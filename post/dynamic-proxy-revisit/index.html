<!DOCTYPE HTML>
<html lang="en-us">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /> 
    <title>Dynamic Proxy revisit - Chao Yang</title>
    <meta name="keywords" content="Java, Programming, Android, JavaScript, Angular, Kotlin, Swift, iOS, Machine Learning, Big Data">
    
    <meta property="og:title" content="Dynamic Proxy revisit">
    <meta property="og:site_name" content="Chao Yang">
    <meta property="og:image" content="/img/author.jpg"> 
    <meta name="title" content="Dynamic Proxy revisit - Chao Yang" />
    <meta name="description" content="A Developer in New Zealand"> 
    
    <link rel="shortcut icon" href="http://yangchao.me/img/favicon.ico" />
    <link rel="apple-touch-icon" href="http://yangchao.me/img/apple-touch-icon.png" />
    <link rel="apple-touch-icon-precomposed" href="http://yangchao.me/img/apple-touch-icon.png" />
    <link href="http://yangchao.me/js/vendor/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />
    <link href="http://yangchao.me/js/vendor/fancybox/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />
    <link href="http://yangchao.me/css/main.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
     fancybox: true, 
    motion: true
  };
</script>
    
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/styles/default.min.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/languages/kotlin.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/languages/swift.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/languages/typescript.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

</head>
<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
<div class="container one-collumn sidebar-position-left page-home  ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-meta  custom-logo ">

  <div class="custom-logo-site-title">
    <a href="http://yangchao.me/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Chao Yang</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">Nothing seek, nothing find</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
    <ul id="menu" class="menu">
      
      
        <li class="menu-item ">
          <a href="http://yangchao.me/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Home
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://www.gitbook.com/@richardyangchao" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />Books
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://yangchao.me/showcase/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-code"></i> <br />Showcase
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://linkedin.com/in/richardyangchao" rel="section">
              <i class="menu-item-icon fa fa-fw fa-linkedin"></i> <br />Résumé
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://yangchao.me/post/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />Archive
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://yangchao.me/about/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />About
          </a>
        </li>
      
    </ul>
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
<section id="posts" class="posts-expand">
  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link" href="http://yangchao.me/post/dynamic-proxy-revisit/" itemprop="url">
        Dynamic Proxy revisit
        </a>
      </h1>
      <div class="post-meta">
      <span class="post-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-o"></i>
</span>
<span class="post-meta-item-text">Published at:</span>
<time itemprop="dateCreated" datetime="2016-03-22T13:04:35+08:00" content="2016-08-15">
    2016-08-15
</time>
</span> 
      
       <span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-eye"></i>
</span>
<span class="post-meta-item-text">Reading:</span>
<span class="leancloud-visitors-count">16491 words ~78min</span>
</span>
      </div>
    </header>
    <div class="post-body" itemprop="articleBody">
    

<h1 id="dynamic-proxy-in-jdk">Dynamic Proxy in JDK</h1>

<p><code>Proxy</code> is a class which can get the proxy class and create the proxy instance. It has a private default constructor and a protected constructor with a contractor argument: <code>InvocationHandler</code>.</p>

<p><code>InvocationHandler</code> is an interface which we can apply our code into the generated proxy class. It has only one method: <code>Object invoke(Object proxy, Method method, Object[] args)</code></p>

<p>Proxy has four static methods:</p>

<pre><code class="language-java">static Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;... interfaces)
static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)
static boolean isProxyClass(Class&lt;?&gt; cl)
static InvocationHandler getInvocationHandler(Object proxy)
</code></pre>

<p>Now let us see how to generate a proxy class in memory. The main logic is in <code>ProxyClassFactory</code>: firstly it call the <code>ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags)</code> to generate the bytes of class file, and then it invokes the native method of Proxy <code>static native Class&lt;?&gt; defineClass0(ClassLoader loader, String name, byte[] b, int off, int len)</code> to load and resolve the bytes into a <code>Class</code>.</p>

<p>So the two static methods <code>ProxyGenerator.generateProxyClass(..)</code> and <code>Proxy.defineClass0(..)</code> are very important.</p>

<p><code>Proxy.defineClass0(..)</code> makes that we don&rsquo;t need to define a ClassLoader to load a class from raw bytes. We will use it as a utility method later.</p>

<p><code>ProxyGenerator</code> has no secret since it just generates the bytecode following the class file format in the JVM specification.
<!-- more --></p>

<pre><code class="language-java">// https://github.com/openjdk-mirror/jdk7u-jdk/blob/master/src/share/classes/sun/misc/ProxyGenerator.java
package sun.misc;

import java.io.ByteArrayOutputStream;
import java.io.DataOutputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.lang.reflect.Array;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import sun.security.action.GetBooleanAction;

/**
 * ProxyGenerator contains the code to generate a dynamic proxy class
 * for the java.lang.reflect.Proxy API.
 *
 * The external interfaces to ProxyGenerator is the static
 * &quot;generateProxyClass&quot; method.
 *
 * @author      Peter Jones
 * @since       1.3
 */
public class ProxyGenerator {
    /*
     * In the comments below, &quot;JVMS&quot; refers to The Java Virtual Machine
     * Specification Second Edition and &quot;JLS&quot; refers to the original
     * version of The Java Language Specification, unless otherwise
     * specified.
     */

    /* generate 1.5-era class file version */
    private static final int CLASSFILE_MAJOR_VERSION = 49;
    private static final int CLASSFILE_MINOR_VERSION = 0;

    /*
     * beginning of constants copied from
     * sun.tools.java.RuntimeConstants (which no longer exists):
     */

    /* constant pool tags */
    private static final int CONSTANT_UTF8              = 1;
    private static final int CONSTANT_UNICODE           = 2;
    private static final int CONSTANT_INTEGER           = 3;
    private static final int CONSTANT_FLOAT             = 4;
    private static final int CONSTANT_LONG              = 5;
    private static final int CONSTANT_DOUBLE            = 6;
    private static final int CONSTANT_CLASS             = 7;
    private static final int CONSTANT_STRING            = 8;
    private static final int CONSTANT_FIELD             = 9;
    private static final int CONSTANT_METHOD            = 10;
    private static final int CONSTANT_INTERFACEMETHOD   = 11;
    private static final int CONSTANT_NAMEANDTYPE       = 12;

    /* access and modifier flags */
    private static final int ACC_PUBLIC                 = 0x00000001;
    private static final int ACC_PRIVATE                = 0x00000002;
//  private static final int ACC_PROTECTED              = 0x00000004;
    private static final int ACC_STATIC                 = 0x00000008;
    private static final int ACC_FINAL                  = 0x00000010;
//  private static final int ACC_SYNCHRONIZED           = 0x00000020;
//  private static final int ACC_VOLATILE               = 0x00000040;
//  private static final int ACC_TRANSIENT              = 0x00000080;
//  private static final int ACC_NATIVE                 = 0x00000100;
//  private static final int ACC_INTERFACE              = 0x00000200;
//  private static final int ACC_ABSTRACT               = 0x00000400;
    private static final int ACC_SUPER                  = 0x00000020;
//  private static final int ACC_STRICT                 = 0x00000800;

    /* opcodes */
//  private static final int opc_nop                    = 0;
    private static final int opc_aconst_null            = 1;
//  private static final int opc_iconst_m1              = 2;
    private static final int opc_iconst_0               = 3;
//  private static final int opc_iconst_1               = 4;
//  private static final int opc_iconst_2               = 5;
//  private static final int opc_iconst_3               = 6;
//  private static final int opc_iconst_4               = 7;
//  private static final int opc_iconst_5               = 8;
//  private static final int opc_lconst_0               = 9;
//  private static final int opc_lconst_1               = 10;
//  private static final int opc_fconst_0               = 11;
//  private static final int opc_fconst_1               = 12;
//  private static final int opc_fconst_2               = 13;
//  private static final int opc_dconst_0               = 14;
//  private static final int opc_dconst_1               = 15;
    private static final int opc_bipush                 = 16;
    private static final int opc_sipush                 = 17;
    private static final int opc_ldc                    = 18;
    private static final int opc_ldc_w                  = 19;
//  private static final int opc_ldc2_w                 = 20;
    private static final int opc_iload                  = 21;
    private static final int opc_lload                  = 22;
    private static final int opc_fload                  = 23;
    private static final int opc_dload                  = 24;
    private static final int opc_aload                  = 25;
    private static final int opc_iload_0                = 26;
//  private static final int opc_iload_1                = 27;
//  private static final int opc_iload_2                = 28;
//  private static final int opc_iload_3                = 29;
    private static final int opc_lload_0                = 30;
//  private static final int opc_lload_1                = 31;
//  private static final int opc_lload_2                = 32;
//  private static final int opc_lload_3                = 33;
    private static final int opc_fload_0                = 34;
//  private static final int opc_fload_1                = 35;
//  private static final int opc_fload_2                = 36;
//  private static final int opc_fload_3                = 37;
    private static final int opc_dload_0                = 38;
//  private static final int opc_dload_1                = 39;
//  private static final int opc_dload_2                = 40;
//  private static final int opc_dload_3                = 41;
    private static final int opc_aload_0                = 42;
//  private static final int opc_aload_1                = 43;
//  private static final int opc_aload_2                = 44;
//  private static final int opc_aload_3                = 45;
//  private static final int opc_iaload                 = 46;
//  private static final int opc_laload                 = 47;
//  private static final int opc_faload                 = 48;
//  private static final int opc_daload                 = 49;
//  private static final int opc_aaload                 = 50;
//  private static final int opc_baload                 = 51;
//  private static final int opc_caload                 = 52;
//  private static final int opc_saload                 = 53;
//  private static final int opc_istore                 = 54;
//  private static final int opc_lstore                 = 55;
//  private static final int opc_fstore                 = 56;
//  private static final int opc_dstore                 = 57;
    private static final int opc_astore                 = 58;
//  private static final int opc_istore_0               = 59;
//  private static final int opc_istore_1               = 60;
//  private static final int opc_istore_2               = 61;
//  private static final int opc_istore_3               = 62;
//  private static final int opc_lstore_0               = 63;
//  private static final int opc_lstore_1               = 64;
//  private static final int opc_lstore_2               = 65;
//  private static final int opc_lstore_3               = 66;
//  private static final int opc_fstore_0               = 67;
//  private static final int opc_fstore_1               = 68;
//  private static final int opc_fstore_2               = 69;
//  private static final int opc_fstore_3               = 70;
//  private static final int opc_dstore_0               = 71;
//  private static final int opc_dstore_1               = 72;
//  private static final int opc_dstore_2               = 73;
//  private static final int opc_dstore_3               = 74;
    private static final int opc_astore_0               = 75;
//  private static final int opc_astore_1               = 76;
//  private static final int opc_astore_2               = 77;
//  private static final int opc_astore_3               = 78;
//  private static final int opc_iastore                = 79;
//  private static final int opc_lastore                = 80;
//  private static final int opc_fastore                = 81;
//  private static final int opc_dastore                = 82;
    private static final int opc_aastore                = 83;
//  private static final int opc_bastore                = 84;
//  private static final int opc_castore                = 85;
//  private static final int opc_sastore                = 86;
    private static final int opc_pop                    = 87;
//  private static final int opc_pop2                   = 88;
    private static final int opc_dup                    = 89;
//  private static final int opc_dup_x1                 = 90;
//  private static final int opc_dup_x2                 = 91;
//  private static final int opc_dup2                   = 92;
//  private static final int opc_dup2_x1                = 93;
//  private static final int opc_dup2_x2                = 94;
//  private static final int opc_swap                   = 95;
//  private static final int opc_iadd                   = 96;
//  private static final int opc_ladd                   = 97;
//  private static final int opc_fadd                   = 98;
//  private static final int opc_dadd                   = 99;
//  private static final int opc_isub                   = 100;
//  private static final int opc_lsub                   = 101;
//  private static final int opc_fsub                   = 102;
//  private static final int opc_dsub                   = 103;
//  private static final int opc_imul                   = 104;
//  private static final int opc_lmul                   = 105;
//  private static final int opc_fmul                   = 106;
//  private static final int opc_dmul                   = 107;
//  private static final int opc_idiv                   = 108;
//  private static final int opc_ldiv                   = 109;
//  private static final int opc_fdiv                   = 110;
//  private static final int opc_ddiv                   = 111;
//  private static final int opc_irem                   = 112;
//  private static final int opc_lrem                   = 113;
//  private static final int opc_frem                   = 114;
//  private static final int opc_drem                   = 115;
//  private static final int opc_ineg                   = 116;
//  private static final int opc_lneg                   = 117;
//  private static final int opc_fneg                   = 118;
//  private static final int opc_dneg                   = 119;
//  private static final int opc_ishl                   = 120;
//  private static final int opc_lshl                   = 121;
//  private static final int opc_ishr                   = 122;
//  private static final int opc_lshr                   = 123;
//  private static final int opc_iushr                  = 124;
//  private static final int opc_lushr                  = 125;
//  private static final int opc_iand                   = 126;
//  private static final int opc_land                   = 127;
//  private static final int opc_ior                    = 128;
//  private static final int opc_lor                    = 129;
//  private static final int opc_ixor                   = 130;
//  private static final int opc_lxor                   = 131;
//  private static final int opc_iinc                   = 132;
//  private static final int opc_i2l                    = 133;
//  private static final int opc_i2f                    = 134;
//  private static final int opc_i2d                    = 135;
//  private static final int opc_l2i                    = 136;
//  private static final int opc_l2f                    = 137;
//  private static final int opc_l2d                    = 138;
//  private static final int opc_f2i                    = 139;
//  private static final int opc_f2l                    = 140;
//  private static final int opc_f2d                    = 141;
//  private static final int opc_d2i                    = 142;
//  private static final int opc_d2l                    = 143;
//  private static final int opc_d2f                    = 144;
//  private static final int opc_i2b                    = 145;
//  private static final int opc_i2c                    = 146;
//  private static final int opc_i2s                    = 147;
//  private static final int opc_lcmp                   = 148;
//  private static final int opc_fcmpl                  = 149;
//  private static final int opc_fcmpg                  = 150;
//  private static final int opc_dcmpl                  = 151;
//  private static final int opc_dcmpg                  = 152;
//  private static final int opc_ifeq                   = 153;
//  private static final int opc_ifne                   = 154;
//  private static final int opc_iflt                   = 155;
//  private static final int opc_ifge                   = 156;
//  private static final int opc_ifgt                   = 157;
//  private static final int opc_ifle                   = 158;
//  private static final int opc_if_icmpeq              = 159;
//  private static final int opc_if_icmpne              = 160;
//  private static final int opc_if_icmplt              = 161;
//  private static final int opc_if_icmpge              = 162;
//  private static final int opc_if_icmpgt              = 163;
//  private static final int opc_if_icmple              = 164;
//  private static final int opc_if_acmpeq              = 165;
//  private static final int opc_if_acmpne              = 166;
//  private static final int opc_goto                   = 167;
//  private static final int opc_jsr                    = 168;
//  private static final int opc_ret                    = 169;
//  private static final int opc_tableswitch            = 170;
//  private static final int opc_lookupswitch           = 171;
    private static final int opc_ireturn                = 172;
    private static final int opc_lreturn                = 173;
    private static final int opc_freturn                = 174;
    private static final int opc_dreturn                = 175;
    private static final int opc_areturn                = 176;
    private static final int opc_return                 = 177;
    private static final int opc_getstatic              = 178;
    private static final int opc_putstatic              = 179;
    private static final int opc_getfield               = 180;
//  private static final int opc_putfield               = 181;
    private static final int opc_invokevirtual          = 182;
    private static final int opc_invokespecial          = 183;
    private static final int opc_invokestatic           = 184;
    private static final int opc_invokeinterface        = 185;
    private static final int opc_new                    = 187;
//  private static final int opc_newarray               = 188;
    private static final int opc_anewarray              = 189;
//  private static final int opc_arraylength            = 190;
    private static final int opc_athrow                 = 191;
    private static final int opc_checkcast              = 192;
//  private static final int opc_instanceof             = 193;
//  private static final int opc_monitorenter           = 194;
//  private static final int opc_monitorexit            = 195;
    private static final int opc_wide                   = 196;
//  private static final int opc_multianewarray         = 197;
//  private static final int opc_ifnull                 = 198;
//  private static final int opc_ifnonnull              = 199;
//  private static final int opc_goto_w                 = 200;
//  private static final int opc_jsr_w                  = 201;

    // end of constants copied from sun.tools.java.RuntimeConstants

    /** name of the superclass of proxy classes */
    private final static String superclassName = &quot;java/lang/reflect/Proxy&quot;;

    /** name of field for storing a proxy instance's invocation handler */
    private final static String handlerFieldName = &quot;h&quot;;

    /** debugging flag for saving generated class files */
    private final static boolean saveGeneratedFiles =
        java.security.AccessController.doPrivileged(
            new GetBooleanAction(
                &quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;)).booleanValue();

    /**
     * Generate a proxy class given a name and a list of proxy interfaces.
     */
    public static byte[] generateProxyClass(final String name,
                                            Class[] interfaces)
    {
        ProxyGenerator gen = new ProxyGenerator(name, interfaces);
        final byte[] classFile = gen.generateClassFile();

        if (saveGeneratedFiles) {
            java.security.AccessController.doPrivileged(
            new java.security.PrivilegedAction&lt;Void&gt;() {
                public Void run() {
                    try {
                        FileOutputStream file =
                            new FileOutputStream(dotToSlash(name) + &quot;.class&quot;);
                        file.write(classFile);
                        file.close();
                        return null;
                    } catch (IOException e) {
                        throw new InternalError(
                            &quot;I/O exception saving generated file: &quot; + e);
                    }
                }
            });
        }

        return classFile;
    }

    /* preloaded Method objects for methods in java.lang.Object */
    private static Method hashCodeMethod;
    private static Method equalsMethod;
    private static Method toStringMethod;
    static {
        try {
            hashCodeMethod = Object.class.getMethod(&quot;hashCode&quot;);
            equalsMethod =
                Object.class.getMethod(&quot;equals&quot;, new Class[] { Object.class });
            toStringMethod = Object.class.getMethod(&quot;toString&quot;);
        } catch (NoSuchMethodException e) {
            throw new NoSuchMethodError(e.getMessage());
        }
    }

    /** name of proxy class */
    private String className;

    /** proxy interfaces */
    private Class[] interfaces;

    /** constant pool of class being generated */
    private ConstantPool cp = new ConstantPool();

    /** FieldInfo struct for each field of generated class */
    private List&lt;FieldInfo&gt; fields = new ArrayList&lt;FieldInfo&gt;();

    /** MethodInfo struct for each method of generated class */
    private List&lt;MethodInfo&gt; methods = new ArrayList&lt;MethodInfo&gt;();

    /**
     * maps method signature string to list of ProxyMethod objects for
     * proxy methods with that signature
     */
    private Map&lt;String, List&lt;ProxyMethod&gt;&gt; proxyMethods =
        new HashMap&lt;String,List&lt;ProxyMethod&gt;&gt;();

    /** count of ProxyMethod objects added to proxyMethods */
    private int proxyMethodCount = 0;

    /**
     * Construct a ProxyGenerator to generate a proxy class with the
     * specified name and for the given interfaces.
     *
     * A ProxyGenerator object contains the state for the ongoing
     * generation of a particular proxy class.
     */
    private ProxyGenerator(String className, Class[] interfaces) {
        this.className = className;
        this.interfaces = interfaces;
    }

    /**
     * Generate a class file for the proxy class.  This method drives the
     * class file generation process.
     */
    private byte[] generateClassFile() {

        /* ============================================================
         * Step 1: Assemble ProxyMethod objects for all methods to
         * generate proxy dispatching code for.
         */

        /*
         * Record that proxy methods are needed for the hashCode, equals,
         * and toString methods of java.lang.Object.  This is done before
         * the methods from the proxy interfaces so that the methods from
         * java.lang.Object take precedence over duplicate methods in the
         * proxy interfaces.
         */
        addProxyMethod(hashCodeMethod, Object.class);
        addProxyMethod(equalsMethod, Object.class);
        addProxyMethod(toStringMethod, Object.class);

        /*
         * Now record all of the methods from the proxy interfaces, giving
         * earlier interfaces precedence over later ones with duplicate
         * methods.
         */
        for (int i = 0; i &lt; interfaces.length; i++) {
            Method[] methods = interfaces[i].getMethods();
            for (int j = 0; j &lt; methods.length; j++) {
                addProxyMethod(methods[j], interfaces[i]);
            }
        }

        /*
         * For each set of proxy methods with the same signature,
         * verify that the methods' return types are compatible.
         */
        for (List&lt;ProxyMethod&gt; sigmethods : proxyMethods.values()) {
            checkReturnTypes(sigmethods);
        }

        /* ============================================================
         * Step 2: Assemble FieldInfo and MethodInfo structs for all of
         * fields and methods in the class we are generating.
         */
        try {
            methods.add(generateConstructor());

            for (List&lt;ProxyMethod&gt; sigmethods : proxyMethods.values()) {
                for (ProxyMethod pm : sigmethods) {

                    // add static field for method's Method object
                    fields.add(new FieldInfo(pm.methodFieldName,
                        &quot;Ljava/lang/reflect/Method;&quot;,
                         ACC_PRIVATE | ACC_STATIC));

                    // generate code for proxy method and add it
                    methods.add(pm.generateMethod());
                }
            }

            methods.add(generateStaticInitializer());

        } catch (IOException e) {
            throw new InternalError(&quot;unexpected I/O Exception&quot;);
        }

        if (methods.size() &gt; 65535) {
            throw new IllegalArgumentException(&quot;method limit exceeded&quot;);
        }
        if (fields.size() &gt; 65535) {
            throw new IllegalArgumentException(&quot;field limit exceeded&quot;);
        }

        /* ============================================================
         * Step 3: Write the final class file.
         */

        /*
         * Make sure that constant pool indexes are reserved for the
         * following items before starting to write the final class file.
         */
        cp.getClass(dotToSlash(className));
        cp.getClass(superclassName);
        for (int i = 0; i &lt; interfaces.length; i++) {
            cp.getClass(dotToSlash(interfaces[i].getName()));
        }

        /*
         * Disallow new constant pool additions beyond this point, since
         * we are about to write the final constant pool table.
         */
        cp.setReadOnly();

        ByteArrayOutputStream bout = new ByteArrayOutputStream();
        DataOutputStream dout = new DataOutputStream(bout);

        try {
            /*
             * Write all the items of the &quot;ClassFile&quot; structure.
             * See JVMS section 4.1.
             */
                                        // u4 magic;
            dout.writeInt(0xCAFEBABE);
                                        // u2 minor_version;
            dout.writeShort(CLASSFILE_MINOR_VERSION);
                                        // u2 major_version;
            dout.writeShort(CLASSFILE_MAJOR_VERSION);

            cp.write(dout);             // (write constant pool)

                                        // u2 access_flags;
            dout.writeShort(ACC_PUBLIC | ACC_FINAL | ACC_SUPER);
                                        // u2 this_class;
            dout.writeShort(cp.getClass(dotToSlash(className)));
                                        // u2 super_class;
            dout.writeShort(cp.getClass(superclassName));

                                        // u2 interfaces_count;
            dout.writeShort(interfaces.length);
                                        // u2 interfaces[interfaces_count];
            for (int i = 0; i &lt; interfaces.length; i++) {
                dout.writeShort(cp.getClass(
                    dotToSlash(interfaces[i].getName())));
            }

                                        // u2 fields_count;
            dout.writeShort(fields.size());
                                        // field_info fields[fields_count];
            for (FieldInfo f : fields) {
                f.write(dout);
            }

                                        // u2 methods_count;
            dout.writeShort(methods.size());
                                        // method_info methods[methods_count];
            for (MethodInfo m : methods) {
                m.write(dout);
            }

                                         // u2 attributes_count;
            dout.writeShort(0); // (no ClassFile attributes for proxy classes)

        } catch (IOException e) {
            throw new InternalError(&quot;unexpected I/O Exception&quot;);
        }

        return bout.toByteArray();
    }

    /**
     * Add another method to be proxied, either by creating a new
     * ProxyMethod object or augmenting an old one for a duplicate
     * method.
     *
     * &quot;fromClass&quot; indicates the proxy interface that the method was
     * found through, which may be different from (a subinterface of)
     * the method's &quot;declaring class&quot;.  Note that the first Method
     * object passed for a given name and descriptor identifies the
     * Method object (and thus the declaring class) that will be
     * passed to the invocation handler's &quot;invoke&quot; method for a given
     * set of duplicate methods.
     */
    private void addProxyMethod(Method m, Class fromClass) {
        String name = m.getName();
        Class[] parameterTypes = m.getParameterTypes();
        Class returnType = m.getReturnType();
        Class[] exceptionTypes = m.getExceptionTypes();

        String sig = name + getParameterDescriptors(parameterTypes);
        List&lt;ProxyMethod&gt; sigmethods = proxyMethods.get(sig);
        if (sigmethods != null) {
            for (ProxyMethod pm : sigmethods) {
                if (returnType == pm.returnType) {
                    /*
                     * Found a match: reduce exception types to the
                     * greatest set of exceptions that can thrown
                     * compatibly with the throws clauses of both
                     * overridden methods.
                     */
                    List&lt;Class&lt;?&gt;&gt; legalExceptions = new ArrayList&lt;Class&lt;?&gt;&gt;();
                    collectCompatibleTypes(
                        exceptionTypes, pm.exceptionTypes, legalExceptions);
                    collectCompatibleTypes(
                        pm.exceptionTypes, exceptionTypes, legalExceptions);
                    pm.exceptionTypes = new Class[legalExceptions.size()];
                    pm.exceptionTypes =
                        legalExceptions.toArray(pm.exceptionTypes);
                    return;
                }
            }
        } else {
            sigmethods = new ArrayList&lt;ProxyMethod&gt;(3);
            proxyMethods.put(sig, sigmethods);
        }
        sigmethods.add(new ProxyMethod(name, parameterTypes, returnType,
                                       exceptionTypes, fromClass));
    }

    /**
     * For a given set of proxy methods with the same signature, check
     * that their return types are compatible according to the Proxy
     * specification.
     *
     * Specifically, if there is more than one such method, then all
     * of the return types must be reference types, and there must be
     * one return type that is assignable to each of the rest of them.
     */
    private static void checkReturnTypes(List&lt;ProxyMethod&gt; methods) {
        /*
         * If there is only one method with a given signature, there
         * cannot be a conflict.  This is the only case in which a
         * primitive (or void) return type is allowed.
         */
        if (methods.size() &lt; 2) {
            return;
        }

        /*
         * List of return types that are not yet known to be
         * assignable from (&quot;covered&quot; by) any of the others.
         */
        LinkedList&lt;Class&lt;?&gt;&gt; uncoveredReturnTypes = new LinkedList&lt;Class&lt;?&gt;&gt;();

    nextNewReturnType:
        for (ProxyMethod pm : methods) {
            Class&lt;?&gt; newReturnType = pm.returnType;
            if (newReturnType.isPrimitive()) {
                throw new IllegalArgumentException(
                    &quot;methods with same signature &quot; +
                    getFriendlyMethodSignature(pm.methodName,
                                               pm.parameterTypes) +
                    &quot; but incompatible return types: &quot; +
                    newReturnType.getName() + &quot; and others&quot;);
            }
            boolean added = false;

            /*
             * Compare the new return type to the existing uncovered
             * return types.
             */
            ListIterator&lt;Class&lt;?&gt;&gt; liter = uncoveredReturnTypes.listIterator();
            while (liter.hasNext()) {
                Class&lt;?&gt; uncoveredReturnType = liter.next();

                /*
                 * If an existing uncovered return type is assignable
                 * to this new one, then we can forget the new one.
                 */
                if (newReturnType.isAssignableFrom(uncoveredReturnType)) {
                    assert !added;
                    continue nextNewReturnType;
                }

                /*
                 * If the new return type is assignable to an existing
                 * uncovered one, then should replace the existing one
                 * with the new one (or just forget the existing one,
                 * if the new one has already be put in the list).
                 */
                if (uncoveredReturnType.isAssignableFrom(newReturnType)) {
                    // (we can assume that each return type is unique)
                    if (!added) {
                        liter.set(newReturnType);
                        added = true;
                    } else {
                        liter.remove();
                    }
                }
            }

            /*
             * If we got through the list of existing uncovered return
             * types without an assignability relationship, then add
             * the new return type to the list of uncovered ones.
             */
            if (!added) {
                uncoveredReturnTypes.add(newReturnType);
            }
        }

        /*
         * We shouldn't end up with more than one return type that is
         * not assignable from any of the others.
         */
        if (uncoveredReturnTypes.size() &gt; 1) {
            ProxyMethod pm = methods.get(0);
            throw new IllegalArgumentException(
                &quot;methods with same signature &quot; +
                getFriendlyMethodSignature(pm.methodName, pm.parameterTypes) +
                &quot; but incompatible return types: &quot; + uncoveredReturnTypes);
        }
    }

    /**
     * A FieldInfo object contains information about a particular field
     * in the class being generated.  The class mirrors the data items of
     * the &quot;field_info&quot; structure of the class file format (see JVMS 4.5).
     */
    private class FieldInfo {
        public int accessFlags;
        public String name;
        public String descriptor;

        public FieldInfo(String name, String descriptor, int accessFlags) {
            this.name = name;
            this.descriptor = descriptor;
            this.accessFlags = accessFlags;

            /*
             * Make sure that constant pool indexes are reserved for the
             * following items before starting to write the final class file.
             */
            cp.getUtf8(name);
            cp.getUtf8(descriptor);
        }

        public void write(DataOutputStream out) throws IOException {
            /*
             * Write all the items of the &quot;field_info&quot; structure.
             * See JVMS section 4.5.
             */
                                        // u2 access_flags;
            out.writeShort(accessFlags);
                                        // u2 name_index;
            out.writeShort(cp.getUtf8(name));
                                        // u2 descriptor_index;
            out.writeShort(cp.getUtf8(descriptor));
                                        // u2 attributes_count;
            out.writeShort(0);  // (no field_info attributes for proxy classes)
        }
    }

    /**
     * An ExceptionTableEntry object holds values for the data items of
     * an entry in the &quot;exception_table&quot; item of the &quot;Code&quot; attribute of
     * &quot;method_info&quot; structures (see JVMS 4.7.3).
     */
    private static class ExceptionTableEntry {
        public short startPc;
        public short endPc;
        public short handlerPc;
        public short catchType;

        public ExceptionTableEntry(short startPc, short endPc,
                                   short handlerPc, short catchType)
        {
            this.startPc = startPc;
            this.endPc = endPc;
            this.handlerPc = handlerPc;
            this.catchType = catchType;
        }
    };

    /**
     * A MethodInfo object contains information about a particular method
     * in the class being generated.  This class mirrors the data items of
     * the &quot;method_info&quot; structure of the class file format (see JVMS 4.6).
     */
    private class MethodInfo {
        public int accessFlags;
        public String name;
        public String descriptor;
        public short maxStack;
        public short maxLocals;
        public ByteArrayOutputStream code = new ByteArrayOutputStream();
        public List&lt;ExceptionTableEntry&gt; exceptionTable =
            new ArrayList&lt;ExceptionTableEntry&gt;();
        public short[] declaredExceptions;

        public MethodInfo(String name, String descriptor, int accessFlags) {
            this.name = name;
            this.descriptor = descriptor;
            this.accessFlags = accessFlags;

            /*
             * Make sure that constant pool indexes are reserved for the
             * following items before starting to write the final class file.
             */
            cp.getUtf8(name);
            cp.getUtf8(descriptor);
            cp.getUtf8(&quot;Code&quot;);
            cp.getUtf8(&quot;Exceptions&quot;);
        }

        public void write(DataOutputStream out) throws IOException {
            /*
             * Write all the items of the &quot;method_info&quot; structure.
             * See JVMS section 4.6.
             */
                                        // u2 access_flags;
            out.writeShort(accessFlags);
                                        // u2 name_index;
            out.writeShort(cp.getUtf8(name));
                                        // u2 descriptor_index;
            out.writeShort(cp.getUtf8(descriptor));
                                        // u2 attributes_count;
            out.writeShort(2);  // (two method_info attributes:)

            // Write &quot;Code&quot; attribute. See JVMS section 4.7.3.

                                        // u2 attribute_name_index;
            out.writeShort(cp.getUtf8(&quot;Code&quot;));
                                        // u4 attribute_length;
            out.writeInt(12 + code.size() + 8 * exceptionTable.size());
                                        // u2 max_stack;
            out.writeShort(maxStack);
                                        // u2 max_locals;
            out.writeShort(maxLocals);
                                        // u2 code_length;
            out.writeInt(code.size());
                                        // u1 code[code_length];
            code.writeTo(out);
                                        // u2 exception_table_length;
            out.writeShort(exceptionTable.size());
            for (ExceptionTableEntry e : exceptionTable) {
                                        // u2 start_pc;
                out.writeShort(e.startPc);
                                        // u2 end_pc;
                out.writeShort(e.endPc);
                                        // u2 handler_pc;
                out.writeShort(e.handlerPc);
                                        // u2 catch_type;
                out.writeShort(e.catchType);
            }
                                        // u2 attributes_count;
            out.writeShort(0);

            // write &quot;Exceptions&quot; attribute.  See JVMS section 4.7.4.

                                        // u2 attribute_name_index;
            out.writeShort(cp.getUtf8(&quot;Exceptions&quot;));
                                        // u4 attributes_length;
            out.writeInt(2 + 2 * declaredExceptions.length);
                                        // u2 number_of_exceptions;
            out.writeShort(declaredExceptions.length);
                        // u2 exception_index_table[number_of_exceptions];
            for (int i = 0; i &lt; declaredExceptions.length; i++) {
                out.writeShort(declaredExceptions[i]);
            }
        }

    }

    /**
     * A ProxyMethod object represents a proxy method in the proxy class
     * being generated: a method whose implementation will encode and
     * dispatch invocations to the proxy instance's invocation handler.
     */
    private class ProxyMethod {

        public String methodName;
        public Class[] parameterTypes;
        public Class returnType;
        public Class[] exceptionTypes;
        public Class fromClass;
        public String methodFieldName;

        private ProxyMethod(String methodName, Class[] parameterTypes,
                            Class returnType, Class[] exceptionTypes,
                            Class fromClass)
        {
            this.methodName = methodName;
            this.parameterTypes = parameterTypes;
            this.returnType = returnType;
            this.exceptionTypes = exceptionTypes;
            this.fromClass = fromClass;
            this.methodFieldName = &quot;m&quot; + proxyMethodCount++;
        }

        /**
         * Return a MethodInfo object for this method, including generating
         * the code and exception table entry.
         */
        private MethodInfo generateMethod() throws IOException {
            String desc = getMethodDescriptor(parameterTypes, returnType);
            MethodInfo minfo = new MethodInfo(methodName, desc,
                ACC_PUBLIC | ACC_FINAL);

            int[] parameterSlot = new int[parameterTypes.length];
            int nextSlot = 1;
            for (int i = 0; i &lt; parameterSlot.length; i++) {
                parameterSlot[i] = nextSlot;
                nextSlot += getWordsPerType(parameterTypes[i]);
            }
            int localSlot0 = nextSlot;
            short pc, tryBegin = 0, tryEnd;

            DataOutputStream out = new DataOutputStream(minfo.code);

            code_aload(0, out);

            out.writeByte(opc_getfield);
            out.writeShort(cp.getFieldRef(
                superclassName,
                handlerFieldName, &quot;Ljava/lang/reflect/InvocationHandler;&quot;));

            code_aload(0, out);

            out.writeByte(opc_getstatic);
            out.writeShort(cp.getFieldRef(
                dotToSlash(className),
                methodFieldName, &quot;Ljava/lang/reflect/Method;&quot;));

            if (parameterTypes.length &gt; 0) {

                code_ipush(parameterTypes.length, out);

                out.writeByte(opc_anewarray);
                out.writeShort(cp.getClass(&quot;java/lang/Object&quot;));

                for (int i = 0; i &lt; parameterTypes.length; i++) {

                    out.writeByte(opc_dup);

                    code_ipush(i, out);

                    codeWrapArgument(parameterTypes[i], parameterSlot[i], out);

                    out.writeByte(opc_aastore);
                }
            } else {

                out.writeByte(opc_aconst_null);
            }

            out.writeByte(opc_invokeinterface);
            out.writeShort(cp.getInterfaceMethodRef(
                &quot;java/lang/reflect/InvocationHandler&quot;,
                &quot;invoke&quot;,
                &quot;(Ljava/lang/Object;Ljava/lang/reflect/Method;&quot; +
                    &quot;[Ljava/lang/Object;)Ljava/lang/Object;&quot;));
            out.writeByte(4);
            out.writeByte(0);

            if (returnType == void.class) {

                out.writeByte(opc_pop);

                out.writeByte(opc_return);

            } else {

                codeUnwrapReturnValue(returnType, out);
            }

            tryEnd = pc = (short) minfo.code.size();

            List&lt;Class&lt;?&gt;&gt; catchList = computeUniqueCatchList(exceptionTypes);
            if (catchList.size() &gt; 0) {

                for (Class&lt;?&gt; ex : catchList) {
                    minfo.exceptionTable.add(new ExceptionTableEntry(
                        tryBegin, tryEnd, pc,
                        cp.getClass(dotToSlash(ex.getName()))));
                }

                out.writeByte(opc_athrow);

                pc = (short) minfo.code.size();

                minfo.exceptionTable.add(new ExceptionTableEntry(
                    tryBegin, tryEnd, pc, cp.getClass(&quot;java/lang/Throwable&quot;)));

                code_astore(localSlot0, out);

                out.writeByte(opc_new);
                out.writeShort(cp.getClass(
                    &quot;java/lang/reflect/UndeclaredThrowableException&quot;));

                out.writeByte(opc_dup);

                code_aload(localSlot0, out);

                out.writeByte(opc_invokespecial);

                out.writeShort(cp.getMethodRef(
                    &quot;java/lang/reflect/UndeclaredThrowableException&quot;,
                    &quot;&lt;init&gt;&quot;, &quot;(Ljava/lang/Throwable;)V&quot;));

                out.writeByte(opc_athrow);
            }

            if (minfo.code.size() &gt; 65535) {
                throw new IllegalArgumentException(&quot;code size limit exceeded&quot;);
            }

            minfo.maxStack = 10;
            minfo.maxLocals = (short) (localSlot0 + 1);
            minfo.declaredExceptions = new short[exceptionTypes.length];
            for (int i = 0; i &lt; exceptionTypes.length; i++) {
                minfo.declaredExceptions[i] = cp.getClass(
                    dotToSlash(exceptionTypes[i].getName()));
            }

            return minfo;
        }

        /**
         * Generate code for wrapping an argument of the given type
         * whose value can be found at the specified local variable
         * index, in order for it to be passed (as an Object) to the
         * invocation handler's &quot;invoke&quot; method.  The code is written
         * to the supplied stream.
         */
        private void codeWrapArgument(Class type, int slot,
                                      DataOutputStream out)
            throws IOException
        {
            if (type.isPrimitive()) {
                PrimitiveTypeInfo prim = PrimitiveTypeInfo.get(type);

                if (type == int.class ||
                    type == boolean.class ||
                    type == byte.class ||
                    type == char.class ||
                    type == short.class)
                {
                    code_iload(slot, out);
                } else if (type == long.class) {
                    code_lload(slot, out);
                } else if (type == float.class) {
                    code_fload(slot, out);
                } else if (type == double.class) {
                    code_dload(slot, out);
                } else {
                    throw new AssertionError();
                }

                out.writeByte(opc_invokestatic);
                out.writeShort(cp.getMethodRef(
                    prim.wrapperClassName,
                    &quot;valueOf&quot;, prim.wrapperValueOfDesc));

            } else {

                code_aload(slot, out);
            }
        }

        /**
         * Generate code for unwrapping a return value of the given
         * type from the invocation handler's &quot;invoke&quot; method (as type
         * Object) to its correct type.  The code is written to the
         * supplied stream.
         */
        private void codeUnwrapReturnValue(Class type, DataOutputStream out)
            throws IOException
        {
            if (type.isPrimitive()) {
                PrimitiveTypeInfo prim = PrimitiveTypeInfo.get(type);

                out.writeByte(opc_checkcast);
                out.writeShort(cp.getClass(prim.wrapperClassName));

                out.writeByte(opc_invokevirtual);
                out.writeShort(cp.getMethodRef(
                    prim.wrapperClassName,
                    prim.unwrapMethodName, prim.unwrapMethodDesc));

                if (type == int.class ||
                    type == boolean.class ||
                    type == byte.class ||
                    type == char.class ||
                    type == short.class)
                {
                    out.writeByte(opc_ireturn);
                } else if (type == long.class) {
                    out.writeByte(opc_lreturn);
                } else if (type == float.class) {
                    out.writeByte(opc_freturn);
                } else if (type == double.class) {
                    out.writeByte(opc_dreturn);
                } else {
                    throw new AssertionError();
                }

            } else {

                out.writeByte(opc_checkcast);
                out.writeShort(cp.getClass(dotToSlash(type.getName())));

                out.writeByte(opc_areturn);
            }
        }

        /**
         * Generate code for initializing the static field that stores
         * the Method object for this proxy method.  The code is written
         * to the supplied stream.
         */
        private void codeFieldInitialization(DataOutputStream out)
            throws IOException
        {
            codeClassForName(fromClass, out);

            code_ldc(cp.getString(methodName), out);

            code_ipush(parameterTypes.length, out);

            out.writeByte(opc_anewarray);
            out.writeShort(cp.getClass(&quot;java/lang/Class&quot;));

            for (int i = 0; i &lt; parameterTypes.length; i++) {

                out.writeByte(opc_dup);

                code_ipush(i, out);

                if (parameterTypes[i].isPrimitive()) {
                    PrimitiveTypeInfo prim =
                        PrimitiveTypeInfo.get(parameterTypes[i]);

                    out.writeByte(opc_getstatic);
                    out.writeShort(cp.getFieldRef(
                        prim.wrapperClassName, &quot;TYPE&quot;, &quot;Ljava/lang/Class;&quot;));

                } else {
                    codeClassForName(parameterTypes[i], out);
                }

                out.writeByte(opc_aastore);
            }

            out.writeByte(opc_invokevirtual);
            out.writeShort(cp.getMethodRef(
                &quot;java/lang/Class&quot;,
                &quot;getMethod&quot;,
                &quot;(Ljava/lang/String;[Ljava/lang/Class;)&quot; +
                &quot;Ljava/lang/reflect/Method;&quot;));

            out.writeByte(opc_putstatic);
            out.writeShort(cp.getFieldRef(
                dotToSlash(className),
                methodFieldName, &quot;Ljava/lang/reflect/Method;&quot;));
        }
    }

    /**
     * Generate the constructor method for the proxy class.
     */
    private MethodInfo generateConstructor() throws IOException {
        MethodInfo minfo = new MethodInfo(
            &quot;&lt;init&gt;&quot;, &quot;(Ljava/lang/reflect/InvocationHandler;)V&quot;,
            ACC_PUBLIC);

        DataOutputStream out = new DataOutputStream(minfo.code);

        code_aload(0, out);

        code_aload(1, out);

        out.writeByte(opc_invokespecial);
        out.writeShort(cp.getMethodRef(
            superclassName,
            &quot;&lt;init&gt;&quot;, &quot;(Ljava/lang/reflect/InvocationHandler;)V&quot;));

        out.writeByte(opc_return);

        minfo.maxStack = 10;
        minfo.maxLocals = 2;
        minfo.declaredExceptions = new short[0];

        return minfo;
    }

    /**
     * Generate the static initializer method for the proxy class.
     */
    private MethodInfo generateStaticInitializer() throws IOException {
        MethodInfo minfo = new MethodInfo(
            &quot;&lt;clinit&gt;&quot;, &quot;()V&quot;, ACC_STATIC);

        int localSlot0 = 1;
        short pc, tryBegin = 0, tryEnd;

        DataOutputStream out = new DataOutputStream(minfo.code);

        for (List&lt;ProxyMethod&gt; sigmethods : proxyMethods.values()) {
            for (ProxyMethod pm : sigmethods) {
                pm.codeFieldInitialization(out);
            }
        }

        out.writeByte(opc_return);

        tryEnd = pc = (short) minfo.code.size();

        minfo.exceptionTable.add(new ExceptionTableEntry(
            tryBegin, tryEnd, pc,
            cp.getClass(&quot;java/lang/NoSuchMethodException&quot;)));

        code_astore(localSlot0, out);

        out.writeByte(opc_new);
        out.writeShort(cp.getClass(&quot;java/lang/NoSuchMethodError&quot;));

        out.writeByte(opc_dup);

        code_aload(localSlot0, out);

        out.writeByte(opc_invokevirtual);
        out.writeShort(cp.getMethodRef(
            &quot;java/lang/Throwable&quot;, &quot;getMessage&quot;, &quot;()Ljava/lang/String;&quot;));

        out.writeByte(opc_invokespecial);
        out.writeShort(cp.getMethodRef(
            &quot;java/lang/NoSuchMethodError&quot;, &quot;&lt;init&gt;&quot;, &quot;(Ljava/lang/String;)V&quot;));

        out.writeByte(opc_athrow);

        pc = (short) minfo.code.size();

        minfo.exceptionTable.add(new ExceptionTableEntry(
            tryBegin, tryEnd, pc,
            cp.getClass(&quot;java/lang/ClassNotFoundException&quot;)));

        code_astore(localSlot0, out);

        out.writeByte(opc_new);
        out.writeShort(cp.getClass(&quot;java/lang/NoClassDefFoundError&quot;));

        out.writeByte(opc_dup);

        code_aload(localSlot0, out);

        out.writeByte(opc_invokevirtual);
        out.writeShort(cp.getMethodRef(
            &quot;java/lang/Throwable&quot;, &quot;getMessage&quot;, &quot;()Ljava/lang/String;&quot;));

        out.writeByte(opc_invokespecial);
        out.writeShort(cp.getMethodRef(
            &quot;java/lang/NoClassDefFoundError&quot;,
            &quot;&lt;init&gt;&quot;, &quot;(Ljava/lang/String;)V&quot;));

        out.writeByte(opc_athrow);

        if (minfo.code.size() &gt; 65535) {
            throw new IllegalArgumentException(&quot;code size limit exceeded&quot;);
        }

        minfo.maxStack = 10;
        minfo.maxLocals = (short) (localSlot0 + 1);
        minfo.declaredExceptions = new short[0];

        return minfo;
    }


    /*
     * =============== Code Generation Utility Methods ===============
     */

    /*
     * The following methods generate code for the load or store operation
     * indicated by their name for the given local variable.  The code is
     * written to the supplied stream.
     */

    private void code_iload(int lvar, DataOutputStream out)
        throws IOException
    {
        codeLocalLoadStore(lvar, opc_iload, opc_iload_0, out);
    }

    private void code_lload(int lvar, DataOutputStream out)
        throws IOException
    {
        codeLocalLoadStore(lvar, opc_lload, opc_lload_0, out);
    }

    private void code_fload(int lvar, DataOutputStream out)
        throws IOException
    {
        codeLocalLoadStore(lvar, opc_fload, opc_fload_0, out);
    }

    private void code_dload(int lvar, DataOutputStream out)
        throws IOException
    {
        codeLocalLoadStore(lvar, opc_dload, opc_dload_0, out);
    }

    private void code_aload(int lvar, DataOutputStream out)
        throws IOException
    {
        codeLocalLoadStore(lvar, opc_aload, opc_aload_0, out);
    }

//  private void code_istore(int lvar, DataOutputStream out)
//      throws IOException
//  {
//      codeLocalLoadStore(lvar, opc_istore, opc_istore_0, out);
//  }

//  private void code_lstore(int lvar, DataOutputStream out)
//      throws IOException
//  {
//      codeLocalLoadStore(lvar, opc_lstore, opc_lstore_0, out);
//  }

//  private void code_fstore(int lvar, DataOutputStream out)
//      throws IOException
//  {
//      codeLocalLoadStore(lvar, opc_fstore, opc_fstore_0, out);
//  }

//  private void code_dstore(int lvar, DataOutputStream out)
//      throws IOException
//  {
//      codeLocalLoadStore(lvar, opc_dstore, opc_dstore_0, out);
//  }

    private void code_astore(int lvar, DataOutputStream out)
        throws IOException
    {
        codeLocalLoadStore(lvar, opc_astore, opc_astore_0, out);
    }

    /**
     * Generate code for a load or store instruction for the given local
     * variable.  The code is written to the supplied stream.
     *
     * &quot;opcode&quot; indicates the opcode form of the desired load or store
     * instruction that takes an explicit local variable index, and
     * &quot;opcode_0&quot; indicates the corresponding form of the instruction
     * with the implicit index 0.
     */
    private void codeLocalLoadStore(int lvar, int opcode, int opcode_0,
                                    DataOutputStream out)
        throws IOException
    {
        assert lvar &gt;= 0 &amp;&amp; lvar &lt;= 0xFFFF;
        if (lvar &lt;= 3) {
            out.writeByte(opcode_0 + lvar);
        } else if (lvar &lt;= 0xFF) {
            out.writeByte(opcode);
            out.writeByte(lvar &amp; 0xFF);
        } else {
            /*
             * Use the &quot;wide&quot; instruction modifier for local variable
             * indexes that do not fit into an unsigned byte.
             */
            out.writeByte(opc_wide);
            out.writeByte(opcode);
            out.writeShort(lvar &amp; 0xFFFF);
        }
    }

    /**
     * Generate code for an &quot;ldc&quot; instruction for the given constant pool
     * index (the &quot;ldc_w&quot; instruction is used if the index does not fit
     * into an unsigned byte).  The code is written to the supplied stream.
     */
    private void code_ldc(int index, DataOutputStream out)
        throws IOException
    {
        assert index &gt;= 0 &amp;&amp; index &lt;= 0xFFFF;
        if (index &lt;= 0xFF) {
            out.writeByte(opc_ldc);
            out.writeByte(index &amp; 0xFF);
        } else {
            out.writeByte(opc_ldc_w);
            out.writeShort(index &amp; 0xFFFF);
        }
    }

    /**
     * Generate code to push a constant integer value on to the operand
     * stack, using the &quot;iconst_&lt;i&gt;&quot;, &quot;bipush&quot;, or &quot;sipush&quot; instructions
     * depending on the size of the value.  The code is written to the
     * supplied stream.
     */
    private void code_ipush(int value, DataOutputStream out)
        throws IOException
    {
        if (value &gt;= -1 &amp;&amp; value &lt;= 5) {
            out.writeByte(opc_iconst_0 + value);
        } else if (value &gt;= Byte.MIN_VALUE &amp;&amp; value &lt;= Byte.MAX_VALUE) {
            out.writeByte(opc_bipush);
            out.writeByte(value &amp; 0xFF);
        } else if (value &gt;= Short.MIN_VALUE &amp;&amp; value &lt;= Short.MAX_VALUE) {
            out.writeByte(opc_sipush);
            out.writeShort(value &amp; 0xFFFF);
        } else {
            throw new AssertionError();
        }
    }

    /**
     * Generate code to invoke the Class.forName with the name of the given
     * class to get its Class object at runtime.  The code is written to
     * the supplied stream.  Note that the code generated by this method
     * may caused the checked ClassNotFoundException to be thrown.
     */
    private void codeClassForName(Class cl, DataOutputStream out)
        throws IOException
    {
        code_ldc(cp.getString(cl.getName()), out);

        out.writeByte(opc_invokestatic);
        out.writeShort(cp.getMethodRef(
            &quot;java/lang/Class&quot;,
            &quot;forName&quot;, &quot;(Ljava/lang/String;)Ljava/lang/Class;&quot;));
    }


    /*
     * ==================== General Utility Methods ====================
     */

    /**
     * Convert a fully qualified class name that uses '.' as the package
     * separator, the external representation used by the Java language
     * and APIs, to a fully qualified class name that uses '/' as the
     * package separator, the representation used in the class file
     * format (see JVMS section 4.2).
     */
    private static String dotToSlash(String name) {
        return name.replace('.', '/');
    }

    /**
     * Return the &quot;method descriptor&quot; string for a method with the given
     * parameter types and return type.  See JVMS section 4.3.3.
     */
    private static String getMethodDescriptor(Class[] parameterTypes,
                                              Class returnType)
    {
        return getParameterDescriptors(parameterTypes) +
            ((returnType == void.class) ? &quot;V&quot; : getFieldType(returnType));
    }

    /**
     * Return the list of &quot;parameter descriptor&quot; strings enclosed in
     * parentheses corresponding to the given parameter types (in other
     * words, a method descriptor without a return descriptor).  This
     * string is useful for constructing string keys for methods without
     * regard to their return type.
     */
    private static String getParameterDescriptors(Class[] parameterTypes) {
        StringBuilder desc = new StringBuilder(&quot;(&quot;);
        for (int i = 0; i &lt; parameterTypes.length; i++) {
            desc.append(getFieldType(parameterTypes[i]));
        }
        desc.append(')');
        return desc.toString();
    }

    /**
     * Return the &quot;field type&quot; string for the given type, appropriate for
     * a field descriptor, a parameter descriptor, or a return descriptor
     * other than &quot;void&quot;.  See JVMS section 4.3.2.
     */
    private static String getFieldType(Class type) {
        if (type.isPrimitive()) {
            return PrimitiveTypeInfo.get(type).baseTypeString;
        } else if (type.isArray()) {
            /*
             * According to JLS 20.3.2, the getName() method on Class does
             * return the VM type descriptor format for array classes (only);
             * using that should be quicker than the otherwise obvious code:
             *
             *     return &quot;[&quot; + getTypeDescriptor(type.getComponentType());
             */
            return type.getName().replace('.', '/');
        } else {
            return &quot;L&quot; + dotToSlash(type.getName()) + &quot;;&quot;;
        }
    }

    /**
     * Returns a human-readable string representing the signature of a
     * method with the given name and parameter types.
     */
    private static String getFriendlyMethodSignature(String name,
                                                     Class[] parameterTypes)
    {
        StringBuilder sig = new StringBuilder(name);
        sig.append('(');
        for (int i = 0; i &lt; parameterTypes.length; i++) {
            if (i &gt; 0) {
                sig.append(',');
            }
            Class parameterType = parameterTypes[i];
            int dimensions = 0;
            while (parameterType.isArray()) {
                parameterType = parameterType.getComponentType();
                dimensions++;
            }
            sig.append(parameterType.getName());
            while (dimensions-- &gt; 0) {
                sig.append(&quot;[]&quot;);
            }
        }
        sig.append(')');
        return sig.toString();
    }

    /**
     * Return the number of abstract &quot;words&quot;, or consecutive local variable
     * indexes, required to contain a value of the given type.  See JVMS
     * section 3.6.1.
     *
     * Note that the original version of the JVMS contained a definition of
     * this abstract notion of a &quot;word&quot; in section 3.4, but that definition
     * was removed for the second edition.
     */
    private static int getWordsPerType(Class type) {
        if (type == long.class || type == double.class) {
            return 2;
        } else {
            return 1;
        }
    }

    /**
     * Add to the given list all of the types in the &quot;from&quot; array that
     * are not already contained in the list and are assignable to at
     * least one of the types in the &quot;with&quot; array.
     *
     * This method is useful for computing the greatest common set of
     * declared exceptions from duplicate methods inherited from
     * different interfaces.
     */
    private static void collectCompatibleTypes(Class&lt;?&gt;[] from,
                                               Class&lt;?&gt;[] with,
                                               List&lt;Class&lt;?&gt;&gt; list)
    {
        for (int i = 0; i &lt; from.length; i++) {
            if (!list.contains(from[i])) {
                for (int j = 0; j &lt; with.length; j++) {
                    if (with[j].isAssignableFrom(from[i])) {
                        list.add(from[i]);
                        break;
                    }
                }
            }
        }
    }

    /**
     * Given the exceptions declared in the throws clause of a proxy method,
     * compute the exceptions that need to be caught from the invocation
     * handler's invoke method and rethrown intact in the method's
     * implementation before catching other Throwables and wrapping them
     * in UndeclaredThrowableExceptions.
     *
     * The exceptions to be caught are returned in a List object.  Each
     * exception in the returned list is guaranteed to not be a subclass of
     * any of the other exceptions in the list, so the catch blocks for
     * these exceptions may be generated in any order relative to each other.
     *
     * Error and RuntimeException are each always contained by the returned
     * list (if none of their superclasses are contained), since those
     * unchecked exceptions should always be rethrown intact, and thus their
     * subclasses will never appear in the returned list.
     *
     * The returned List will be empty if java.lang.Throwable is in the
     * given list of declared exceptions, indicating that no exceptions
     * need to be caught.
     */
    private static List&lt;Class&lt;?&gt;&gt; computeUniqueCatchList(Class&lt;?&gt;[] exceptions) {
        List&lt;Class&lt;?&gt;&gt; uniqueList = new ArrayList&lt;Class&lt;?&gt;&gt;();
                                                // unique exceptions to catch

        uniqueList.add(Error.class);            // always catch/rethrow these
        uniqueList.add(RuntimeException.class);

    nextException:
        for (int i = 0; i &lt; exceptions.length; i++) {
            Class&lt;?&gt; ex = exceptions[i];
            if (ex.isAssignableFrom(Throwable.class)) {
                /*
                 * If Throwable is declared to be thrown by the proxy method,
                 * then no catch blocks are necessary, because the invoke
                 * can, at most, throw Throwable anyway.
                 */
                uniqueList.clear();
                break;
            } else if (!Throwable.class.isAssignableFrom(ex)) {
                /*
                 * Ignore types that cannot be thrown by the invoke method.
                 */
                continue;
            }
            /*
             * Compare this exception against the current list of
             * exceptions that need to be caught:
             */
            for (int j = 0; j &lt; uniqueList.size();) {
                Class&lt;?&gt; ex2 = uniqueList.get(j);
                if (ex2.isAssignableFrom(ex)) {
                    /*
                     * if a superclass of this exception is already on
                     * the list to catch, then ignore this one and continue;
                     */
                    continue nextException;
                } else if (ex.isAssignableFrom(ex2)) {
                    /*
                     * if a subclass of this exception is on the list
                     * to catch, then remove it;
                     */
                    uniqueList.remove(j);
                } else {
                    j++;        // else continue comparing.
                }
            }
            // This exception is unique (so far): add it to the list to catch.
            uniqueList.add(ex);
        }
        return uniqueList;
    }

    /**
     * A PrimitiveTypeInfo object contains assorted information about
     * a primitive type in its public fields.  The struct for a particular
     * primitive type can be obtained using the static &quot;get&quot; method.
     */
    private static class PrimitiveTypeInfo {

        /** &quot;base type&quot; used in various descriptors (see JVMS section 4.3.2) */
        public String baseTypeString;

        /** name of corresponding wrapper class */
        public String wrapperClassName;

        /** method descriptor for wrapper class &quot;valueOf&quot; factory method */
        public String wrapperValueOfDesc;

        /** name of wrapper class method for retrieving primitive value */
        public String unwrapMethodName;

        /** descriptor of same method */
        public String unwrapMethodDesc;

        private static Map&lt;Class,PrimitiveTypeInfo&gt; table =
            new HashMap&lt;Class,PrimitiveTypeInfo&gt;();
        static {
            add(byte.class, Byte.class);
            add(char.class, Character.class);
            add(double.class, Double.class);
            add(float.class, Float.class);
            add(int.class, Integer.class);
            add(long.class, Long.class);
            add(short.class, Short.class);
            add(boolean.class, Boolean.class);
        }

        private static void add(Class primitiveClass, Class wrapperClass) {
            table.put(primitiveClass,
                      new PrimitiveTypeInfo(primitiveClass, wrapperClass));
        }

        private PrimitiveTypeInfo(Class primitiveClass, Class wrapperClass) {
            assert primitiveClass.isPrimitive();

            baseTypeString =
                Array.newInstance(primitiveClass, 0)
                .getClass().getName().substring(1);
            wrapperClassName = dotToSlash(wrapperClass.getName());
            wrapperValueOfDesc =
                &quot;(&quot; + baseTypeString + &quot;)L&quot; + wrapperClassName + &quot;;&quot;;
            unwrapMethodName = primitiveClass.getName() + &quot;Value&quot;;
            unwrapMethodDesc = &quot;()&quot; + baseTypeString;
        }

        public static PrimitiveTypeInfo get(Class cl) {
            return table.get(cl);
        }
    }


    /**
     * A ConstantPool object represents the constant pool of a class file
     * being generated.  This representation of a constant pool is designed
     * specifically for use by ProxyGenerator; in particular, it assumes
     * that constant pool entries will not need to be resorted (for example,
     * by their type, as the Java compiler does), so that the final index
     * value can be assigned and used when an entry is first created.
     *
     * Note that new entries cannot be created after the constant pool has
     * been written to a class file.  To prevent such logic errors, a
     * ConstantPool instance can be marked &quot;read only&quot;, so that further
     * attempts to add new entries will fail with a runtime exception.
     *
     * See JVMS section 4.4 for more information about the constant pool
     * of a class file.
     */
    private static class ConstantPool {

        /**
         * list of constant pool entries, in constant pool index order.
         *
         * This list is used when writing the constant pool to a stream
         * and for assigning the next index value.  Note that element 0
         * of this list corresponds to constant pool index 1.
         */
        private List&lt;Entry&gt; pool = new ArrayList&lt;Entry&gt;(32);

        /**
         * maps constant pool data of all types to constant pool indexes.
         *
         * This map is used to look up the index of an existing entry for
         * values of all types.
         */
        private Map&lt;Object,Short&gt; map = new HashMap&lt;Object,Short&gt;(16);

        /** true if no new constant pool entries may be added */
        private boolean readOnly = false;

        /**
         * Get or assign the index for a CONSTANT_Utf8 entry.
         */
        public short getUtf8(String s) {
            if (s == null) {
                throw new NullPointerException();
            }
            return getValue(s);
        }

        /**
         * Get or assign the index for a CONSTANT_Integer entry.
         */
        public short getInteger(int i) {
            return getValue(new Integer(i));
        }

        /**
         * Get or assign the index for a CONSTANT_Float entry.
         */
        public short getFloat(float f) {
            return getValue(new Float(f));
        }

        /**
         * Get or assign the index for a CONSTANT_Class entry.
         */
        public short getClass(String name) {
            short utf8Index = getUtf8(name);
            return getIndirect(new IndirectEntry(
                CONSTANT_CLASS, utf8Index));
        }

        /**
         * Get or assign the index for a CONSTANT_String entry.
         */
        public short getString(String s) {
            short utf8Index = getUtf8(s);
            return getIndirect(new IndirectEntry(
                CONSTANT_STRING, utf8Index));
        }

        /**
         * Get or assign the index for a CONSTANT_FieldRef entry.
         */
        public short getFieldRef(String className,
                                 String name, String descriptor)
        {
            short classIndex = getClass(className);
            short nameAndTypeIndex = getNameAndType(name, descriptor);
            return getIndirect(new IndirectEntry(
                CONSTANT_FIELD, classIndex, nameAndTypeIndex));
        }

        /**
         * Get or assign the index for a CONSTANT_MethodRef entry.
         */
        public short getMethodRef(String className,
                                  String name, String descriptor)
        {
            short classIndex = getClass(className);
            short nameAndTypeIndex = getNameAndType(name, descriptor);
            return getIndirect(new IndirectEntry(
                CONSTANT_METHOD, classIndex, nameAndTypeIndex));
        }

        /**
         * Get or assign the index for a CONSTANT_InterfaceMethodRef entry.
         */
        public short getInterfaceMethodRef(String className, String name,
                                           String descriptor)
        {
            short classIndex = getClass(className);
            short nameAndTypeIndex = getNameAndType(name, descriptor);
            return getIndirect(new IndirectEntry(
                CONSTANT_INTERFACEMETHOD, classIndex, nameAndTypeIndex));
        }

        /**
         * Get or assign the index for a CONSTANT_NameAndType entry.
         */
        public short getNameAndType(String name, String descriptor) {
            short nameIndex = getUtf8(name);
            short descriptorIndex = getUtf8(descriptor);
            return getIndirect(new IndirectEntry(
                CONSTANT_NAMEANDTYPE, nameIndex, descriptorIndex));
        }

        /**
         * Set this ConstantPool instance to be &quot;read only&quot;.
         *
         * After this method has been called, further requests to get
         * an index for a non-existent entry will cause an InternalError
         * to be thrown instead of creating of the entry.
         */
        public void setReadOnly() {
            readOnly = true;
        }

        /**
         * Write this constant pool to a stream as part of
         * the class file format.
         *
         * This consists of writing the &quot;constant_pool_count&quot; and
         * &quot;constant_pool[]&quot; items of the &quot;ClassFile&quot; structure, as
         * described in JVMS section 4.1.
         */
        public void write(OutputStream out) throws IOException {
            DataOutputStream dataOut = new DataOutputStream(out);

            // constant_pool_count: number of entries plus one
            dataOut.writeShort(pool.size() + 1);

            for (Entry e : pool) {
                e.write(dataOut);
            }
        }

        /**
         * Add a new constant pool entry and return its index.
         */
        private short addEntry(Entry entry) {
            pool.add(entry);
            /*
             * Note that this way of determining the index of the
             * added entry is wrong if this pool supports
             * CONSTANT_Long or CONSTANT_Double entries.
             */
            if (pool.size() &gt;= 65535) {
                throw new IllegalArgumentException(
                    &quot;constant pool size limit exceeded&quot;);
            }
            return (short) pool.size();
        }

        /**
         * Get or assign the index for an entry of a type that contains
         * a direct value.  The type of the given object determines the
         * type of the desired entry as follows:
         *
         *      java.lang.String        CONSTANT_Utf8
         *      java.lang.Integer       CONSTANT_Integer
         *      java.lang.Float         CONSTANT_Float
         *      java.lang.Long          CONSTANT_Long
         *      java.lang.Double        CONSTANT_DOUBLE
         */
        private short getValue(Object key) {
            Short index = map.get(key);
            if (index != null) {
                return index.shortValue();
            } else {
                if (readOnly) {
                    throw new InternalError(
                        &quot;late constant pool addition: &quot; + key);
                }
                short i = addEntry(new ValueEntry(key));
                map.put(key, new Short(i));
                return i;
            }
        }

        /**
         * Get or assign the index for an entry of a type that contains
         * references to other constant pool entries.
         */
        private short getIndirect(IndirectEntry e) {
            Short index = map.get(e);
            if (index != null) {
                return index.shortValue();
            } else {
                if (readOnly) {
                    throw new InternalError(&quot;late constant pool addition&quot;);
                }
                short i = addEntry(e);
                map.put(e, new Short(i));
                return i;
            }
        }

        /**
         * Entry is the abstact superclass of all constant pool entry types
         * that can be stored in the &quot;pool&quot; list; its purpose is to define a
         * common method for writing constant pool entries to a class file.
         */
        private static abstract class Entry {
            public abstract void write(DataOutputStream out)
                throws IOException;
        }

        /**
         * ValueEntry represents a constant pool entry of a type that
         * contains a direct value (see the comments for the &quot;getValue&quot;
         * method for a list of such types).
         *
         * ValueEntry objects are not used as keys for their entries in the
         * Map &quot;map&quot;, so no useful hashCode or equals methods are defined.
         */
        private static class ValueEntry extends Entry {
            private Object value;

            public ValueEntry(Object value) {
                this.value = value;
            }

            public void write(DataOutputStream out) throws IOException {
                if (value instanceof String) {
                    out.writeByte(CONSTANT_UTF8);
                    out.writeUTF((String) value);
                } else if (value instanceof Integer) {
                    out.writeByte(CONSTANT_INTEGER);
                    out.writeInt(((Integer) value).intValue());
                } else if (value instanceof Float) {
                    out.writeByte(CONSTANT_FLOAT);
                    out.writeFloat(((Float) value).floatValue());
                } else if (value instanceof Long) {
                    out.writeByte(CONSTANT_LONG);
                    out.writeLong(((Long) value).longValue());
                } else if (value instanceof Double) {
                    out.writeDouble(CONSTANT_DOUBLE);
                    out.writeDouble(((Double) value).doubleValue());
                } else {
                    throw new InternalError(&quot;bogus value entry: &quot; + value);
                }
            }
        }

        /**
         * IndirectEntry represents a constant pool entry of a type that
         * references other constant pool entries, i.e., the following types:
         *
         *      CONSTANT_Class, CONSTANT_String, CONSTANT_Fieldref,
         *      CONSTANT_Methodref, CONSTANT_InterfaceMethodref, and
         *      CONSTANT_NameAndType.
         *
         * Each of these entry types contains either one or two indexes of
         * other constant pool entries.
         *
         * IndirectEntry objects are used as the keys for their entries in
         * the Map &quot;map&quot;, so the hashCode and equals methods are overridden
         * to allow matching.
         */
        private static class IndirectEntry extends Entry {
            private int tag;
            private short index0;
            private short index1;

            /**
             * Construct an IndirectEntry for a constant pool entry type
             * that contains one index of another entry.
             */
            public IndirectEntry(int tag, short index) {
                this.tag = tag;
                this.index0 = index;
                this.index1 = 0;
            }

            /**
             * Construct an IndirectEntry for a constant pool entry type
             * that contains two indexes for other entries.
             */
            public IndirectEntry(int tag, short index0, short index1) {
                this.tag = tag;
                this.index0 = index0;
                this.index1 = index1;
            }

            public void write(DataOutputStream out) throws IOException {
                out.writeByte(tag);
                out.writeShort(index0);
                /*
                 * If this entry type contains two indexes, write
                 * out the second, too.
                 */
                if (tag == CONSTANT_FIELD ||
                    tag == CONSTANT_METHOD ||
                    tag == CONSTANT_INTERFACEMETHOD ||
                    tag == CONSTANT_NAMEANDTYPE)
                {
                    out.writeShort(index1);
                }
            }

            public int hashCode() {
                return tag + index0 + index1;
            }

            public boolean equals(Object obj) {
                if (obj instanceof IndirectEntry) {
                    IndirectEntry other = (IndirectEntry) obj;
                    if (tag == other.tag &amp;&amp;
                        index0 == other.index0 &amp;&amp; index1 == other.index1)
                    {
                        return true;
                    }
                }
                return false;
            }
        }
    }
}
</code></pre>

<p>To have an intuitive understanding of the generated class file, we turn on the option of <strong>saveGeneratedFiles</strong>.</p>

<pre><code class="language-java">// Target.java
package dynamicproxy;

public interface Target {

    void foo();
}
</code></pre>

<pre><code class="language-java">// TargetProxyInvocationHandler.java
package dynamicproxy;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;

public class TargetProxyInvocationHandler implements InvocationHandler {
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        if(&quot;foo&quot;.equals(method.getName())) {
            System.out.println(&quot;foo invoked&quot;);
        }
        return null;
    }
}
</code></pre>

<pre><code class="language-java">// Main.java
package dynamicproxy;

import java.lang.reflect.Proxy;

public class Main {
    public static void main(String[] args) {
        System.getProperties().put(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;,&quot;true&quot;);
        Target b = (Target) Proxy.newProxyInstance(Target.class.getClassLoader(), new Class[] {Target.class}, new TargetProxyInvocationHandler());
        System.out.println(b.getClass().toString());
        b.foo();
    }
}
</code></pre>

<p>And now we can find the generated Proxy class file:</p>

<pre><code class="language-java">// Proxy.class
package com.sun.proxy;

import dynamicproxy.Target;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.lang.reflect.UndeclaredThrowableException;

public final class $Proxy0 extends Proxy implements Target {
	 private static Method m0;
    private static Method m1;
    private static Method m2;
    private static Method m3;
    
    static {
        try {
            m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;, new Class[0]);
            m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, new Class[]{Class.forName(&quot;java.lang.Object&quot;)});
            m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;, new Class[0]);
            m3 = Class.forName(&quot;dynamicproxy.Target&quot;).getMethod(&quot;foo&quot;, new Class[0]);
        } catch (NoSuchMethodException var2) {
            throw new NoSuchMethodError(var2.getMessage());
        } catch (ClassNotFoundException var3) {
            throw new NoClassDefFoundError(var3.getMessage());
        }
    }

    public $Proxy0(InvocationHandler var1) throws  {
        super(var1);
    }
    
    public final int hashCode() throws  {
        try {
            return ((Integer)super.h.invoke(this, m0, (Object[])null)).intValue();
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    public final boolean equals(Object var1) throws  {
        try {
            return ((Boolean)super.h.invoke(this, m1, new Object[]{var1})).booleanValue();
        } catch (RuntimeException | Error var3) {
            throw var3;
        } catch (Throwable var4) {
            throw new UndeclaredThrowableException(var4);
        }
    }

    public final String toString() throws  {
        try {
            return (String)super.h.invoke(this, m2, (Object[])null);
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    public final void foo() throws  {
        try {
            super.h.invoke(this, m3, (Object[])null);
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }
}
</code></pre>

<h1 id="implement-dynamic-proxy-supporting-class">Implement Dynamic Proxy supporting Class</h1>

<p>A restriction of the Proxy provided by JDK is that we can only get a proxy for an interface rather than a class.</p>

<p>But can we implement this feature on our own?</p>

<p>Obviously, we need to modify ProxyGenerator to control the generation of the final class as our expectation.</p>

<pre><code class="language-java">package dynamicproxy.supportclass;

import java.io.ByteArrayOutputStream;
import java.io.DataOutputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.lang.reflect.Array;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import sun.security.action.GetBooleanAction;

/**
 * ProxyGeneratorEx contains the code to generate a dynamic proxy class
 * for any class.
 */
public class ProxyGeneratorEx {
    /*
     * In the comments below, &quot;JVMS&quot; refers to The Java Virtual Machine
     * Specification Second Edition and &quot;JLS&quot; refers to the original
     * version of The Java Language Specification, unless otherwise
     * specified.
     */

    /* generate 1.5-era class file version */
    private static final int CLASSFILE_MAJOR_VERSION = 49;
    private static final int CLASSFILE_MINOR_VERSION = 0;

    /*
     * beginning of constants copied from
     * sun.tools.java.RuntimeConstants (which no longer exists):
     */

    /* constant pool tags */
    private static final int CONSTANT_UTF8              = 1;
    private static final int CONSTANT_UNICODE           = 2;
    private static final int CONSTANT_INTEGER           = 3;
    private static final int CONSTANT_FLOAT             = 4;
    private static final int CONSTANT_LONG              = 5;
    private static final int CONSTANT_DOUBLE            = 6;
    private static final int CONSTANT_CLASS             = 7;
    private static final int CONSTANT_STRING            = 8;
    private static final int CONSTANT_FIELD             = 9;
    private static final int CONSTANT_METHOD            = 10;
    private static final int CONSTANT_INTERFACEMETHOD   = 11;
    private static final int CONSTANT_NAMEANDTYPE       = 12;

    /* access and modifier flags */
    private static final int ACC_PUBLIC                 = 0x00000001;
    private static final int ACC_PRIVATE                = 0x00000002;
    //  private static final int ACC_PROTECTED              = 0x00000004;
    private static final int ACC_STATIC                 = 0x00000008;
    private static final int ACC_FINAL                  = 0x00000010;
    //  private static final int ACC_SYNCHRONIZED           = 0x00000020;
//  private static final int ACC_VOLATILE               = 0x00000040;
//  private static final int ACC_TRANSIENT              = 0x00000080;
//  private static final int ACC_NATIVE                 = 0x00000100;
//  private static final int ACC_INTERFACE              = 0x00000200;
//  private static final int ACC_ABSTRACT               = 0x00000400;
    private static final int ACC_SUPER                  = 0x00000020;
//  private static final int ACC_STRICT                 = 0x00000800;

    /* opcodes */
//  private static final int opc_nop                    = 0;
    private static final int opc_aconst_null            = 1;
    //  private static final int opc_iconst_m1              = 2;
    private static final int opc_iconst_0               = 3;
    //  private static final int opc_iconst_1               = 4;
//  private static final int opc_iconst_2               = 5;
//  private static final int opc_iconst_3               = 6;
//  private static final int opc_iconst_4               = 7;
//  private static final int opc_iconst_5               = 8;
//  private static final int opc_lconst_0               = 9;
//  private static final int opc_lconst_1               = 10;
//  private static final int opc_fconst_0               = 11;
//  private static final int opc_fconst_1               = 12;
//  private static final int opc_fconst_2               = 13;
//  private static final int opc_dconst_0               = 14;
//  private static final int opc_dconst_1               = 15;
    private static final int opc_bipush                 = 16;
    private static final int opc_sipush                 = 17;
    private static final int opc_ldc                    = 18;
    private static final int opc_ldc_w                  = 19;
    //  private static final int opc_ldc2_w                 = 20;
    private static final int opc_iload                  = 21;
    private static final int opc_lload                  = 22;
    private static final int opc_fload                  = 23;
    private static final int opc_dload                  = 24;
    private static final int opc_aload                  = 25;
    private static final int opc_iload_0                = 26;
    //  private static final int opc_iload_1                = 27;
//  private static final int opc_iload_2                = 28;
//  private static final int opc_iload_3                = 29;
    private static final int opc_lload_0                = 30;
    //  private static final int opc_lload_1                = 31;
//  private static final int opc_lload_2                = 32;
//  private static final int opc_lload_3                = 33;
    private static final int opc_fload_0                = 34;
    //  private static final int opc_fload_1                = 35;
//  private static final int opc_fload_2                = 36;
//  private static final int opc_fload_3                = 37;
    private static final int opc_dload_0                = 38;
    //  private static final int opc_dload_1                = 39;
//  private static final int opc_dload_2                = 40;
//  private static final int opc_dload_3                = 41;
    private static final int opc_aload_0                = 42;
    //  private static final int opc_aload_1                = 43;
//  private static final int opc_aload_2                = 44;
//  private static final int opc_aload_3                = 45;
//  private static final int opc_iaload                 = 46;
//  private static final int opc_laload                 = 47;
//  private static final int opc_faload                 = 48;
//  private static final int opc_daload                 = 49;
//  private static final int opc_aaload                 = 50;
//  private static final int opc_baload                 = 51;
//  private static final int opc_caload                 = 52;
//  private static final int opc_saload                 = 53;
//  private static final int opc_istore                 = 54;
//  private static final int opc_lstore                 = 55;
//  private static final int opc_fstore                 = 56;
//  private static final int opc_dstore                 = 57;
    private static final int opc_astore                 = 58;
    //  private static final int opc_istore_0               = 59;
//  private static final int opc_istore_1               = 60;
//  private static final int opc_istore_2               = 61;
//  private static final int opc_istore_3               = 62;
//  private static final int opc_lstore_0               = 63;
//  private static final int opc_lstore_1               = 64;
//  private static final int opc_lstore_2               = 65;
//  private static final int opc_lstore_3               = 66;
//  private static final int opc_fstore_0               = 67;
//  private static final int opc_fstore_1               = 68;
//  private static final int opc_fstore_2               = 69;
//  private static final int opc_fstore_3               = 70;
//  private static final int opc_dstore_0               = 71;
//  private static final int opc_dstore_1               = 72;
//  private static final int opc_dstore_2               = 73;
//  private static final int opc_dstore_3               = 74;
    private static final int opc_astore_0               = 75;
    //  private static final int opc_astore_1               = 76;
//  private static final int opc_astore_2               = 77;
//  private static final int opc_astore_3               = 78;
//  private static final int opc_iastore                = 79;
//  private static final int opc_lastore                = 80;
//  private static final int opc_fastore                = 81;
//  private static final int opc_dastore                = 82;
    private static final int opc_aastore                = 83;
    //  private static final int opc_bastore                = 84;
//  private static final int opc_castore                = 85;
//  private static final int opc_sastore                = 86;
    private static final int opc_pop                    = 87;
    //  private static final int opc_pop2                   = 88;
    private static final int opc_dup                    = 89;
    //  private static final int opc_dup_x1                 = 90;
//  private static final int opc_dup_x2                 = 91;
//  private static final int opc_dup2                   = 92;
//  private static final int opc_dup2_x1                = 93;
//  private static final int opc_dup2_x2                = 94;
//  private static final int opc_swap                   = 95;
//  private static final int opc_iadd                   = 96;
//  private static final int opc_ladd                   = 97;
//  private static final int opc_fadd                   = 98;
//  private static final int opc_dadd                   = 99;
//  private static final int opc_isub                   = 100;
//  private static final int opc_lsub                   = 101;
//  private static final int opc_fsub                   = 102;
//  private static final int opc_dsub                   = 103;
//  private static final int opc_imul                   = 104;
//  private static final int opc_lmul                   = 105;
//  private static final int opc_fmul                   = 106;
//  private static final int opc_dmul                   = 107;
//  private static final int opc_idiv                   = 108;
//  private static final int opc_ldiv                   = 109;
//  private static final int opc_fdiv                   = 110;
//  private static final int opc_ddiv                   = 111;
//  private static final int opc_irem                   = 112;
//  private static final int opc_lrem                   = 113;
//  private static final int opc_frem                   = 114;
//  private static final int opc_drem                   = 115;
//  private static final int opc_ineg                   = 116;
//  private static final int opc_lneg                   = 117;
//  private static final int opc_fneg                   = 118;
//  private static final int opc_dneg                   = 119;
//  private static final int opc_ishl                   = 120;
//  private static final int opc_lshl                   = 121;
//  private static final int opc_ishr                   = 122;
//  private static final int opc_lshr                   = 123;
//  private static final int opc_iushr                  = 124;
//  private static final int opc_lushr                  = 125;
//  private static final int opc_iand                   = 126;
//  private static final int opc_land                   = 127;
//  private static final int opc_ior                    = 128;
//  private static final int opc_lor                    = 129;
//  private static final int opc_ixor                   = 130;
//  private static final int opc_lxor                   = 131;
//  private static final int opc_iinc                   = 132;
//  private static final int opc_i2l                    = 133;
//  private static final int opc_i2f                    = 134;
//  private static final int opc_i2d                    = 135;
//  private static final int opc_l2i                    = 136;
//  private static final int opc_l2f                    = 137;
//  private static final int opc_l2d                    = 138;
//  private static final int opc_f2i                    = 139;
//  private static final int opc_f2l                    = 140;
//  private static final int opc_f2d                    = 141;
//  private static final int opc_d2i                    = 142;
//  private static final int opc_d2l                    = 143;
//  private static final int opc_d2f                    = 144;
//  private static final int opc_i2b                    = 145;
//  private static final int opc_i2c                    = 146;
//  private static final int opc_i2s                    = 147;
//  private static final int opc_lcmp                   = 148;
//  private static final int opc_fcmpl                  = 149;
//  private static final int opc_fcmpg                  = 150;
//  private static final int opc_dcmpl                  = 151;
//  private static final int opc_dcmpg                  = 152;
//  private static final int opc_ifeq                   = 153;
//  private static final int opc_ifne                   = 154;
//  private static final int opc_iflt                   = 155;
//  private static final int opc_ifge                   = 156;
//  private static final int opc_ifgt                   = 157;
//  private static final int opc_ifle                   = 158;
//  private static final int opc_if_icmpeq              = 159;
//  private static final int opc_if_icmpne              = 160;
//  private static final int opc_if_icmplt              = 161;
//  private static final int opc_if_icmpge              = 162;
//  private static final int opc_if_icmpgt              = 163;
//  private static final int opc_if_icmple              = 164;
//  private static final int opc_if_acmpeq              = 165;
//  private static final int opc_if_acmpne              = 166;
//  private static final int opc_goto                   = 167;
//  private static final int opc_jsr                    = 168;
//  private static final int opc_ret                    = 169;
//  private static final int opc_tableswitch            = 170;
//  private static final int opc_lookupswitch           = 171;
    private static final int opc_ireturn                = 172;
    private static final int opc_lreturn                = 173;
    private static final int opc_freturn                = 174;
    private static final int opc_dreturn                = 175;
    private static final int opc_areturn                = 176;
    private static final int opc_return                 = 177;
    private static final int opc_getstatic              = 178;
    private static final int opc_putstatic              = 179;
    private static final int opc_getfield               = 180;
    private static final int opc_putfield               = 181;
    private static final int opc_invokevirtual          = 182;
    private static final int opc_invokespecial          = 183;
    private static final int opc_invokestatic           = 184;
    private static final int opc_invokeinterface        = 185;
    private static final int opc_new                    = 187;
    //  private static final int opc_newarray               = 188;
    private static final int opc_anewarray              = 189;
    //  private static final int opc_arraylength            = 190;
    private static final int opc_athrow                 = 191;
    private static final int opc_checkcast              = 192;
    //  private static final int opc_instanceof             = 193;
//  private static final int opc_monitorenter           = 194;
//  private static final int opc_monitorexit            = 195;
    private static final int opc_wide                   = 196;
//  private static final int opc_multianewarray         = 197;
//  private static final int opc_ifnull                 = 198;
//  private static final int opc_ifnonnull              = 199;
//  private static final int opc_goto_w                 = 200;
//  private static final int opc_jsr_w                  = 201;

    // end of constants copied from sun.tools.java.RuntimeConstants

    /** name of the superclass of proxy classes */
    private String superclassName;

    /** name of field for storing a proxy instance's invocation handler */
    private final static String handlerFieldName = &quot;h&quot;;

    /** debugging flag for saving generated class files */
    private final static boolean saveGeneratedFiles =
            java.security.AccessController.doPrivileged(
                    new GetBooleanAction(
                            &quot;sun.misc.ProxyGeneratorEx.saveGeneratedFiles&quot;)).booleanValue();

    /**
     * Generate a proxy class given a name and a list of proxy interfaces.
     */
    public static byte[] generateProxyClass(final String name, Class superclass,
                                            Class[] interfaces)
    {
        ProxyGeneratorEx gen = new ProxyGeneratorEx(name, superclass, interfaces);
        final byte[] classFile = gen.generateClassFile();

        if (saveGeneratedFiles) {
            java.security.AccessController.doPrivileged(
                    new java.security.PrivilegedAction&lt;Void&gt;() {
                        public Void run() {
                            try {
                                FileOutputStream file =
                                        new FileOutputStream(dotToSlash(name) + &quot;.class&quot;);
                                file.write(classFile);
                                file.close();
                                return null;
                            } catch (IOException e) {
                                throw new InternalError(
                                        &quot;I/O exception saving generated file: &quot; + e);
                            }
                        }
                    });
        }

        return classFile;
    }

    /* preloaded Method objects for methods in java.lang.Object */
    private static Method hashCodeMethod;
    private static Method equalsMethod;
    private static Method toStringMethod;
    static {
        try {
            hashCodeMethod = Object.class.getMethod(&quot;hashCode&quot;);
            equalsMethod =
                    Object.class.getMethod(&quot;equals&quot;, new Class[] { Object.class });
            toStringMethod = Object.class.getMethod(&quot;toString&quot;);
        } catch (NoSuchMethodException e) {
            throw new NoSuchMethodError(e.getMessage());
        }
    }

    /** name of proxy class */
    private String className;

    /** proxy interfaces */
    private Class[] interfaces;

    /** constant pool of class being generated */
    private ConstantPool cp = new ConstantPool();

    /** FieldInfo struct for each field of generated class */
    private List&lt;FieldInfo&gt; fields = new ArrayList&lt;FieldInfo&gt;();

    /** MethodInfo struct for each method of generated class */
    private List&lt;MethodInfo&gt; methods = new ArrayList&lt;MethodInfo&gt;();

    /**
     * maps method signature string to list of ProxyMethod objects for
     * proxy methods with that signature
     */
    private Map&lt;String, List&lt;ProxyMethod&gt;&gt; proxyMethods =
            new HashMap&lt;String,List&lt;ProxyMethod&gt;&gt;();

    /** count of ProxyMethod objects added to proxyMethods */
    private int proxyMethodCount = 0;

    private Class superclass;

    /**
     * Construct a ProxyGeneratorEx to generate a proxy class with the
     * specified name and for the given interfaces.
     *
     * A ProxyGeneratorEx object contains the state for the ongoing
     * generation of a particular proxy class.
     */
    private ProxyGeneratorEx(String className, Class supperclass, Class[] interfaces) {
        this.className = className;
        this.superclassName = dotToSlash(supperclass.getName());
        this.superclass = supperclass;
        this.interfaces = interfaces;
    }

    /**
     * Generate a class file for the proxy class.  This method drives the
     * class file generation process.
     */
    private byte[] generateClassFile() {

        /* ============================================================
         * Step 1: Assemble ProxyMethod objects for all methods to
         * generate proxy dispatching code for.
         */

        /*
         * Record that proxy methods are needed for the hashCode, equals,
         * and toString methods of java.lang.Object.  This is done before
         * the methods from the proxy interfaces so that the methods from
         * java.lang.Object take precedence over duplicate methods in the
         * proxy interfaces.
         */
        addProxyMethod(hashCodeMethod, Object.class);
        addProxyMethod(equalsMethod, Object.class);
        addProxyMethod(toStringMethod, Object.class);

        /*
         * Now record all of the methods from the proxy interfaces, giving
         * earlier interfaces precedence over later ones with duplicate
         * methods.
         */
        for (int i = 0; i &lt; interfaces.length; i++) {
            Method[] methods = interfaces[i].getMethods();
            for (int j = 0; j &lt; methods.length; j++) {
                addProxyMethod(methods[j], interfaces[i]);
            }
        }

        // Now record all of the methods from the proxy superclass
        Method[] superclassMethods = superclass.getDeclaredMethods();
        for (int j = 0; j &lt; superclassMethods.length; j++) {
            addProxyMethod(superclassMethods[j], superclass);
        }

        /*
         * For each set of proxy methods with the same signature,
         * verify that the methods' return types are compatible.
         */
        for (List&lt;ProxyMethod&gt; sigmethods : proxyMethods.values()) {
            checkReturnTypes(sigmethods);
        }

        /* ============================================================
         * Step 2: Assemble FieldInfo and MethodInfo structs for all of
         * fields and methods in the class we are generating.
         */
        try {
            methods.add(generateConstructor());

            for (List&lt;ProxyMethod&gt; sigmethods : proxyMethods.values()) {
                for (ProxyMethod pm : sigmethods) {

                    // add static field for method's Method object
                    fields.add(new FieldInfo(pm.methodFieldName,
                            &quot;Ljava/lang/reflect/Method;&quot;,
                            ACC_PRIVATE | ACC_STATIC));

                    // generate code for proxy method and add it
                    methods.add(pm.generateMethod());
                }
            }
            // add field: InvocationHandler
            fields.add(new FieldInfo(handlerFieldName,
                    &quot;Ljava/lang/reflect/InvocationHandler;&quot;,
                    ACC_PRIVATE));

            methods.add(generateStaticInitializer());

        } catch (IOException e) {
            throw new InternalError(&quot;unexpected I/O Exception&quot;);
        }

        if (methods.size() &gt; 65535) {
            throw new IllegalArgumentException(&quot;method limit exceeded&quot;);
        }
        if (fields.size() &gt; 65535) {
            throw new IllegalArgumentException(&quot;field limit exceeded&quot;);
        }

        /* ============================================================
         * Step 3: Write the final class file.
         */

        /*
         * Make sure that constant pool indexes are reserved for the
         * following items before starting to write the final class file.
         */
        cp.getClass(dotToSlash(className));
        cp.getClass(superclassName);
        for (int i = 0; i &lt; interfaces.length; i++) {
            cp.getClass(dotToSlash(interfaces[i].getName()));
        }

        /*
         * Disallow new constant pool additions beyond this point, since
         * we are about to write the final constant pool table.
         */
        cp.setReadOnly();

        ByteArrayOutputStream bout = new ByteArrayOutputStream();
        DataOutputStream dout = new DataOutputStream(bout);

        try {
            /*
             * Write all the items of the &quot;ClassFile&quot; structure.
             * See JVMS section 4.1.
             */
            // u4 magic;
            dout.writeInt(0xCAFEBABE);
            // u2 minor_version;
            dout.writeShort(CLASSFILE_MINOR_VERSION);
            // u2 major_version;
            dout.writeShort(CLASSFILE_MAJOR_VERSION);

            cp.write(dout);             // (write constant pool)

            // u2 access_flags;
            dout.writeShort(ACC_PUBLIC | ACC_FINAL | ACC_SUPER);
            // u2 this_class;
            dout.writeShort(cp.getClass(dotToSlash(className)));
            // u2 super_class;
            dout.writeShort(cp.getClass(superclassName));

            // u2 interfaces_count;
            dout.writeShort(interfaces.length);
            // u2 interfaces[interfaces_count];
            for (int i = 0; i &lt; interfaces.length; i++) {
                dout.writeShort(cp.getClass(
                        dotToSlash(interfaces[i].getName())));
            }

            // u2 fields_count;
            dout.writeShort(fields.size());
            // field_info fields[fields_count];
            for (FieldInfo f : fields) {
                f.write(dout);
            }

            // u2 methods_count;
            dout.writeShort(methods.size());
            // method_info methods[methods_count];
            for (MethodInfo m : methods) {
                m.write(dout);
            }

            // u2 attributes_count;
            dout.writeShort(0); // (no ClassFile attributes for proxy classes)

        } catch (IOException e) {
            throw new InternalError(&quot;unexpected I/O Exception&quot;);
        }

        return bout.toByteArray();
    }

    /**
     * Add another method to be proxied, either by creating a new
     * ProxyMethod object or augmenting an old one for a duplicate
     * method.
     *
     * &quot;fromClass&quot; indicates the proxy interface that the method was
     * found through, which may be different from (a subinterface of)
     * the method's &quot;declaring class&quot;.  Note that the first Method
     * object passed for a given name and descriptor identifies the
     * Method object (and thus the declaring class) that will be
     * passed to the invocation handler's &quot;invoke&quot; method for a given
     * set of duplicate methods.
     */
    private void addProxyMethod(Method m, Class fromClass) {
        String name = m.getName();
        Class[] parameterTypes = m.getParameterTypes();
        Class returnType = m.getReturnType();
        Class[] exceptionTypes = m.getExceptionTypes();

        String sig = name + getParameterDescriptors(parameterTypes);
        List&lt;ProxyMethod&gt; sigmethods = proxyMethods.get(sig);
        if (sigmethods != null) {
            for (ProxyMethod pm : sigmethods) {
                if (returnType == pm.returnType) {
                    /*
                     * Found a match: reduce exception types to the
                     * greatest set of exceptions that can thrown
                     * compatibly with the throws clauses of both
                     * overridden methods.
                     */
                    List&lt;Class&lt;?&gt;&gt; legalExceptions = new ArrayList&lt;Class&lt;?&gt;&gt;();
                    collectCompatibleTypes(
                            exceptionTypes, pm.exceptionTypes, legalExceptions);
                    collectCompatibleTypes(
                            pm.exceptionTypes, exceptionTypes, legalExceptions);
                    pm.exceptionTypes = new Class[legalExceptions.size()];
                    pm.exceptionTypes =
                            legalExceptions.toArray(pm.exceptionTypes);
                    return;
                }
            }
        } else {
            sigmethods = new ArrayList&lt;ProxyMethod&gt;(3);
            proxyMethods.put(sig, sigmethods);
        }
        sigmethods.add(new ProxyMethod(name, parameterTypes, returnType,
                exceptionTypes, fromClass));
    }

    /**
     * For a given set of proxy methods with the same signature, check
     * that their return types are compatible according to the Proxy
     * specification.
     *
     * Specifically, if there is more than one such method, then all
     * of the return types must be reference types, and there must be
     * one return type that is assignable to each of the rest of them.
     */
    private static void checkReturnTypes(List&lt;ProxyMethod&gt; methods) {
        /*
         * If there is only one method with a given signature, there
         * cannot be a conflict.  This is the only case in which a
         * primitive (or void) return type is allowed.
         */
        if (methods.size() &lt; 2) {
            return;
        }

        /*
         * List of return types that are not yet known to be
         * assignable from (&quot;covered&quot; by) any of the others.
         */
        LinkedList&lt;Class&lt;?&gt;&gt; uncoveredReturnTypes = new LinkedList&lt;Class&lt;?&gt;&gt;();

        nextNewReturnType:
        for (ProxyMethod pm : methods) {
            Class&lt;?&gt; newReturnType = pm.returnType;
            if (newReturnType.isPrimitive()) {
                throw new IllegalArgumentException(
                        &quot;methods with same signature &quot; +
                                getFriendlyMethodSignature(pm.methodName,
                                        pm.parameterTypes) +
                                &quot; but incompatible return types: &quot; +
                                newReturnType.getName() + &quot; and others&quot;);
            }
            boolean added = false;

            /*
             * Compare the new return type to the existing uncovered
             * return types.
             */
            ListIterator&lt;Class&lt;?&gt;&gt; liter = uncoveredReturnTypes.listIterator();
            while (liter.hasNext()) {
                Class&lt;?&gt; uncoveredReturnType = liter.next();

                /*
                 * If an existing uncovered return type is assignable
                 * to this new one, then we can forget the new one.
                 */
                if (newReturnType.isAssignableFrom(uncoveredReturnType)) {
                    assert !added;
                    continue nextNewReturnType;
                }

                /*
                 * If the new return type is assignable to an existing
                 * uncovered one, then should replace the existing one
                 * with the new one (or just forget the existing one,
                 * if the new one has already be put in the list).
                 */
                if (uncoveredReturnType.isAssignableFrom(newReturnType)) {
                    // (we can assume that each return type is unique)
                    if (!added) {
                        liter.set(newReturnType);
                        added = true;
                    } else {
                        liter.remove();
                    }
                }
            }

            /*
             * If we got through the list of existing uncovered return
             * types without an assignability relationship, then add
             * the new return type to the list of uncovered ones.
             */
            if (!added) {
                uncoveredReturnTypes.add(newReturnType);
            }
        }

        /*
         * We shouldn't end up with more than one return type that is
         * not assignable from any of the others.
         */
        if (uncoveredReturnTypes.size() &gt; 1) {
            ProxyMethod pm = methods.get(0);
            throw new IllegalArgumentException(
                    &quot;methods with same signature &quot; +
                            getFriendlyMethodSignature(pm.methodName, pm.parameterTypes) +
                            &quot; but incompatible return types: &quot; + uncoveredReturnTypes);
        }
    }

    /**
     * A FieldInfo object contains information about a particular field
     * in the class being generated.  The class mirrors the data items of
     * the &quot;field_info&quot; structure of the class file format (see JVMS 4.5).
     */
    private class FieldInfo {
        public int accessFlags;
        public String name;
        public String descriptor;

        public FieldInfo(String name, String descriptor, int accessFlags) {
            this.name = name;
            this.descriptor = descriptor;
            this.accessFlags = accessFlags;

            /*
             * Make sure that constant pool indexes are reserved for the
             * following items before starting to write the final class file.
             */
            cp.getUtf8(name);
            cp.getUtf8(descriptor);
        }

        public void write(DataOutputStream out) throws IOException {
            /*
             * Write all the items of the &quot;field_info&quot; structure.
             * See JVMS section 4.5.
             */
            // u2 access_flags;
            out.writeShort(accessFlags);
            // u2 name_index;
            out.writeShort(cp.getUtf8(name));
            // u2 descriptor_index;
            out.writeShort(cp.getUtf8(descriptor));
            // u2 attributes_count;
            out.writeShort(0);  // (no field_info attributes for proxy classes)
        }
    }

    /**
     * An ExceptionTableEntry object holds values for the data items of
     * an entry in the &quot;exception_table&quot; item of the &quot;Code&quot; attribute of
     * &quot;method_info&quot; structures (see JVMS 4.7.3).
     */
    private static class ExceptionTableEntry {
        public short startPc;
        public short endPc;
        public short handlerPc;
        public short catchType;

        public ExceptionTableEntry(short startPc, short endPc,
                                   short handlerPc, short catchType)
        {
            this.startPc = startPc;
            this.endPc = endPc;
            this.handlerPc = handlerPc;
            this.catchType = catchType;
        }
    };

    /**
     * A MethodInfo object contains information about a particular method
     * in the class being generated.  This class mirrors the data items of
     * the &quot;method_info&quot; structure of the class file format (see JVMS 4.6).
     */
    private class MethodInfo {
        public int accessFlags;
        public String name;
        public String descriptor;
        public short maxStack;
        public short maxLocals;
        public ByteArrayOutputStream code = new ByteArrayOutputStream();
        public List&lt;ExceptionTableEntry&gt; exceptionTable =
                new ArrayList&lt;ExceptionTableEntry&gt;();
        public short[] declaredExceptions;

        public MethodInfo(String name, String descriptor, int accessFlags) {
            this.name = name;
            this.descriptor = descriptor;
            this.accessFlags = accessFlags;

            /*
             * Make sure that constant pool indexes are reserved for the
             * following items before starting to write the final class file.
             */
            cp.getUtf8(name);
            cp.getUtf8(descriptor);
            cp.getUtf8(&quot;Code&quot;);
            cp.getUtf8(&quot;Exceptions&quot;);
        }

        public void write(DataOutputStream out) throws IOException {
            /*
             * Write all the items of the &quot;method_info&quot; structure.
             * See JVMS section 4.6.
             */
            // u2 access_flags;
            out.writeShort(accessFlags);
            // u2 name_index;
            out.writeShort(cp.getUtf8(name));
            // u2 descriptor_index;
            out.writeShort(cp.getUtf8(descriptor));
            // u2 attributes_count;
            out.writeShort(2);  // (two method_info attributes:)

            // Write &quot;Code&quot; attribute. See JVMS section 4.7.3.

            // u2 attribute_name_index;
            out.writeShort(cp.getUtf8(&quot;Code&quot;));
            // u4 attribute_length;
            out.writeInt(12 + code.size() + 8 * exceptionTable.size());
            // u2 max_stack;
            out.writeShort(maxStack);
            // u2 max_locals;
            out.writeShort(maxLocals);
            // u2 code_length;
            out.writeInt(code.size());
            // u1 code[code_length];
            code.writeTo(out);
            // u2 exception_table_length;
            out.writeShort(exceptionTable.size());
            for (ExceptionTableEntry e : exceptionTable) {
                // u2 start_pc;
                out.writeShort(e.startPc);
                // u2 end_pc;
                out.writeShort(e.endPc);
                // u2 handler_pc;
                out.writeShort(e.handlerPc);
                // u2 catch_type;
                out.writeShort(e.catchType);
            }
            // u2 attributes_count;
            out.writeShort(0);

            // write &quot;Exceptions&quot; attribute.  See JVMS section 4.7.4.

            // u2 attribute_name_index;
            out.writeShort(cp.getUtf8(&quot;Exceptions&quot;));
            // u4 attributes_length;
            out.writeInt(2 + 2 * declaredExceptions.length);
            // u2 number_of_exceptions;
            out.writeShort(declaredExceptions.length);
            // u2 exception_index_table[number_of_exceptions];
            for (int i = 0; i &lt; declaredExceptions.length; i++) {
                out.writeShort(declaredExceptions[i]);
            }
        }

    }

    /**
     * A ProxyMethod object represents a proxy method in the proxy class
     * being generated: a method whose implementation will encode and
     * dispatch invocations to the proxy instance's invocation handler.
     */
    private class ProxyMethod {

        public String methodName;
        public Class[] parameterTypes;
        public Class returnType;
        public Class[] exceptionTypes;
        public Class fromClass;
        public String methodFieldName;

        private ProxyMethod(String methodName, Class[] parameterTypes,
                            Class returnType, Class[] exceptionTypes,
                            Class fromClass)
        {
            this.methodName = methodName;
            this.parameterTypes = parameterTypes;
            this.returnType = returnType;
            this.exceptionTypes = exceptionTypes;
            this.fromClass = fromClass;
            this.methodFieldName = &quot;m&quot; + proxyMethodCount++;
        }

        /**
         * Return a MethodInfo object for this method, including generating
         * the code and exception table entry.
         */
        private MethodInfo generateMethod() throws IOException {
            String desc = getMethodDescriptor(parameterTypes, returnType);
            MethodInfo minfo = new MethodInfo(methodName, desc,
                    ACC_PUBLIC | ACC_FINAL);

            int[] parameterSlot = new int[parameterTypes.length];
            int nextSlot = 1;
            for (int i = 0; i &lt; parameterSlot.length; i++) {
                parameterSlot[i] = nextSlot;
                nextSlot += getWordsPerType(parameterTypes[i]);
            }
            int localSlot0 = nextSlot;
            short pc, tryBegin = 0, tryEnd;

            DataOutputStream out = new DataOutputStream(minfo.code);

            code_aload(0, out);

            out.writeByte(opc_getfield);
            out.writeShort(cp.getFieldRef(
                    className,
                    handlerFieldName, &quot;Ljava/lang/reflect/InvocationHandler;&quot;));

            code_aload(0, out);

            out.writeByte(opc_getstatic);
            out.writeShort(cp.getFieldRef(
                    dotToSlash(className),
                    methodFieldName, &quot;Ljava/lang/reflect/Method;&quot;));

            if (parameterTypes.length &gt; 0) {

                code_ipush(parameterTypes.length, out);

                out.writeByte(opc_anewarray);
                out.writeShort(cp.getClass(&quot;java/lang/Object&quot;));

                for (int i = 0; i &lt; parameterTypes.length; i++) {

                    out.writeByte(opc_dup);

                    code_ipush(i, out);

                    codeWrapArgument(parameterTypes[i], parameterSlot[i], out);

                    out.writeByte(opc_aastore);
                }
            } else {

                out.writeByte(opc_aconst_null);
            }

            out.writeByte(opc_invokeinterface);
            out.writeShort(cp.getInterfaceMethodRef(
                    &quot;java/lang/reflect/InvocationHandler&quot;,
                    &quot;invoke&quot;,
                    &quot;(Ljava/lang/Object;Ljava/lang/reflect/Method;&quot; +
                            &quot;[Ljava/lang/Object;)Ljava/lang/Object;&quot;));
            out.writeByte(4);
            out.writeByte(0);

            if (returnType == void.class) {

                out.writeByte(opc_pop);

                out.writeByte(opc_return);

            } else {

                codeUnwrapReturnValue(returnType, out);
            }

            tryEnd = pc = (short) minfo.code.size();

            List&lt;Class&lt;?&gt;&gt; catchList = computeUniqueCatchList(exceptionTypes);
            if (catchList.size() &gt; 0) {

                for (Class&lt;?&gt; ex : catchList) {
                    minfo.exceptionTable.add(new ExceptionTableEntry(
                            tryBegin, tryEnd, pc,
                            cp.getClass(dotToSlash(ex.getName()))));
                }

                out.writeByte(opc_athrow);

                pc = (short) minfo.code.size();

                minfo.exceptionTable.add(new ExceptionTableEntry(
                        tryBegin, tryEnd, pc, cp.getClass(&quot;java/lang/Throwable&quot;)));

                code_astore(localSlot0, out);

                out.writeByte(opc_new);
                out.writeShort(cp.getClass(
                        &quot;java/lang/reflect/UndeclaredThrowableException&quot;));

                out.writeByte(opc_dup);

                code_aload(localSlot0, out);

                out.writeByte(opc_invokespecial);

                out.writeShort(cp.getMethodRef(
                        &quot;java/lang/reflect/UndeclaredThrowableException&quot;,
                        &quot;&lt;init&gt;&quot;, &quot;(Ljava/lang/Throwable;)V&quot;));

                out.writeByte(opc_athrow);
            }

            if (minfo.code.size() &gt; 65535) {
                throw new IllegalArgumentException(&quot;code size limit exceeded&quot;);
            }

            minfo.maxStack = 10;
            minfo.maxLocals = (short) (localSlot0 + 1);
            minfo.declaredExceptions = new short[exceptionTypes.length];
            for (int i = 0; i &lt; exceptionTypes.length; i++) {
                minfo.declaredExceptions[i] = cp.getClass(
                        dotToSlash(exceptionTypes[i].getName()));
            }

            return minfo;
        }

        /**
         * Generate code for wrapping an argument of the given type
         * whose value can be found at the specified local variable
         * index, in order for it to be passed (as an Object) to the
         * invocation handler's &quot;invoke&quot; method.  The code is written
         * to the supplied stream.
         */
        private void codeWrapArgument(Class type, int slot,
                                      DataOutputStream out)
                throws IOException
        {
            if (type.isPrimitive()) {
                PrimitiveTypeInfo prim = PrimitiveTypeInfo.get(type);

                if (type == int.class ||
                        type == boolean.class ||
                        type == byte.class ||
                        type == char.class ||
                        type == short.class)
                {
                    code_iload(slot, out);
                } else if (type == long.class) {
                    code_lload(slot, out);
                } else if (type == float.class) {
                    code_fload(slot, out);
                } else if (type == double.class) {
                    code_dload(slot, out);
                } else {
                    throw new AssertionError();
                }

                out.writeByte(opc_invokestatic);
                out.writeShort(cp.getMethodRef(
                        prim.wrapperClassName,
                        &quot;valueOf&quot;, prim.wrapperValueOfDesc));

            } else {

                code_aload(slot, out);
            }
        }

        /**
         * Generate code for unwrapping a return value of the given
         * type from the invocation handler's &quot;invoke&quot; method (as type
         * Object) to its correct type.  The code is written to the
         * supplied stream.
         */
        private void codeUnwrapReturnValue(Class type, DataOutputStream out)
                throws IOException
        {
            if (type.isPrimitive()) {
                PrimitiveTypeInfo prim = PrimitiveTypeInfo.get(type);

                out.writeByte(opc_checkcast);
                out.writeShort(cp.getClass(prim.wrapperClassName));

                out.writeByte(opc_invokevirtual);
                out.writeShort(cp.getMethodRef(
                        prim.wrapperClassName,
                        prim.unwrapMethodName, prim.unwrapMethodDesc));

                if (type == int.class ||
                        type == boolean.class ||
                        type == byte.class ||
                        type == char.class ||
                        type == short.class)
                {
                    out.writeByte(opc_ireturn);
                } else if (type == long.class) {
                    out.writeByte(opc_lreturn);
                } else if (type == float.class) {
                    out.writeByte(opc_freturn);
                } else if (type == double.class) {
                    out.writeByte(opc_dreturn);
                } else {
                    throw new AssertionError();
                }

            } else {

                out.writeByte(opc_checkcast);
                out.writeShort(cp.getClass(dotToSlash(type.getName())));

                out.writeByte(opc_areturn);
            }
        }

        /**
         * Generate code for initializing the static field that stores
         * the Method object for this proxy method.  The code is written
         * to the supplied stream.
         */
        private void codeFieldInitialization(DataOutputStream out)
                throws IOException
        {
            codeClassForName(fromClass, out);

            code_ldc(cp.getString(methodName), out);

            code_ipush(parameterTypes.length, out);

            out.writeByte(opc_anewarray);
            out.writeShort(cp.getClass(&quot;java/lang/Class&quot;));

            for (int i = 0; i &lt; parameterTypes.length; i++) {

                out.writeByte(opc_dup);

                code_ipush(i, out);

                if (parameterTypes[i].isPrimitive()) {
                    PrimitiveTypeInfo prim =
                            PrimitiveTypeInfo.get(parameterTypes[i]);

                    out.writeByte(opc_getstatic);
                    out.writeShort(cp.getFieldRef(
                            prim.wrapperClassName, &quot;TYPE&quot;, &quot;Ljava/lang/Class;&quot;));

                } else {
                    codeClassForName(parameterTypes[i], out);
                }

                out.writeByte(opc_aastore);
            }

            out.writeByte(opc_invokevirtual);
            out.writeShort(cp.getMethodRef(
                    &quot;java/lang/Class&quot;,
                    &quot;getMethod&quot;,
                    &quot;(Ljava/lang/String;[Ljava/lang/Class;)&quot; +
                            &quot;Ljava/lang/reflect/Method;&quot;));

            out.writeByte(opc_putstatic);
            out.writeShort(cp.getFieldRef(
                    dotToSlash(className),
                    methodFieldName, &quot;Ljava/lang/reflect/Method;&quot;));
        }
    }

    /**
     * Generate the constructor method for the proxy class.
     */
    private MethodInfo generateConstructor() throws IOException {
        MethodInfo minfo = new MethodInfo(
                &quot;&lt;init&gt;&quot;, &quot;(Ljava/lang/reflect/InvocationHandler;)V&quot;,
                ACC_PUBLIC);

        DataOutputStream out = new DataOutputStream(minfo.code);

        code_aload(0, out);

        out.writeByte(opc_invokespecial);
        out.writeShort(cp.getMethodRef(
                superclassName,
                &quot;&lt;init&gt;&quot;, &quot;()V&quot;));

        code_aload(0, out);
        code_aload(1, out);

        // write field h
        out.writeByte(opc_putfield);
        out.writeShort(cp.getFieldRef(className, handlerFieldName, &quot;Ljava/lang/reflect/InvocationHandler;&quot;));

        out.writeByte(opc_return);

        minfo.maxStack = 10;
        minfo.maxLocals = 2;
        minfo.declaredExceptions = new short[0];

        return minfo;
    }

    /**
     * Generate the static initializer method for the proxy class.
     */
    private MethodInfo generateStaticInitializer() throws IOException {
        MethodInfo minfo = new MethodInfo(
                &quot;&lt;clinit&gt;&quot;, &quot;()V&quot;, ACC_STATIC);

        int localSlot0 = 1;
        short pc, tryBegin = 0, tryEnd;

        DataOutputStream out = new DataOutputStream(minfo.code);

        for (List&lt;ProxyMethod&gt; sigmethods : proxyMethods.values()) {
            for (ProxyMethod pm : sigmethods) {
                pm.codeFieldInitialization(out);
            }
        }

        out.writeByte(opc_return);

        tryEnd = pc = (short) minfo.code.size();

        minfo.exceptionTable.add(new ExceptionTableEntry(
                tryBegin, tryEnd, pc,
                cp.getClass(&quot;java/lang/NoSuchMethodException&quot;)));

        code_astore(localSlot0, out);

        out.writeByte(opc_new);
        out.writeShort(cp.getClass(&quot;java/lang/NoSuchMethodError&quot;));

        out.writeByte(opc_dup);

        code_aload(localSlot0, out);

        out.writeByte(opc_invokevirtual);
        out.writeShort(cp.getMethodRef(
                &quot;java/lang/Throwable&quot;, &quot;getMessage&quot;, &quot;()Ljava/lang/String;&quot;));

        out.writeByte(opc_invokespecial);
        out.writeShort(cp.getMethodRef(
                &quot;java/lang/NoSuchMethodError&quot;, &quot;&lt;init&gt;&quot;, &quot;(Ljava/lang/String;)V&quot;));

        out.writeByte(opc_athrow);

        pc = (short) minfo.code.size();

        minfo.exceptionTable.add(new ExceptionTableEntry(
                tryBegin, tryEnd, pc,
                cp.getClass(&quot;java/lang/ClassNotFoundException&quot;)));

        code_astore(localSlot0, out);

        out.writeByte(opc_new);
        out.writeShort(cp.getClass(&quot;java/lang/NoClassDefFoundError&quot;));

        out.writeByte(opc_dup);

        code_aload(localSlot0, out);

        out.writeByte(opc_invokevirtual);
        out.writeShort(cp.getMethodRef(
                &quot;java/lang/Throwable&quot;, &quot;getMessage&quot;, &quot;()Ljava/lang/String;&quot;));

        out.writeByte(opc_invokespecial);
        out.writeShort(cp.getMethodRef(
                &quot;java/lang/NoClassDefFoundError&quot;,
                &quot;&lt;init&gt;&quot;, &quot;(Ljava/lang/String;)V&quot;));

        out.writeByte(opc_athrow);

        if (minfo.code.size() &gt; 65535) {
            throw new IllegalArgumentException(&quot;code size limit exceeded&quot;);
        }

        minfo.maxStack = 10;
        minfo.maxLocals = (short) (localSlot0 + 1);
        minfo.declaredExceptions = new short[0];

        return minfo;
    }


    /*
     * =============== Code Generation Utility Methods ===============
     */

    /*
     * The following methods generate code for the load or store operation
     * indicated by their name for the given local variable.  The code is
     * written to the supplied stream.
     */

    private void code_iload(int lvar, DataOutputStream out)
            throws IOException
    {
        codeLocalLoadStore(lvar, opc_iload, opc_iload_0, out);
    }

    private void code_lload(int lvar, DataOutputStream out)
            throws IOException
    {
        codeLocalLoadStore(lvar, opc_lload, opc_lload_0, out);
    }

    private void code_fload(int lvar, DataOutputStream out)
            throws IOException
    {
        codeLocalLoadStore(lvar, opc_fload, opc_fload_0, out);
    }

    private void code_dload(int lvar, DataOutputStream out)
            throws IOException
    {
        codeLocalLoadStore(lvar, opc_dload, opc_dload_0, out);
    }

    private void code_aload(int lvar, DataOutputStream out)
            throws IOException
    {
        codeLocalLoadStore(lvar, opc_aload, opc_aload_0, out);
    }

//  private void code_istore(int lvar, DataOutputStream out)
//      throws IOException
//  {
//      codeLocalLoadStore(lvar, opc_istore, opc_istore_0, out);
//  }

//  private void code_lstore(int lvar, DataOutputStream out)
//      throws IOException
//  {
//      codeLocalLoadStore(lvar, opc_lstore, opc_lstore_0, out);
//  }

//  private void code_fstore(int lvar, DataOutputStream out)
//      throws IOException
//  {
//      codeLocalLoadStore(lvar, opc_fstore, opc_fstore_0, out);
//  }

//  private void code_dstore(int lvar, DataOutputStream out)
//      throws IOException
//  {
//      codeLocalLoadStore(lvar, opc_dstore, opc_dstore_0, out);
//  }

    private void code_astore(int lvar, DataOutputStream out)
            throws IOException
    {
        codeLocalLoadStore(lvar, opc_astore, opc_astore_0, out);
    }

    /**
     * Generate code for a load or store instruction for the given local
     * variable.  The code is written to the supplied stream.
     *
     * &quot;opcode&quot; indicates the opcode form of the desired load or store
     * instruction that takes an explicit local variable index, and
     * &quot;opcode_0&quot; indicates the corresponding form of the instruction
     * with the implicit index 0.
     */
    private void codeLocalLoadStore(int lvar, int opcode, int opcode_0,
                                    DataOutputStream out)
            throws IOException
    {
        assert lvar &gt;= 0 &amp;&amp; lvar &lt;= 0xFFFF;
        if (lvar &lt;= 3) {
            out.writeByte(opcode_0 + lvar);
        } else if (lvar &lt;= 0xFF) {
            out.writeByte(opcode);
            out.writeByte(lvar &amp; 0xFF);
        } else {
            /*
             * Use the &quot;wide&quot; instruction modifier for local variable
             * indexes that do not fit into an unsigned byte.
             */
            out.writeByte(opc_wide);
            out.writeByte(opcode);
            out.writeShort(lvar &amp; 0xFFFF);
        }
    }

    /**
     * Generate code for an &quot;ldc&quot; instruction for the given constant pool
     * index (the &quot;ldc_w&quot; instruction is used if the index does not fit
     * into an unsigned byte).  The code is written to the supplied stream.
     */
    private void code_ldc(int index, DataOutputStream out)
            throws IOException
    {
        assert index &gt;= 0 &amp;&amp; index &lt;= 0xFFFF;
        if (index &lt;= 0xFF) {
            out.writeByte(opc_ldc);
            out.writeByte(index &amp; 0xFF);
        } else {
            out.writeByte(opc_ldc_w);
            out.writeShort(index &amp; 0xFFFF);
        }
    }

    /**
     * Generate code to push a constant integer value on to the operand
     * stack, using the &quot;iconst_&lt;i&gt;&quot;, &quot;bipush&quot;, or &quot;sipush&quot; instructions
     * depending on the size of the value.  The code is written to the
     * supplied stream.
     */
    private void code_ipush(int value, DataOutputStream out)
            throws IOException
    {
        if (value &gt;= -1 &amp;&amp; value &lt;= 5) {
            out.writeByte(opc_iconst_0 + value);
        } else if (value &gt;= Byte.MIN_VALUE &amp;&amp; value &lt;= Byte.MAX_VALUE) {
            out.writeByte(opc_bipush);
            out.writeByte(value &amp; 0xFF);
        } else if (value &gt;= Short.MIN_VALUE &amp;&amp; value &lt;= Short.MAX_VALUE) {
            out.writeByte(opc_sipush);
            out.writeShort(value &amp; 0xFFFF);
        } else {
            throw new AssertionError();
        }
    }

    /**
     * Generate code to invoke the Class.forName with the name of the given
     * class to get its Class object at runtime.  The code is written to
     * the supplied stream.  Note that the code generated by this method
     * may caused the checked ClassNotFoundException to be thrown.
     */
    private void codeClassForName(Class cl, DataOutputStream out)
            throws IOException
    {
        code_ldc(cp.getString(cl.getName()), out);

        out.writeByte(opc_invokestatic);
        out.writeShort(cp.getMethodRef(
                &quot;java/lang/Class&quot;,
                &quot;forName&quot;, &quot;(Ljava/lang/String;)Ljava/lang/Class;&quot;));
    }


    /*
     * ==================== General Utility Methods ====================
     */

    /**
     * Convert a fully qualified class name that uses '.' as the package
     * separator, the external representation used by the Java language
     * and APIs, to a fully qualified class name that uses '/' as the
     * package separator, the representation used in the class file
     * format (see JVMS section 4.2).
     */
    private static String dotToSlash(String name) {
        return name.replace('.', '/');
    }

    /**
     * Return the &quot;method descriptor&quot; string for a method with the given
     * parameter types and return type.  See JVMS section 4.3.3.
     */
    private static String getMethodDescriptor(Class[] parameterTypes,
                                              Class returnType)
    {
        return getParameterDescriptors(parameterTypes) +
                ((returnType == void.class) ? &quot;V&quot; : getFieldType(returnType));
    }

    /**
     * Return the list of &quot;parameter descriptor&quot; strings enclosed in
     * parentheses corresponding to the given parameter types (in other
     * words, a method descriptor without a return descriptor).  This
     * string is useful for constructing string keys for methods without
     * regard to their return type.
     */
    private static String getParameterDescriptors(Class[] parameterTypes) {
        StringBuilder desc = new StringBuilder(&quot;(&quot;);
        for (int i = 0; i &lt; parameterTypes.length; i++) {
            desc.append(getFieldType(parameterTypes[i]));
        }
        desc.append(')');
        return desc.toString();
    }

    /**
     * Return the &quot;field type&quot; string for the given type, appropriate for
     * a field descriptor, a parameter descriptor, or a return descriptor
     * other than &quot;void&quot;.  See JVMS section 4.3.2.
     */
    private static String getFieldType(Class type) {
        if (type.isPrimitive()) {
            return PrimitiveTypeInfo.get(type).baseTypeString;
        } else if (type.isArray()) {
            /*
             * According to JLS 20.3.2, the getName() method on Class does
             * return the VM type descriptor format for array classes (only);
             * using that should be quicker than the otherwise obvious code:
             *
             *     return &quot;[&quot; + getTypeDescriptor(type.getComponentType());
             */
            return type.getName().replace('.', '/');
        } else {
            return &quot;L&quot; + dotToSlash(type.getName()) + &quot;;&quot;;
        }
    }

    /**
     * Returns a human-readable string representing the signature of a
     * method with the given name and parameter types.
     */
    private static String getFriendlyMethodSignature(String name,
                                                     Class[] parameterTypes)
    {
        StringBuilder sig = new StringBuilder(name);
        sig.append('(');
        for (int i = 0; i &lt; parameterTypes.length; i++) {
            if (i &gt; 0) {
                sig.append(',');
            }
            Class parameterType = parameterTypes[i];
            int dimensions = 0;
            while (parameterType.isArray()) {
                parameterType = parameterType.getComponentType();
                dimensions++;
            }
            sig.append(parameterType.getName());
            while (dimensions-- &gt; 0) {
                sig.append(&quot;[]&quot;);
            }
        }
        sig.append(')');
        return sig.toString();
    }

    /**
     * Return the number of abstract &quot;words&quot;, or consecutive local variable
     * indexes, required to contain a value of the given type.  See JVMS
     * section 3.6.1.
     *
     * Note that the original version of the JVMS contained a definition of
     * this abstract notion of a &quot;word&quot; in section 3.4, but that definition
     * was removed for the second edition.
     */
    private static int getWordsPerType(Class type) {
        if (type == long.class || type == double.class) {
            return 2;
        } else {
            return 1;
        }
    }

    /**
     * Add to the given list all of the types in the &quot;from&quot; array that
     * are not already contained in the list and are assignable to at
     * least one of the types in the &quot;with&quot; array.
     *
     * This method is useful for computing the greatest common set of
     * declared exceptions from duplicate methods inherited from
     * different interfaces.
     */
    private static void collectCompatibleTypes(Class&lt;?&gt;[] from,
                                               Class&lt;?&gt;[] with,
                                               List&lt;Class&lt;?&gt;&gt; list)
    {
        for (int i = 0; i &lt; from.length; i++) {
            if (!list.contains(from[i])) {
                for (int j = 0; j &lt; with.length; j++) {
                    if (with[j].isAssignableFrom(from[i])) {
                        list.add(from[i]);
                        break;
                    }
                }
            }
        }
    }

    /**
     * Given the exceptions declared in the throws clause of a proxy method,
     * compute the exceptions that need to be caught from the invocation
     * handler's invoke method and rethrown intact in the method's
     * implementation before catching other Throwables and wrapping them
     * in UndeclaredThrowableExceptions.
     *
     * The exceptions to be caught are returned in a List object.  Each
     * exception in the returned list is guaranteed to not be a subclass of
     * any of the other exceptions in the list, so the catch blocks for
     * these exceptions may be generated in any order relative to each other.
     *
     * Error and RuntimeException are each always contained by the returned
     * list (if none of their superclasses are contained), since those
     * unchecked exceptions should always be rethrown intact, and thus their
     * subclasses will never appear in the returned list.
     *
     * The returned List will be empty if java.lang.Throwable is in the
     * given list of declared exceptions, indicating that no exceptions
     * need to be caught.
     */
    private static List&lt;Class&lt;?&gt;&gt; computeUniqueCatchList(Class&lt;?&gt;[] exceptions) {
        List&lt;Class&lt;?&gt;&gt; uniqueList = new ArrayList&lt;Class&lt;?&gt;&gt;();
        // unique exceptions to catch

        uniqueList.add(Error.class);            // always catch/rethrow these
        uniqueList.add(RuntimeException.class);

        nextException:
        for (int i = 0; i &lt; exceptions.length; i++) {
            Class&lt;?&gt; ex = exceptions[i];
            if (ex.isAssignableFrom(Throwable.class)) {
                /*
                 * If Throwable is declared to be thrown by the proxy method,
                 * then no catch blocks are necessary, because the invoke
                 * can, at most, throw Throwable anyway.
                 */
                uniqueList.clear();
                break;
            } else if (!Throwable.class.isAssignableFrom(ex)) {
                /*
                 * Ignore types that cannot be thrown by the invoke method.
                 */
                continue;
            }
            /*
             * Compare this exception against the current list of
             * exceptions that need to be caught:
             */
            for (int j = 0; j &lt; uniqueList.size();) {
                Class&lt;?&gt; ex2 = uniqueList.get(j);
                if (ex2.isAssignableFrom(ex)) {
                    /*
                     * if a superclass of this exception is already on
                     * the list to catch, then ignore this one and continue;
                     */
                    continue nextException;
                } else if (ex.isAssignableFrom(ex2)) {
                    /*
                     * if a subclass of this exception is on the list
                     * to catch, then remove it;
                     */
                    uniqueList.remove(j);
                } else {
                    j++;        // else continue comparing.
                }
            }
            // This exception is unique (so far): add it to the list to catch.
            uniqueList.add(ex);
        }
        return uniqueList;
    }

    /**
     * A PrimitiveTypeInfo object contains assorted information about
     * a primitive type in its public fields.  The struct for a particular
     * primitive type can be obtained using the static &quot;get&quot; method.
     */
    private static class PrimitiveTypeInfo {

        /** &quot;base type&quot; used in various descriptors (see JVMS section 4.3.2) */
        public String baseTypeString;

        /** name of corresponding wrapper class */
        public String wrapperClassName;

        /** method descriptor for wrapper class &quot;valueOf&quot; factory method */
        public String wrapperValueOfDesc;

        /** name of wrapper class method for retrieving primitive value */
        public String unwrapMethodName;

        /** descriptor of same method */
        public String unwrapMethodDesc;

        private static Map&lt;Class,PrimitiveTypeInfo&gt; table =
                new HashMap&lt;Class,PrimitiveTypeInfo&gt;();
        static {
            add(byte.class, Byte.class);
            add(char.class, Character.class);
            add(double.class, Double.class);
            add(float.class, Float.class);
            add(int.class, Integer.class);
            add(long.class, Long.class);
            add(short.class, Short.class);
            add(boolean.class, Boolean.class);
        }

        private static void add(Class primitiveClass, Class wrapperClass) {
            table.put(primitiveClass,
                    new PrimitiveTypeInfo(primitiveClass, wrapperClass));
        }

        private PrimitiveTypeInfo(Class primitiveClass, Class wrapperClass) {
            assert primitiveClass.isPrimitive();

            baseTypeString =
                    Array.newInstance(primitiveClass, 0)
                            .getClass().getName().substring(1);
            wrapperClassName = dotToSlash(wrapperClass.getName());
            wrapperValueOfDesc =
                    &quot;(&quot; + baseTypeString + &quot;)L&quot; + wrapperClassName + &quot;;&quot;;
            unwrapMethodName = primitiveClass.getName() + &quot;Value&quot;;
            unwrapMethodDesc = &quot;()&quot; + baseTypeString;
        }

        public static PrimitiveTypeInfo get(Class cl) {
            return table.get(cl);
        }
    }


    /**
     * A ConstantPool object represents the constant pool of a class file
     * being generated.  This representation of a constant pool is designed
     * specifically for use by ProxyGeneratorEx; in particular, it assumes
     * that constant pool entries will not need to be resorted (for example,
     * by their type, as the Java compiler does), so that the final index
     * value can be assigned and used when an entry is first created.
     *
     * Note that new entries cannot be created after the constant pool has
     * been written to a class file.  To prevent such logic errors, a
     * ConstantPool instance can be marked &quot;read only&quot;, so that further
     * attempts to add new entries will fail with a runtime exception.
     *
     * See JVMS section 4.4 for more information about the constant pool
     * of a class file.
     */
    private static class ConstantPool {

        /**
         * list of constant pool entries, in constant pool index order.
         *
         * This list is used when writing the constant pool to a stream
         * and for assigning the next index value.  Note that element 0
         * of this list corresponds to constant pool index 1.
         */
        private List&lt;Entry&gt; pool = new ArrayList&lt;Entry&gt;(32);

        /**
         * maps constant pool data of all types to constant pool indexes.
         *
         * This map is used to look up the index of an existing entry for
         * values of all types.
         */
        private Map&lt;Object,Short&gt; map = new HashMap&lt;Object,Short&gt;(16);

        /** true if no new constant pool entries may be added */
        private boolean readOnly = false;

        /**
         * Get or assign the index for a CONSTANT_Utf8 entry.
         */
        public short getUtf8(String s) {
            if (s == null) {
                throw new NullPointerException();
            }
            return getValue(s);
        }

        /**
         * Get or assign the index for a CONSTANT_Integer entry.
         */
        public short getInteger(int i) {
            return getValue(new Integer(i));
        }

        /**
         * Get or assign the index for a CONSTANT_Float entry.
         */
        public short getFloat(float f) {
            return getValue(new Float(f));
        }

        /**
         * Get or assign the index for a CONSTANT_Class entry.
         */
        public short getClass(String name) {
            short utf8Index = getUtf8(name);
            return getIndirect(new IndirectEntry(
                    CONSTANT_CLASS, utf8Index));
        }

        /**
         * Get or assign the index for a CONSTANT_String entry.
         */
        public short getString(String s) {
            short utf8Index = getUtf8(s);
            return getIndirect(new IndirectEntry(
                    CONSTANT_STRING, utf8Index));
        }

        /**
         * Get or assign the index for a CONSTANT_FieldRef entry.
         */
        public short getFieldRef(String className,
                                 String name, String descriptor)
        {
            short classIndex = getClass(className);
            short nameAndTypeIndex = getNameAndType(name, descriptor);
            return getIndirect(new IndirectEntry(
                    CONSTANT_FIELD, classIndex, nameAndTypeIndex));
        }

        /**
         * Get or assign the index for a CONSTANT_MethodRef entry.
         */
        public short getMethodRef(String className,
                                  String name, String descriptor)
        {
            short classIndex = getClass(className);
            short nameAndTypeIndex = getNameAndType(name, descriptor);
            return getIndirect(new IndirectEntry(
                    CONSTANT_METHOD, classIndex, nameAndTypeIndex));
        }

        /**
         * Get or assign the index for a CONSTANT_InterfaceMethodRef entry.
         */
        public short getInterfaceMethodRef(String className, String name,
                                           String descriptor)
        {
            short classIndex = getClass(className);
            short nameAndTypeIndex = getNameAndType(name, descriptor);
            return getIndirect(new IndirectEntry(
                    CONSTANT_INTERFACEMETHOD, classIndex, nameAndTypeIndex));
        }

        /**
         * Get or assign the index for a CONSTANT_NameAndType entry.
         */
        public short getNameAndType(String name, String descriptor) {
            short nameIndex = getUtf8(name);
            short descriptorIndex = getUtf8(descriptor);
            return getIndirect(new IndirectEntry(
                    CONSTANT_NAMEANDTYPE, nameIndex, descriptorIndex));
        }

        /**
         * Set this ConstantPool instance to be &quot;read only&quot;.
         *
         * After this method has been called, further requests to get
         * an index for a non-existent entry will cause an InternalError
         * to be thrown instead of creating of the entry.
         */
        public void setReadOnly() {
            readOnly = true;
        }

        /**
         * Write this constant pool to a stream as part of
         * the class file format.
         *
         * This consists of writing the &quot;constant_pool_count&quot; and
         * &quot;constant_pool[]&quot; items of the &quot;ClassFile&quot; structure, as
         * described in JVMS section 4.1.
         */
        public void write(OutputStream out) throws IOException {
            DataOutputStream dataOut = new DataOutputStream(out);

            // constant_pool_count: number of entries plus one
            dataOut.writeShort(pool.size() + 1);

            for (Entry e : pool) {
                e.write(dataOut);
            }
        }

        /**
         * Add a new constant pool entry and return its index.
         */
        private short addEntry(Entry entry) {
            pool.add(entry);
            /*
             * Note that this way of determining the index of the
             * added entry is wrong if this pool supports
             * CONSTANT_Long or CONSTANT_Double entries.
             */
            if (pool.size() &gt;= 65535) {
                throw new IllegalArgumentException(
                        &quot;constant pool size limit exceeded&quot;);
            }
            return (short) pool.size();
        }

        /**
         * Get or assign the index for an entry of a type that contains
         * a direct value.  The type of the given object determines the
         * type of the desired entry as follows:
         *
         *      java.lang.String        CONSTANT_Utf8
         *      java.lang.Integer       CONSTANT_Integer
         *      java.lang.Float         CONSTANT_Float
         *      java.lang.Long          CONSTANT_Long
         *      java.lang.Double        CONSTANT_DOUBLE
         */
        private short getValue(Object key) {
            Short index = map.get(key);
            if (index != null) {
                return index.shortValue();
            } else {
                if (readOnly) {
                    throw new InternalError(
                            &quot;late constant pool addition: &quot; + key);
                }
                short i = addEntry(new ValueEntry(key));
                map.put(key, new Short(i));
                return i;
            }
        }

        /**
         * Get or assign the index for an entry of a type that contains
         * references to other constant pool entries.
         */
        private short getIndirect(IndirectEntry e) {
            Short index = map.get(e);
            if (index != null) {
                return index.shortValue();
            } else {
                if (readOnly) {
                    throw new InternalError(&quot;late constant pool addition&quot;);
                }
                short i = addEntry(e);
                map.put(e, new Short(i));
                return i;
            }
        }

        /**
         * Entry is the abstact superclass of all constant pool entry types
         * that can be stored in the &quot;pool&quot; list; its purpose is to define a
         * common method for writing constant pool entries to a class file.
         */
        private static abstract class Entry {
            public abstract void write(DataOutputStream out)
                    throws IOException;
        }

        /**
         * ValueEntry represents a constant pool entry of a type that
         * contains a direct value (see the comments for the &quot;getValue&quot;
         * method for a list of such types).
         *
         * ValueEntry objects are not used as keys for their entries in the
         * Map &quot;map&quot;, so no useful hashCode or equals methods are defined.
         */
        private static class ValueEntry extends Entry {
            private Object value;

            public ValueEntry(Object value) {
                this.value = value;
            }

            public void write(DataOutputStream out) throws IOException {
                if (value instanceof String) {
                    out.writeByte(CONSTANT_UTF8);
                    out.writeUTF((String) value);
                } else if (value instanceof Integer) {
                    out.writeByte(CONSTANT_INTEGER);
                    out.writeInt(((Integer) value).intValue());
                } else if (value instanceof Float) {
                    out.writeByte(CONSTANT_FLOAT);
                    out.writeFloat(((Float) value).floatValue());
                } else if (value instanceof Long) {
                    out.writeByte(CONSTANT_LONG);
                    out.writeLong(((Long) value).longValue());
                } else if (value instanceof Double) {
                    out.writeDouble(CONSTANT_DOUBLE);
                    out.writeDouble(((Double) value).doubleValue());
                } else {
                    throw new InternalError(&quot;bogus value entry: &quot; + value);
                }
            }
        }

        /**
         * IndirectEntry represents a constant pool entry of a type that
         * references other constant pool entries, i.e., the following types:
         *
         *      CONSTANT_Class, CONSTANT_String, CONSTANT_Fieldref,
         *      CONSTANT_Methodref, CONSTANT_InterfaceMethodref, and
         *      CONSTANT_NameAndType.
         *
         * Each of these entry types contains either one or two indexes of
         * other constant pool entries.
         *
         * IndirectEntry objects are used as the keys for their entries in
         * the Map &quot;map&quot;, so the hashCode and equals methods are overridden
         * to allow matching.
         */
        private static class IndirectEntry extends Entry {
            private int tag;
            private short index0;
            private short index1;

            /**
             * Construct an IndirectEntry for a constant pool entry type
             * that contains one index of another entry.
             */
            public IndirectEntry(int tag, short index) {
                this.tag = tag;
                this.index0 = index;
                this.index1 = 0;
            }

            /**
             * Construct an IndirectEntry for a constant pool entry type
             * that contains two indexes for other entries.
             */
            public IndirectEntry(int tag, short index0, short index1) {
                this.tag = tag;
                this.index0 = index0;
                this.index1 = index1;
            }

            public void write(DataOutputStream out) throws IOException {
                out.writeByte(tag);
                out.writeShort(index0);
                /*
                 * If this entry type contains two indexes, write
                 * out the second, too.
                 */
                if (tag == CONSTANT_FIELD ||
                        tag == CONSTANT_METHOD ||
                        tag == CONSTANT_INTERFACEMETHOD ||
                        tag == CONSTANT_NAMEANDTYPE)
                {
                    out.writeShort(index1);
                }
            }

            public int hashCode() {
                return tag + index0 + index1;
            }

            public boolean equals(Object obj) {
                if (obj instanceof IndirectEntry) {
                    IndirectEntry other = (IndirectEntry) obj;
                    if (tag == other.tag &amp;&amp;
                            index0 == other.index0 &amp;&amp; index1 == other.index1)
                    {
                        return true;
                    }
                }
                return false;
            }
        }
    }
}
</code></pre>

<p>And this is the modified <code>Proxy</code> which I name <code>ProxyEx</code>:</p>

<pre><code class="language-java">// ProxyEx.java
package dynamicproxy.supportclass;

import java.lang.reflect.*;

public class ProxyEx {

    public static Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt; superclass, Class&lt;?&gt;... interfaces) {
        byte[] bytes = ProxyGeneratorEx.generateProxyClass(superclass.getSimpleName() + &quot;$&quot;, superclass, interfaces);
        return defineClass0(loader, &quot;$Dog&quot;, bytes, 0, bytes.length);
    }

    /**
     * TODO: no class cache support and no class name generation
     *
     * @param loader
     * @param superclass
     * @param interfaces
     * @param h
     * @return
     */
    public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt; superclass, Class&lt;?&gt;[] interfaces, InvocationHandler h) {
        Class&lt;?&gt; proxyClass = getProxyClass(loader, superclass, interfaces);
        try {
            Constructor constructor = proxyClass.getConstructor(InvocationHandler.class);
            constructor.setAccessible(true);
            return constructor.newInstance(h);
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        } catch (InstantiationException e) {
            e.printStackTrace();
        } catch (InvocationTargetException e) {
            e.printStackTrace();
        }
        return null;
    }


    private static Class&lt;?&gt; defineClass0(ClassLoader loader, String name, byte[] b, int off, int len) {
        Class proxyClass = Proxy.class;
        try {
            Method defineClass0Method = proxyClass.getDeclaredMethod(&quot;defineClass0&quot;, ClassLoader.class, String.class, byte[].class, int.class, int.class);
            defineClass0Method.setAccessible(true);
            return (Class&lt;?&gt;) defineClass0Method.invoke(null, loader, name, b, off, len);
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
        } catch (InvocationTargetException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        }
        return null;
    }
}
</code></pre>

<p>Now let&rsquo;s get a try with our dynamic proxy.</p>

<pre><code class="language-java">// Dog.java
package dynamicproxy.supportclass;

public class Dog {
    public void bark(){}
}
</code></pre>

<pre><code class="language-java">// DogInvocationHandler.java
package dynamicproxy.supportclass;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;

public class DogInvocationHandler implements InvocationHandler {
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        if(&quot;bark&quot;.equals(method.getName())) {
            System.out.println(&quot;dog barked&quot;);
        }
        return null;
    }
}
</code></pre>

<pre><code class="language-java">// Main.java
package dynamicproxy.supportclass;

public class Main {
    public static void main(String[] args) {
        System.getProperties().put(&quot;sun.misc.ProxyGeneratorEx.saveGeneratedFiles&quot;,&quot;true&quot;);

//        Class aClass = ProxyEx.getProxyClass(A.class.getClassLoader(), A.class, new Class[]{});
        Dog dog = (Dog) ProxyEx.newProxyInstance(Dog.class.getClassLoader(), Dog.class, new Class[0], new DogInvocationHandler());
        dog.bark();
    }
}
</code></pre>

<p>Here you should see the console will print &ldquo;dog barked&rdquo;.</p>

    </div>
    <footer class="post-footer">
     

     <div class="post-nav">
    <div class="post-nav-next post-nav-item">
    
        <a href="http://yangchao.me/post/dbvisualizer-tips/" rel="next" title="DbVisualizer Tips">
        <i class="fa fa-chevron-left"></i> DbVisualizer Tips
        </a>
    
    </div>

    <div class="post-nav-prev post-nav-item">
    
        <a href="http://yangchao.me/post/how-jvm-handle-method-invocation/" rel="prev" title="How JVM handle method invocation">
        How JVM handle method invocation <i class="fa fa-chevron-right"></i>
        </a>
    
    </div>
</div>
      
     
     
     




    </footer>
  </article>
</section>

          </div>
        </div>
        <div class="sidebar-toggle">
  <div class="sidebar-toggle-line-wrap">
    <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
  </div>
</div>
<aside id="sidebar" class="sidebar">
  <div class="sidebar-inner">

  <ul class="sidebar-nav motion-element">
    <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
      Table of Content
    </li>
    <li class="sidebar-nav-overview" data-target="site-overview">
      Site Information
    </li>
  </ul>

    <section class="site-overview sidebar-panel ">
      <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
        src="http://yangchao.me/img/author.jpg"
        alt="Charvis" />
    <p class="site-author-name" itemprop="name">Charvis</p>
    <p class="site-description motion-element" itemprop="description"> 
        Programmer &amp; Life explorer</p>
</div>
      <nav class="site-state motion-element">
    <div class="site-state-item site-state-posts">
      <a href="http://yangchao.me/post/">
        <span class="site-state-item-count">132</span>
        <span class="site-state-item-name">Blogs</span>
      </a>
    </div>
    <div class="site-state-item site-state-categories">    
        <a href="http://yangchao.me/categories/">       
        <span class="site-state-item-count">45</span>
        <span class="site-state-item-name">Categories</span>
        </a>
    </div>

    <div class="site-state-item site-state-tags">
        <a href="http://yangchao.me/tags/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">Tags</span>
        </a>
    </div>
</nav>
      
      
<div class="links-of-author motion-element">
    
        <span class="links-of-author-item">
        <a href="https://github.com/richardyangchao" target="_blank" title="GitHub">
            <i class="fa fa-fw fa-github"></i>
            GitHub
        </a>
        </span>
    
        <span class="links-of-author-item">
        <a href="https://linkedin.com/in/richardyangchao" target="_blank" title="Linkedin">
            <i class="fa fa-fw fa-linkedin"></i>
            Linkedin
        </a>
        </span>
    
</div>

      
      <div class="links-of-blogroll motion-element inline">
<script type="text/javascript" src="//rf.revolvermaps.com/0/0/8.js?i=5b4f2ucxar6&amp;m=0&amp;s=220&amp;c=ff0000&amp;cr1=ffffff&amp;f=arial&amp;l=33&amp;bv=35" async="async"></script>
</div>

    </section>
    
<section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
    <div class="post-toc">
        <div class="post-toc-content"><nav id="TableOfContents">
<ul>
<li><a href="#dynamic-proxy-in-jdk">Dynamic Proxy in JDK</a></li>
<li><a href="#implement-dynamic-proxy-supporting-class">Implement Dynamic Proxy supporting Class</a></li>
</ul>
</nav></div>
    </div>
</section>

  </div>
</aside>

      </div>
    </main>
   
    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  <span itemprop="copyrightYear">  &copy; 
   - 2017</span>
  <span class="with-love"><i class="fa fa-heart"></i></span>
  <span class="author" itemprop="copyrightHolder">Chao Yang</span>
</div>
<div class="powered-by">
  Powered by - <a class="theme-link" href="http://gohugo.io" target="_blank" title="hugo" >Hugo</a>
</div>
<div class="theme-info">
  Theme by - <a class="theme-link" href="https://github.com/xtfly/hugo-theme-next" target="_blank"> NexT
  </a>
</div>


      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "//hm.baidu.com/hm.js?0b07433b4ab8d587dae7d34e71973839";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
    })();
</script>
<script type="text/javascript" src="http://tajs.qq.com/stats?sId=58416275" charset="UTF-8"></script> 
<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
<script type="text/javascript" src="http://yangchao.me/js/vendor/jquery/index.js?v=2.1.3"></script>
<script type="text/javascript" src="http://yangchao.me/js/vendor/fastclick/lib/fastclick.min.js?v=1.0.6"></script> 
<script type="text/javascript" src="http://yangchao.me/js/vendor/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
<script type="text/javascript" src="http://yangchao.me/js/vendor/velocity/velocity.min.js?v=1.2.1"></script>
<script type="text/javascript" src="http://yangchao.me/js/vendor/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="http://yangchao.me/js/vendor/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>

<script src="http://yangchao.me/js/vendor/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>

<script type="text/javascript" src="http://yangchao.me/js/utils.js"></script>
<script type="text/javascript" src="http://yangchao.me/js/motion.js"></script>
<script type="text/javascript" src="http://yangchao.me/js/affix.js"></script>
<script type="text/javascript" src="http://yangchao.me/js/schemes/pisces.js"></script>

<script type="text/javascript" src="http://yangchao.me/js/scrollspy.js"></script>
<script type="text/javascript" src="http://yangchao.me/js/post-details.js"></script>
<script type="text/javascript" src="http://yangchao.me/js/toc.js"></script>

<script type="text/javascript" src="http://yangchao.me/js/bootstrap.js"></script>

</body>
</html>