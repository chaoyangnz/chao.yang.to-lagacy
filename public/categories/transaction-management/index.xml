<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Transaction Management on Chao Yang</title>
    <link>/categories/transaction-management/</link>
    <description>Recent content in Transaction Management on Chao Yang</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 03 Apr 2015 16:32:56 +0000</lastBuildDate>
    
	<atom:link href="/categories/transaction-management/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Spring framework - transaction management</title>
      <link>/post/spring-framework-transaction-management/</link>
      <pubDate>Fri, 03 Apr 2015 16:32:56 +0000</pubDate>
      
      <guid>/post/spring-framework-transaction-management/</guid>
      <description>In Java, there are multiple persistence APIs and all of them provides their own ways of transaction management.
 JDBC transaction: this is a resource-specific transaction, which is implemented by connection. JTA transaction: this is a transaction API for global transaction, it usually needs the support of application server. JPA transaction: JPA has its own transaction API by EntityManager. Hibernate transaction: Hibernate also provides its way to manage transaction by SessionFactory JDO: &amp;hellip; Now Spring transaction management abstracts and unifies all these API.</description>
    </item>
    
    <item>
      <title>PostgreSQL Concurrency with MVCC</title>
      <link>/post/postgresql-concurrency-with-mvcc/</link>
      <pubDate>Wed, 04 Mar 2015 08:12:20 +0000</pubDate>
      
      <guid>/post/postgresql-concurrency-with-mvcc/</guid>
      <description>Table of Contents  How MVCC works Disadvantages of MVCC  How MVCC works Every transaction in postgres gets a transaction ID called XID. This includes single one statement transactions such as an insert, update or delete, as well as explicitely wrapping a group of statements together via BEGIN - COMMIT. When a transaction starts, Postgres increments an XID and assigns it to the current transaction. Postgres also stores transaction information on every row in the system, which is used to determine whether a row is visible to the transaction or not.</description>
    </item>
    
    <item>
      <title>Java Transaction - JDBC, JTA, JTS</title>
      <link>/post/javaee-java-transaction-jdbc-jta-jts/</link>
      <pubDate>Tue, 10 Feb 2015 08:46:35 +0000</pubDate>
      
      <guid>/post/javaee-java-transaction-jdbc-jta-jts/</guid>
      <description>https://www.progress.com/products/datadirect-connect/jdbc-drivers/jdbc-developer-center/jdbc-tutorials/understanding-jta---the-java-transaction-api/accessing-databases
Concepts and implementation Where these come from? In transaction processing, there are several participants:
Resource Manager: like RDMS, JMS Providers(MQ), JCA Resources, transnational distributed systems
It is important to understand what constitutes a resource, in this context. For example, if you are using a JMS product, the JMS resource is the single running instance of the JMS product, notthe individual queues and topics. Moreover, sometimes, what appears to be multiple resources might actually be a single resource, if the same underlying resource is accessed in different ways.</description>
    </item>
    
    <item>
      <title>JPA - runtime</title>
      <link>/post/jpa-runtime/</link>
      <pubDate>Tue, 10 Feb 2015 03:51:29 +0000</pubDate>
      
      <guid>/post/jpa-runtime/</guid>
      <description>Core concepts A Cache is a copy of data, copy meaning pulled from but living outside the database. Flushing a Cache is the act of putting modified data back into the database. A PersistenceContext is essentially a Cache. It also tends to have it&#39;s own non-shared database connection. An EntityManager represents a PersistenceContext (and therefore a Cache) An EntityManagerFactory creates an EntityManager (and therefore a PersistenceContext/Cache) Cache == PersistenceContext Entity</description>
    </item>
    
  </channel>
</rss>