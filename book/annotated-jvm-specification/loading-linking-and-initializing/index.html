<!DOCTYPE HTML>
<html lang="en-us">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /> 
    <title> - Chao Yang</title>
    <meta name="keywords" content="Java, Programming, Android, JavaScript, Angular, Kotlin, Swift, iOS, Machine Learning, Big Data">
    
    <meta property="og:title" content="">
    <meta property="og:site_name" content="Chao Yang">
    <meta property="og:image" content="/img/author.jpg"> 
    <meta name="title" content=" - Chao Yang" />
    <meta name="description" content="A Developer in New Zealand"> 
    
    <link rel="shortcut icon" href="http://yangchao.me/img/favicon.ico" />
    <link rel="apple-touch-icon" href="http://yangchao.me/img/apple-touch-icon.png" />
    <link rel="apple-touch-icon-precomposed" href="http://yangchao.me/img/apple-touch-icon.png" />
    <link href="http://yangchao.me/js/vendor/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />
    <link href="http://yangchao.me/js/vendor/fancybox/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />
    <link href="http://yangchao.me/css/main.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
     fancybox: true, 
    motion: true
  };
</script>
    
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/styles/default.min.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/languages/kotlin.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/languages/swift.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/languages/typescript.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

</head>
<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
<div class="container one-collumn sidebar-position-left page-home  ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-meta  custom-logo ">

  <div class="custom-logo-site-title">
    <a href="http://yangchao.me/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Chao Yang</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">Nothing seek, nothing find</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
    <ul id="menu" class="menu">
      
      
        <li class="menu-item ">
          <a href="http://yangchao.me/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Home
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://yangchao.me/books" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />Minibooks
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://github.com/richdyang" rel="section">
              <i class="menu-item-icon fa fa-fw fa-code"></i> <br />Projects
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://yangchao.me/resume/cv.pdf" rel="section">
              <i class="menu-item-icon fa fa-fw fa-linkedin"></i> <br />Résumé
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://yangchao.me/post/index.html" rel="section">
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />Archive
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://yangchao.me/about/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />About
          </a>
        </li>
      
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger"> <i class="menu-item-icon fa fa-search fa-fw"></i> <br /> Search</a>
      </li>
    </ul>
    <div class="site-search">
      <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>

    </div>
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
<section id="posts" class="posts-expand">
  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link" href="http://yangchao.me/book/annotated-jvm-specification/loading-linking-and-initializing/" itemprop="url">
        
        </a>
      </h1>
      <div class="post-meta">
      <span class="post-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-o"></i>
</span>
<span class="post-meta-item-text">Published at:</span>
<time itemprop="dateCreated" datetime="2016-03-22T13:04:35+08:00" content="0001-01-01">
    0001-01-01
</time>
</span> 
      
       <span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-eye"></i>
</span>
<span class="post-meta-item-text">Reading:</span>
<span class="leancloud-visitors-count">8404 words ~40min</span>
</span>
      </div>
    </header>
    <div class="post-body" itemprop="articleBody">
    

<h2 id="chapter-5-loading-linking-and-initializing">Chapter 5. Loading, Linking, and Initializing</h2>

<p>The Java Virtual Machine dynamically loads, links and initializes classes and interfaces. Loading is the process of finding the binary representation of a class or interface type with a particular name and_creating_a class or interface from that binary representation. Linking is the process of taking a class or interface and combining it into the run-time state of the Java Virtual Machine so that it can be executed. Initialization of a class or interface consists of executing the class or interface initialization method<code>&lt;clinit&gt;</code>(<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.9">§2.9</a>).</p>

<p>In this chapter,<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.1">§5.1</a>describes how the Java Virtual Machine derives symbolic references from the binary representation of a class or interface.<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.2">§5.2</a>explains how the processes of loading, linking, and initialization are first initiated by the Java Virtual Machine.<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.3">§5.3</a>specifies how binary representations of classes and interfaces are loaded by class loaders and how classes and interfaces are created. Linking is described in<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4">§5.4</a>.<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.5">§5.5</a>details how classes and interfaces are initialized.<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.6">§5.6</a>introduces the notion of binding native methods. Finally,<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.7">§5.7</a>describes when a Java Virtual Machine exits.</p>

<h2 id="5-1-the-run-time-constant-pool">5.1. The Run-Time Constant Pool</h2>

<p>The Java Virtual Machine maintains a per-type constant pool (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.5">§2.5.5</a>), a run-time data structure that serves many of the purposes of the symbol table of a conventional programming language implementation.</p>

<p>The<code>constant_pool</code>table (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4">§4.4</a>) in the binary representation of a class or interface is used to construct the run-time constant pool upon class or interface creation (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.3">§5.3</a>). All references in the run-time constant pool are initially symbolic. The symbolic references in the run-time constant pool are derived from structures in the binary representation of the class or interface as follows:</p>

<ul>
<li><p>A symbolic reference to a class or interface is derived from a<code>CONSTANT_Class_info</code>structure (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.1">§4.4.1</a>) in the binary representation of a class or interface. Such a reference gives the name of the class or interface in the form returned by the<code>Class.getName</code>method, that is:</p>

<ul>
<li><p>For a nonarray class or an interface, the name is the binary name (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.2.1">§4.2.1</a>) of the class or interface.</p></li>

<li><p>For an array class of_n_dimensions, the name begins with_n_occurrences of the ASCII &ldquo;[&rdquo; character followed by a representation of the element type:</p></li>

<li><p>If the element type is a primitive type, it is represented by the corresponding field descriptor (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.3.2">§4.3.2</a>).</p></li>

<li><p>Otherwise, if the element type is a reference type, it is represented by the ASCII &ldquo;L&rdquo; character followed by the binary name (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.2.1">§4.2.1</a>) of the element type followed by the ASCII &ldquo;;&rdquo; character.</p></li>
</ul></li>
</ul>

<p>Whenever this chapter refers to the name of a class or interface, it should be understood to be in the form returned by the<code>Class.getName</code>method.</p>

<ul>
<li><p>A symbolic reference to a field of a class or an interface is derived from a<code>CONSTANT_Fieldref_info</code>structure (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.2">§4.4.2</a>) in the binary representation of a class or interface. Such a reference gives the name and descriptor of the field, as well as a symbolic reference to the class or interface in which the field is to be found.</p></li>

<li><p>A symbolic reference to a method of a class is derived from a<code>CONSTANT_Methodref_info</code>structure (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.2">§4.4.2</a>) in the binary representation of a class or interface. Such a reference gives the name and descriptor of the method, as well as a symbolic reference to the class in which the method is to be found.</p></li>

<li><p>A symbolic reference to a method of an interface is derived from a<code>CONSTANT_InterfaceMethodref_info</code>structure (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.2">§4.4.2</a>) in the binary representation of a class or interface. Such a reference gives the name and descriptor of the interface method, as well as a symbolic reference to the interface in which the method is to be found.</p></li>

<li><p>A symbolic reference to a method handle is derived from a<code>CONSTANT_MethodHandle_info</code>structure (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.8">§4.4.8</a>) in the binary representation of a class or interface. Such a reference gives a symbolic reference to a field of a class or interface, or a method of a class, or a method of an interface, depending on the kind of the method handle.</p></li>

<li><p>A symbolic reference to a method type is derived from a<code>CONSTANT_MethodType_info</code>structure (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.9">§4.4.9</a>) in the binary representation of a class or interface. Such a reference gives a method descriptor (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.3.3">§4.3.3</a>).</p></li>

<li><p>A symbolic reference to a_call site specifier_is derived from a<code>CONSTANT_InvokeDynamic_info</code>structure (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.10">§4.4.10</a>) in the binary representation of a class or interface. Such a reference gives:</p>

<ul>
<li><p>a symbolic reference to a method handle, which will serve as a bootstrap method for an_invokedynamic_instruction (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.invokedynamic">§<em>invokedynamic</em></a>);</p></li>

<li><p>a sequence of symbolic references (to classes, method types, and method handles), string literals, and run-time constant values which will serve as_static arguments_to a bootstrap method;</p></li>

<li><p>a method name and method descriptor.</p></li>
</ul></li>
</ul>

<p>In addition, certain run-time values which are not symbolic references are derived from items found in the<code>constant_pool</code>table:</p>

<ul>
<li>A string literal is a<code>reference</code>to an instance of class<code>String</code>, and is derived from a<code>CONSTANT_String_info</code>structure (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.3">§4.4.3</a>) in the binary representation of a class or interface. The<code>CONSTANT_String_info</code>structure gives the sequence of Unicode code points constituting the string literal.</li>
</ul>

<p>The Java programming language requires that identical string literals (that is, literals that contain the same sequence of code points) must refer to the same instance of class<code>String</code>(JLS §3.10.5). In addition, if the method<code>String.intern</code>is called on any string, the result is a<code>reference</code>to the same class instance that would be returned if that string appeared as a literal. Thus, the following expression must have the value<code>true</code>:</p>

<pre><code>  (&quot;a&quot; + &quot;b&quot; + &quot;c&quot;).intern() == &quot;abc&quot;
    
</code></pre>

<p>To derive a string literal, the Java Virtual Machine examines the sequence of code points given by the<code>CONSTANT_String_info</code>structure.</p>

<ul>
<li><p>If the method<code>String.intern</code>has previously been called on an instance of class<code>String</code>containing a sequence of Unicode code points identical to that given by the<code>CONSTANT_String_info</code>structure, then the result of string literal derivation is a<code>reference</code>to that same instance of class<code>String</code>.</p></li>

<li><p>Otherwise, a new instance of class<code>String</code>is created containing the sequence of Unicode code points given by the<code>CONSTANT_String_info</code>structure; a<code>reference</code>to that class instance is the result of string literal derivation. Finally, the<code>intern</code>method of the new<code>String</code>instance is invoked.</p></li>

<li><p>Run-time constant values are derived from<code>CONSTANT_Integer_info</code>,<code>CONSTANT_Float_info</code>,<code>CONSTANT_Long_info</code>, or<code>CONSTANT_Double_info</code>structures (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.4">§4.4.4</a>,<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.5">§4.4.5</a>) in the binary representation of a class or interface.</p></li>
</ul>

<p>Note that<code>CONSTANT_Float_info</code>structures represent values in IEEE 754 single format and<code>CONSTANT_Double_info</code>structures represent values in IEEE 754 double format (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.4">§4.4.4</a>,<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.5">§4.4.5</a>). The run-time constant values derived from these structures must thus be values that can be represented using IEEE 754 single and double formats, respectively.</p>

<p>The remaining structures in the<code>constant_pool</code>table of the binary representation of a class or interface - the<code>CONSTANT_NameAndType_info</code>and<code>CONSTANT_Utf8_info</code>structures (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.6">§4.4.6</a>,<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.7">§4.4.7</a>) - are only used indirectly when deriving symbolic references to classes, interfaces, methods, fields, method types, and method handles, and when deriving string literals and call site specifiers.</p>

<h2 id="5-2-java-virtual-machine-startup">5.2. Java Virtual Machine Startup</h2>

<p>The Java Virtual Machine starts up by creating an initial class, which is specified in an implementation-dependent manner, using the bootstrap class loader (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.3.1">§5.3.1</a>). The Java Virtual Machine then links the initial class, initializes it, and invokes the<code>public</code>class method<code>void main(String[])</code>. The invocation of this method drives all further execution. Execution of the Java Virtual Machine instructions constituting the<code>main</code>method may cause linking (and consequently creation) of additional classes and interfaces, as well as invocation of additional methods.</p>

<p>In an implementation of the Java Virtual Machine, the initial class could be provided as a command line argument. Alternatively, the implementation could provide an initial class that sets up a class loader which in turn loads an application. Other choices of the initial class are possible so long as they are consistent with the specification given in the previous paragraph.</p>

<h2 id="5-3-creation-and-loading">5.3. Creation and Loading</h2>

<p>Creation of a class or interfaceCdenoted by the name<code>N</code>consists of the construction in the method area of the Java Virtual Machine (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.4">§2.5.4</a>) of an implementation-specific internal representation ofC. Class or interface creation is triggered by another class or interfaceD, which referencesCthrough its run-time constant pool. Class or interface creation may also be triggered byDinvoking methods in certain Java SE platform class libraries (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.12">§2.12</a>) such as reflection.</p>

<p>IfCis not an array class, it is created by loading a binary representation ofC(<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html">§4 (The<code>class</code>File Format)</a>) using a class loader. Array classes do not have an external binary representation; they are created by the Java Virtual Machine rather than by a class loader.</p>

<p>There are two kinds of class loaders: the bootstrap class loader supplied by the Java Virtual Machine, and user-defined class loaders. Every user-defined class loader is an instance of a subclass of the abstract class<code>ClassLoader</code>. Applications employ user-defined class loaders in order to extend the manner in which the Java Virtual Machine dynamically loads and thereby creates classes. User-defined class loaders can be used to create classes that originate from user-defined sources. For example, a class could be downloaded across a network, generated on the fly, or extracted from an encrypted file.</p>

<p>A class loader<code>L</code>may createCby defining it directly or by delegating to another class loader. If<code>L</code>createsCdirectly, we say that<code>L</code>_defines_Cor, equivalently, that<code>L</code>is the_defining loader_ofC.</p>

<p>When one class loader delegates to another class loader, the loader that initiates the loading is not necessarily the same loader that completes the loading and defines the class. If<code>L</code>createsC, either by defining it directly or by delegation, we say that<code>L</code>initiates loading ofCor, equivalently, that<code>L</code>is an_initiating loader_ofC.</p>

<p>At run time, a class or interface is determined not by its name alone, but by a pair: its binary name (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.2.1">§4.2.1</a>) and its defining class loader. Each such class or interface belongs to a single<em>run-time package</em>. The run-time package of a class or interface is determined by the package name and defining class loader of the class or interface.</p>

<p>The Java Virtual Machine uses one of three procedures to create class or interfaceCdenoted by<code>N</code>:</p>

<ul>
<li><p>If<code>N</code>denotes a nonarray class or an interface, one of the two following methods is used to load and thereby createC:</p>

<ul>
<li><p>IfDwas defined by the bootstrap class loader, then the bootstrap class loader initiates loading ofC(<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.3.1">§5.3.1</a>).</p></li>

<li><p>IfDwas defined by a user-defined class loader, then that same user-defined class loader initiates loading ofC(<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.3.2">§5.3.2</a>).</p></li>
</ul></li>

<li><p>Otherwise<code>N</code>denotes an array class. An array class is created directly by the Java Virtual Machine (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.3.3">§5.3.3</a>), not by a class loader. However, the defining class loader ofDis used in the process of creating array classC.</p></li>
</ul>

<p>If an error occurs during class loading, then an instance of a subclass of<code>LinkageError</code>must be thrown at a point in the program that (directly or indirectly) uses the class or interface being loaded.</p>

<p>If the Java Virtual Machine ever attempts to load a classCduring verification (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.1">§5.4.1</a>) or resolution (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3">§5.4.3</a>) (but not initialization (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.5">§5.5</a>)), and the class loader that is used to initiate loading ofCthrows an instance of<code>ClassNotFoundException</code>, then the Java Virtual Machine must throw an instance of<code>NoClassDefFoundError</code>whose cause is the instance of<code>ClassNotFoundException</code>.</p>

<p>(A subtlety here is that recursive class loading to load superclasses is performed as part of resolution (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.3.5">§5.3.5</a>, step 3). Therefore, a<code>ClassNotFoundException</code>that results from a class loader failing to load a superclass must be wrapped in a<code>NoClassDefFoundError</code>.)</p>

<p>A well-behaved class loader should maintain three properties:</p>

<ul>
<li><p>Given the same name, a good class loader should always return the same<code>Class</code>object.</p></li>

<li><p>If a class loader<code>L1</code>delegates loading of a classCto another loader<code>L2</code>, then for any typeTthat occurs as the direct superclass or a direct superinterface ofC, or as the type of a field inC, or as the type of a formal parameter of a method or constructor inC, or as a return type of a method inC,<code>L1</code>and<code>L2</code>should return the same<code>Class</code>object.</p></li>

<li><p>If a user-defined classloader prefetches binary representations of classes and interfaces, or loads a group of related classes together, then it must reflect loading errors only at points in the program where they could have arisen without prefetching or group loading.</p></li>
</ul>

<p>We will sometimes represent a class or interface using the notation<code>&lt;N</code>,<code>Ld&gt;</code>, where<code>N</code>denotes the name of the class or interface and<code>Ld</code>denotes the defining loader of the class or interface.</p>

<p>We will also represent a class or interface using the notation<code>NLi</code>, where<code>N</code>denotes the name of the class or interface and<code>Li</code>denotes an initiating loader of the class or interface.</p>

<h3 id="5-3-1-loading-using-the-bootstrap-class-loader">5.3.1. Loading Using the Bootstrap Class Loader</h3>

<p>The following steps are used to load and thereby create the nonarray class or interfaceCdenoted by<code>N</code>using the bootstrap class loader.</p>

<p>First, the Java Virtual Machine determines whether the bootstrap class loader has already been recorded as an initiating loader of a class or interface denoted by<code>N</code>. If so, this class or interface isC, and no class creation is necessary.</p>

<p>Otherwise, the Java Virtual Machine passes the argument<code>N</code>to an invocation of a method on the bootstrap class loader to search for a purported representation ofCin a platform-dependent manner. Typically, a class or interface will be represented using a file in a hierarchical file system, and the name of the class or interface will be encoded in the pathname of the file.</p>

<p>Note that there is no guarantee that a purported representation found is valid or is a representation ofC. This phase of loading must detect the following error:</p>

<ul>
<li>If no purported representation ofCis found, loading throws an instance of<code>ClassNotFoundException</code>.</li>
</ul>

<p>Then the Java Virtual Machine attempts to derive a class denoted by<code>N</code>using the bootstrap class loader from the purported representation using the algorithm found in<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.3.5">§5.3.5</a>. That class isC.</p>

<h3 id="5-3-2-loading-using-a-user-defined-class-loader">5.3.2. Loading Using a User-defined Class Loader</h3>

<p>The following steps are used to load and thereby create the nonarray class or interfaceCdenoted by<code>N</code>using a user-defined class loader<code>L</code>.</p>

<p>First, the Java Virtual Machine determines whether<code>L</code>has already been recorded as an initiating loader of a class or interface denoted by<code>N</code>. If so, this class or interface isC, and no class creation is necessary.</p>

<p>Otherwise, the Java Virtual Machine invokes<code>loadClass(N</code>)on<code>L</code>. The value returned by the invocation is the created class or interfaceC. The Java Virtual Machine then records that<code>L</code>is an initiating loader ofC(<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.3.4">§5.3.4</a>). The remainder of this section describes this process in more detail.</p>

<p>When the<code>loadClass</code>method of the class loader<code>L</code>is invoked with the name<code>N</code>of a class or interfaceCto be loaded,<code>L</code>must perform one of the following two operations in order to loadC:</p>

<ol>
<li><p>The class loader<code>L</code>can create an array of bytes representingCas the bytes of a<code>ClassFile</code>structure (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.1">§4.1</a>); it then must invoke the method<code>defineClass</code>of class<code>ClassLoader</code>. Invoking<code>defineClass</code>causes the Java Virtual Machine to derive a class or interface denoted by<code>N</code>using<code>L</code>from the array of bytes using the algorithm found in<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.3.5">§5.3.5</a>.</p></li>

<li><p>The class loader<code>L</code>can delegate the loading ofCto some other class loader<code>L</code>&rsquo;. This is accomplished by passing the argument<code>N</code>directly or indirectly to an invocation of a method on<code>L</code>&rsquo; (typically the<code>loadClass</code>method). The result of the invocation isC.</p></li>
</ol>

<p>In either (1) or (2), if the class loader<code>L</code>is unable to load a class or interface denoted by<code>N</code>for any reason, it must throw an instance of<code>ClassNotFoundException</code>.</p>

<p>Since JDK release 1.1, Oracle’s Java Virtual Machine implementation has invoked the<code>loadClass</code>method of a class loader in order to cause it to load a class or interface. The argument to<code>loadClass</code>is the name of the class or interface to be loaded. There is also a two-argument version of the<code>loadClass</code>method, where the second argument is a<code>boolean</code>that indicates whether the class or interface is to be linked or not. Only the two-argument version was supplied in JDK release 1.0.2, and Oracle’s Java Virtual Machine implementation relied on it to link the loaded class or interface. From JDK release 1.1 onward, Oracle’s Java Virtual Machine implementation links the class or interface directly, without relying on the class loader.</p>

<h3 id="5-3-3-creating-array-classes">5.3.3. Creating Array Classes</h3>

<p>The following steps are used to create the array classCdenoted by<code>N</code>using class loader<code>L</code>. Class loader<code>L</code>may be either the bootstrap class loader or a user-defined class loader.</p>

<p>If<code>L</code>has already been recorded as an initiating loader of an array class with the same component type as<code>N</code>, that class isC, and no array class creation is necessary.</p>

<p>Otherwise, the following steps are performed to createC:</p>

<ol>
<li><p>If the component type is a<code>reference</code>type, the algorithm of this section (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.3">§5.3</a>) is applied recursively using class loader<code>L</code>in order to load and thereby create the component type ofC.</p></li>

<li><p>The Java Virtual Machine creates a new array class with the indicated component type and number of dimensions.</p></li>
</ol>

<p>If the component type is a<code>reference</code>type,Cis marked as having been defined by the defining class loader of the component type. Otherwise,Cis marked as having been defined by the bootstrap class loader.</p>

<p>In any case, the Java Virtual Machine then records that<code>L</code>is an initiating loader forC(<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.3.4">§5.3.4</a>).</p>

<p>If the component type is a<code>reference</code>type, the accessibility of the array class is determined by the accessibility of its component type. Otherwise, the accessibility of the array class is<code>public</code>.</p>

<h3 id="5-3-4-loading-constraints">5.3.4. Loading Constraints</h3>

<p>Ensuring type safe linkage in the presence of class loaders requires special care. It is possible that when two different class loaders initiate loading of a class or interface denoted by<code>N</code>, the name<code>N</code>may denote a different class or interface in each loader.</p>

<p>When a class or interfaceC=<code>&lt;N1</code>,<code>L1&gt;</code>makes a symbolic reference to a field or method of another class or interfaceD=<code>&lt;N2</code>,<code>L2&gt;</code>, the symbolic reference includes a descriptor specifying the type of the field, or the return and argument types of the method. It is essential that any type name<code>N</code>mentioned in the field or method descriptor denote the same class or interface when loaded by<code>L1</code>and when loaded by<code>L2</code>.</p>

<p>To ensure this, the Java Virtual Machine imposes_loading constraints_of the form<code>NL1</code>=<code>NL2</code>during preparation (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.2">§5.4.2</a>) and resolution (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3">§5.4.3</a>). To enforce these constraints, the Java Virtual Machine will, at certain prescribed times (see<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.3.1">§5.3.1</a>,<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.3.2">§5.3.2</a>,<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.3.3">§5.3.3</a>, and<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.3.5">§5.3.5</a>), record that a particular loader is an initiating loader of a particular class. After recording that a loader is an initiating loader of a class, the Java Virtual Machine must immediately check to see if any loading constraints are violated. If so, the record is retracted, the Java Virtual Machine throws a<code>LinkageError</code>, and the loading operation that caused the recording to take place fails.</p>

<p>Similarly, after imposing a loading constraint (see<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.2">§5.4.2</a>,<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.2">§5.4.3.2</a>,<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.3">§5.4.3.3</a>, and<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.4">§5.4.3.4</a>), the Java Virtual Machine must immediately check to see if any loading constraints are violated. If so, the newly imposed loading constraint is retracted, the Java Virtual Machine throws a<code>LinkageError</code>, and the operation that caused the constraint to be imposed (either resolution or preparation, as the case may be) fails.</p>

<p>The situations described here are the only times at which the Java Virtual Machine checks whether any loading constraints have been violated. A loading constraint is violated if, and only if, all the following four conditions hold:</p>

<ul>
<li><p>There exists a loader<code>L</code>such that<code>L</code>has been recorded by the Java Virtual Machine as an initiating loader of a classCnamed<code>N</code>.</p></li>

<li><p>There exists a loader<code>L</code>&rsquo; such that<code>L</code>&rsquo; has been recorded by the Java Virtual Machine as an initiating loader of a classC&rsquo; named<code>N</code>.</p></li>

<li><p>The equivalence relation defined by the (transitive closure of the) set of imposed constraints implies<code>NL</code>=<code>NL</code>&rsquo;.</p></li>

<li><p>C≠C&rsquo;.</p></li>
</ul>

<p>A full discussion of class loaders and type safety is beyond the scope of this specification. For a more comprehensive discussion, readers are referred to_Dynamic Class Loading in the Java Virtual Machine_by Sheng Liang and Gilad Bracha (<em>Proceedings of the 1998 ACM SIGPLAN Conference on Object-Oriented Programming Systems, Languages and Applications</em>).</p>

<h3 id="5-3-5-deriving-a-class-from-a-class-file-representation">5.3.5. Deriving a Class from a<code>class</code>File Representation</h3>

<p>The following steps are used to derive a<code>Class</code>object for the nonarray class or interfaceCdenoted by<code>N</code>using loader<code>L</code>from a purported representation in<code>class</code>file format.</p>

<ol>
<li><p>First, the Java Virtual Machine determines whether it has already recorded that<code>L</code>is an initiating loader of a class or interface denoted by<code>N</code>. If so, this creation attempt is invalid and loading throws a<code>LinkageError</code>.</p></li>

<li><p>Otherwise, the Java Virtual Machine attempts to parse the purported representation. However, the purported representation may not in fact be a valid representation ofC.</p></li>
</ol>

<p>This phase of loading must detect the following errors:</p>

<ul>
<li><p>If the purported representation is not a<code>ClassFile</code>structure (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.1">§4.1</a>,<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.8">§4.8</a>), loading throws an instance of<code>ClassFormatError</code>.</p></li>

<li><p>Otherwise, if the purported representation is not of a supported major or minor version (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.1">§4.1</a>), loading throws an instance of<code>UnsupportedClassVersionError</code>.</p>

<p><code>UnsupportedClassVersionError</code>, a subclass of<code>ClassFormatError</code>, was introduced to enable easy identification of a<code>ClassFormatError</code>caused by an attempt to load a class whose representation uses an unsupported version of the<code>class</code>file format. In JDK release 1.1 and earlier, an instance of<code>NoClassDefFoundError</code>or<code>ClassFormatError</code>was thrown in case of an unsupported version, depending on whether the class was being loaded by the system class loader or a user-defined class loader.</p></li>

<li><p>Otherwise, if the purported representation does not actually represent a class named<code>N</code>, loading throws an instance of<code>NoClassDefFoundError</code>or an instance of one of its subclasses.</p></li>
</ul>

<ol>
<li>IfChas a direct superclass, the symbolic reference fromCto its direct superclass is resolved using the algorithm of<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.1">§5.4.3.1</a>. Note that ifCis an interface it must have<code>Object</code>as its direct superclass, which must already have been loaded. Only<code>Object</code>has no direct superclass.</li>
</ol>

<p>Any exceptions that can be thrown due to class or interface resolution can be thrown as a result of this phase of loading. In addition, this phase of loading must detect the following errors:</p>

<ul>
<li><p>If the class or interface named as the direct superclass ofCis in fact an interface, loading throws an<code>IncompatibleClassChangeError</code>.</p></li>

<li><p>Otherwise, if any of the superclasses ofCisCitself, loading throws a<code>ClassCircularityError</code>.</p></li>
</ul>

<ol>
<li>IfChas any direct superinterfaces, the symbolic references fromCto its direct superinterfaces are resolved using the algorithm of<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.1">§5.4.3.1</a>.</li>
</ol>

<p>Any exceptions that can be thrown due to class or interface resolution can be thrown as a result of this phase of loading. In addition, this phase of loading must detect the following errors:</p>

<ul>
<li><p>If any of the classes or interfaces named as direct superinterfaces ofCis not in fact an interface, loading throws an<code>IncompatibleClassChangeError</code>.</p></li>

<li><p>Otherwise, if any of the superinterfaces ofCisCitself, loading throws a<code>ClassCircularityError</code>.</p></li>
</ul>

<ol>
<li>The Java Virtual Machine marksCas having<code>L</code>as its defining class loader and records that<code>L</code>is an initiating loader ofC(<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.3.4">§5.3.4</a>).</li>
</ol>

<h2 id="5-4-linking">5.4. Linking</h2>

<p>Linking a class or interface involves verifying and preparing that class or interface, its direct superclass, its direct superinterfaces, and its element type (if it is an array type), if necessary. Resolution of symbolic references in the class or interface is an optional part of linking.</p>

<p>This specification allows an implementation flexibility as to when linking activities (and, because of recursion, loading) take place, provided that all of the following properties are maintained:</p>

<ul>
<li><p>A class or interface is completely loaded before it is linked.</p></li>

<li><p>A class or interface is completely verified and prepared before it is initialized.</p></li>

<li><p>Errors detected during linkage are thrown at a point in the program where some action is taken by the program that might, directly or indirectly, require linkage to the class or interface involved in the error.</p></li>
</ul>

<p>For example, a Java Virtual Machine implementation may choose to resolve each symbolic reference in a class or interface individually when it is used (&ldquo;lazy&rdquo; or &ldquo;late&rdquo; resolution), or to resolve them all at once when the class is being verified (&ldquo;eager&rdquo; or &ldquo;static&rdquo; resolution). This means that the resolution process may continue, in some implementations, after a class or interface has been initialized. Whichever strategy is followed, any error detected during resolution must be thrown at a point in the program that (directly or indirectly) uses a symbolic reference to the class or interface.</p>

<p>Because linking involves the allocation of new data structures, it may fail with an<code>OutOfMemoryError</code>.</p>

<h3 id="5-4-1-verification">5.4.1. Verification</h3>

<p><em>Verification</em>(<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.10">§4.10</a>) ensures that the binary representation of a class or interface is structurally correct (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.9">§4.9</a>). Verification may cause additional classes and interfaces to be loaded (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.3">§5.3</a>) but need not cause them to be verified or prepared.</p>

<p>If the binary representation of a class or interface does not satisfy the static or structural constraints listed in<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.9">§4.9</a>, then a<code>VerifyError</code>must be thrown at the point in the program that caused the class or interface to be verified.</p>

<p>If an attempt by the Java Virtual Machine to verify a class or interface fails because an error is thrown that is an instance of<code>LinkageError</code>(or a subclass), then subsequent attempts to verify the class or interface always fail with the same error that was thrown as a result of the initial verification attempt.</p>

<h3 id="5-4-2-preparation">5.4.2. Preparation</h3>

<p>_Preparation_involves creating the static fields for a class or interface and initializing such fields to their default values (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.3">§2.3</a>,<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.4">§2.4</a>). This does not require the execution of any Java Virtual Machine code; explicit initializers for static fields are executed as part of initialization (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.5">§5.5</a>), not preparation.</p>

<p>During preparation of a class or interfaceC, the Java Virtual Machine also imposes loading constraints (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.3.4">§5.3.4</a>). Let<code>L1</code>be the defining loader ofC. For each method<code>m</code>declared inCthat overrides (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.5">§5.4.5</a>) a method declared in a superclass or superinterface<code>&lt;</code>D,<code>L2&gt;</code>, the Java Virtual Machine imposes the following loading constraints:</p>

<p>Given that the return type of<code>m</code>isTr, and that the formal parameter types of<code>m</code>areTf1, &hellip;,Tfn, then:</p>

<p>IfTrnot an array type, letT0beTr; otherwise, letT0be the element type (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.4">§2.4</a>) ofTr.</p>

<p>For<em>i</em>= 1 to<em>n</em>: IfTfiis not an array type, letTibeTfi; otherwise, letTibe the element type (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.4">§2.4</a>) ofTfi.</p>

<p>ThenTi<code>L1</code>=Ti<code>L2</code>for<em>i</em>= 0 to<em>n</em>.</p>

<p>Furthermore, ifCimplements a method<code>m</code>declared in a superinterface<code>&lt;</code>I,<code>L3&gt;</code>ofC, butCdoes not itself declare the method<code>m</code>, then let<code>&lt;</code>D,<code>L2&gt;</code>be the superclass ofCthat declares the implementation of method<code>m</code>inherited byC. The Java Virtual Machine imposes the following constraints:</p>

<p>Given that the return type of<code>m</code>isTr, and that the formal parameter types of<code>m</code>areTf1, &hellip;,Tfn, then:</p>

<p>IfTrnot an array type, letT0beTr; otherwise, letT0be the element type (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.4">§2.4</a>) ofTr.</p>

<p>For<em>i</em>= 1 to<em>n</em>: IfTfiis not an array type, letTibeTfi; otherwise, letTibe the element type (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.4">§2.4</a>) ofTfi.</p>

<p>ThenTi<code>L2</code>=Ti<code>L3</code>for<em>i</em>= 0 to<em>n</em>.</p>

<p>Preparation may occur at any time following creation but must be completed prior to initialization.</p>

<h3 id="5-4-3-resolution">5.4.3. Resolution</h3>

<p>The Java Virtual Machine instructions<em>anewarray</em>,<em>checkcast</em>,<em>getfield</em>,<em>getstatic</em>,<em>instanceof</em>,<em>invokedynamic</em>,<em>invokeinterface</em>,<em>invokespecial</em>,<em>invokestatic</em>,<em>invokevirtual</em>,<em>ldc</em>,<em>ldc_w</em>,<em>multianewarray</em>,<em>new</em>,<em>putfield</em>, and_putstatic_make symbolic references to the run-time constant pool. Execution of any of these instructions requires resolution of its symbolic reference.</p>

<p>_Resolution_is the process of dynamically determining concrete values from symbolic references in the run-time constant pool.</p>

<p>Resolution of the symbolic reference of one occurrence of an_invokedynamic_instruction_does not_imply that the same symbolic reference is considered resolved for any other_invokedynamic_instruction.</p>

<p>For all other instructions above, resolution of the symbolic reference of one occurrence of an instruction_does_imply that the same symbolic reference is considered resolved for any other non-_invokedynamic_instruction.</p>

<p>(The above text implies that the concrete value determined by resolution for a specific_invokedynamic_instruction is a call site object bound to that specific_invokedynamic_instruction.)</p>

<p>Resolution can be attempted on a symbolic reference that has already been resolved. An attempt to resolve a symbolic reference that has already successfully been resolved always succeeds trivially and always results in the same entity produced by the initial resolution of that reference.</p>

<p>If an error occurs during resolution of a symbolic reference, then an instance of<code>IncompatibleClassChangeError</code>(or a subclass) must be thrown at a point in the program that (directly or indirectly) uses the symbolic reference.</p>

<p>If an attempt by the Java Virtual Machine to resolve a symbolic reference fails because an error is thrown that is an instance of<code>LinkageError</code>(or a subclass), then subsequent attempts to resolve the reference always fail with the same error that was thrown as a result of the initial resolution attempt.</p>

<p>A symbolic reference to a call site specifier by a specific_invokedynamic_instruction must not be resolved prior to execution of that instruction.</p>

<p>In the case of failed resolution of an_invokedynamic_instruction, the bootstrap method is not re-executed on subsequent resolution attempts.</p>

<p>Certain of the instructions above require additional linking checks when resolving symbolic references. For instance, in order for a_getfield_instruction to successfully resolve the symbolic reference to the field on which it operates, it must not only complete the field resolution steps given in<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.2">§5.4.3.2</a>but also check that the field is not<code>static</code>. If it is a<code>static</code>field, a linking exception must be thrown.</p>

<p>Notably, in order for an_invokedynamic_instruction to successfully resolve the symbolic reference to a call site specifier, the bootstrap method specified therein must complete normally and return a suitable call site object. If the bootstrap method completes abruptly or returns an unsuitable call site object, a linking exception must be thrown.</p>

<p>Linking exceptions generated by checks that are specific to the execution of a particular Java Virtual Machine instruction are given in the description of that instruction and are not covered in this general discussion of resolution. Note that such exceptions, although described as part of the execution of Java Virtual Machine instructions rather than resolution, are still properly considered failures of resolution.</p>

<p>The following sections describe the process of resolving a symbolic reference in the run-time constant pool (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.1">§5.1</a>) of a class or interfaceD. Details of resolution differ with the kind of symbolic reference to be resolved.</p>

<h4 id="5-4-3-1-class-and-interface-resolution">5.4.3.1. Class and Interface Resolution</h4>

<p>To resolve an unresolved symbolic reference fromDto a class or interfaceCdenoted by<code>N</code>, the following steps are performed:</p>

<ol>
<li>The defining class loader ofDis used to create a class or interface denoted by<code>N</code>. This class or interface isC. The details of the process are given in<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.3">§5.3</a>.</li>
</ol>

<p>Any exception that can be thrown as a result of failure of class or interface creation can thus be thrown as a result of failure of class and interface resolution.</p>

<ol>
<li><p>IfCis an array class and its element type is a<code>reference</code>type, then a symbolic reference to the class or interface representing the element type is resolved by invoking the algorithm in<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.1">§5.4.3.1</a>recursively.</p></li>

<li><p>Finally, access permissions toCare checked.</p>

<ul>
<li>IfCis not accessible (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.4">§5.4.4</a>) toD, class or interface resolution throws an<code>IllegalAccessError</code>.</li>
</ul>

<p>This condition can occur, for example, ifCis a class that was originally declared to be<code>public</code>but was changed to be non-<code>public</code>afterDwas compiled.</p></li>
</ol>

<p>If steps 1 and 2 succeed but step 3 fails,Cis still valid and usable. Nevertheless, resolution fails, andDis prohibited from accessingC.</p>

<h4 id="5-4-3-2-field-resolution">5.4.3.2. Field Resolution</h4>

<p>To resolve an unresolved symbolic reference fromDto a field in a class or interfaceC, the symbolic reference toCgiven by the field reference must first be resolved (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.1">§5.4.3.1</a>). Therefore, any exception that can be thrown as a result of failure of resolution of a class or interface reference can be thrown as a result of failure of field resolution. If the reference toCcan be successfully resolved, an exception relating to the failure of resolution of the field reference itself can be thrown.</p>

<p>When resolving a field reference, field resolution first attempts to look up the referenced field inCand its superclasses:</p>

<ol>
<li><p>IfCdeclares a field with the name and descriptor specified by the field reference, field lookup succeeds. The declared field is the result of the field lookup.</p></li>

<li><p>Otherwise, field lookup is applied recursively to the direct superinterfaces of the specified class or interfaceC.</p></li>

<li><p>Otherwise, ifChas a superclassS, field lookup is applied recursively toS.</p></li>

<li><p>Otherwise, field lookup fails.</p></li>
</ol>

<p>Then:</p>

<ul>
<li><p>If field lookup fails, field resolution throws a<code>NoSuchFieldError</code>.</p></li>

<li><p>Otherwise, if field lookup succeeds but the referenced field is not accessible (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.4">§5.4.4</a>) toD, field resolution throws an<code>IllegalAccessError</code>.</p></li>

<li><p>Otherwise, let<code>&lt;</code>E,<code>L1&gt;</code>be the class or interface in which the referenced field is actually declared and let<code>L2</code>be the defining loader ofD.</p></li>
</ul>

<p>Given that the type of the referenced field isTf, letTbeTfifTfis not an array type, and letTbe the element type (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.4">§2.4</a>) ofTfotherwise.</p>

<p>The Java Virtual Machine must impose the loading constraint thatT<code>L1</code>=T<code>L2</code>(<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.3.4">§5.3.4</a>).</p>

<h4 id="5-4-3-3-method-resolution">5.4.3.3. Method Resolution</h4>

<p>To resolve an unresolved symbolic reference fromDto a method in a classC, the symbolic reference toCgiven by the method reference is first resolved (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.1">§5.4.3.1</a>). Therefore, any exception that can be thrown as a result of failure of resolution of a class reference can be thrown as a result of failure of method resolution. If the reference toCcan be successfully resolved, exceptions relating to the resolution of the method reference itself can be thrown.</p>

<p>When resolving a method reference:</p>

<ol>
<li><p>IfCis an interface, method resolution throws an<code>IncompatibleClassChangeError</code>.</p></li>

<li><p>Otherwise, method resolution attempts to locate the referenced method inCand its superclasses:</p>

<ul>
<li>IfCdeclares exactly one method with the name specified by the method reference, and the declaration is a signature polymorphic method (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.9">§2.9</a>), then method lookup succeeds. All the class names mentioned in the descriptor are resolved (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.1">§5.4.3.1</a>).</li>
</ul>

<p>_The resolved method is the signature polymorphic method declaration._It is not necessary forCto declare a method with the descriptor specified by the method reference.</p>

<ul>
<li><p>Otherwise, ifCdeclares a method with the name and descriptor specified by the method reference, method lookup succeeds.</p></li>

<li><p>Otherwise, ifChas a superclass, step 2 of method resolution is recursively invoked on the direct superclass ofC.</p></li>
</ul></li>

<li><p>Otherwise, method resolution attempts to locate the referenced method in the superinterfaces of the specified classC:</p>

<ul>
<li><p>If the_maximally-specific superinterface methods_ofCfor the name and descriptor specified by the method reference include exactly one method that does not have its<code>ACC_ABSTRACT</code>flag set, then this method is chosen and method lookup succeeds.</p></li>

<li><p>Otherwise, if any superinterface ofCdeclares a method with the name and descriptor specified by the method reference that has neither its<code>ACC_PRIVATE</code>flag nor its<code>ACC_STATIC</code>flag set, one of these is arbitrarily chosen and method lookup succeeds.</p></li>

<li><p>Otherwise, method lookup fails.</p></li>
</ul></li>
</ol>

<p>A_maximally-specific superinterface method_of a class or interfaceCfor a particular method name and descriptor is any method for which all of the following are true:</p>

<ul>
<li><p>The method is declared in a superinterface (direct or indirect) ofC.</p></li>

<li><p>The method is declared with the specified name and descriptor.</p></li>

<li><p>The method has neither its<code>ACC_PRIVATE</code>flag nor its<code>ACC_STATIC</code>flag set.</p></li>

<li><p>Where the method is declared in interfaceI, there exists no other maximally-specific superinterface method ofCwith the specified name and descriptor that is declared in a subinterface ofI.</p></li>
</ul>

<p>The result of method resolution is determined by whether method lookup succeeds or fails:</p>

<ul>
<li><p>If method lookup fails, method resolution throws a<code>NoSuchMethodError</code>.</p></li>

<li><p>Otherwise, if method lookup succeeds and the referenced method is not accessible (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.4">§5.4.4</a>) toD, method resolution throws an<code>IllegalAccessError</code>.</p></li>

<li><p>Otherwise, let<code>&lt;</code>E,<code>L1&gt;</code>be the class or interface in which the referenced method<code>m</code>is actually declared, and let<code>L2</code>be the defining loader ofD.</p></li>
</ul>

<p>Given that the return type of<code>m</code>isTr, and that the formal parameter types of<code>m</code>areTf1, &hellip;,Tfn, then:</p>

<p>IfTris not an array type, letT0beTr; otherwise, letT0be the element type (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.4">§2.4</a>) ofTr.</p>

<p>For<em>i</em>= 1 to<em>n</em>: IfTfiis not an array type, letTibeTfi; otherwise, letTibe the element type (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.4">§2.4</a>) ofTfi.</p>

<p>The Java Virtual Machine must impose the loading constraintsTi<code>L1</code>=Ti<code>L2</code>for<em>i</em>= 0 to<em>n</em>(<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.3.4">§5.3.4</a>).</p>

<p>When resolution searches for a method in the class&rsquo;s superinterfaces, the best outcome is to identify a maximally-specific non-<code>abstract</code>method. It is possible that this method will be chosen by method selection, so it is desirable to add class loader constraints for it.</p>

<p>Otherwise, the result is nondeterministic. This is not new:_TheJava® Virtual Machine Specification_has never identified exactly which method is chosen, and how &ldquo;ties&rdquo; should be broken. Prior to Java SE 8, this was mostly an unobservable distinction. However, beginning with Java SE 8, the set of interface methods is more heterogenous, so care must be taken to avoid problems with nondeterministic behavior. Thus:</p>

<ul>
<li><p>Superinterface methods that are<code>private</code>and<code>static</code>are ignored by resolution. This is consistent with the Java programming language, where such interface methods are not inherited.</p></li>

<li><p>Any behavior controlled by the resolved method should not depend on whether the method is<code>abstract</code>or not.</p></li>
</ul>

<p>Note that if the result of resolution is an<code>abstract</code>method, the referenced classCmay be non-<code>abstract</code>. RequiringCto be<code>abstract</code>would conflict with the nondeterministic choice of superinterface methods. Instead, resolution assumes that the run time class of the invoked object has a concrete implementation of the method.</p>

<h4 id="5-4-3-4-interface-method-resolution">5.4.3.4. Interface Method Resolution</h4>

<p>To resolve an unresolved symbolic reference fromDto an interface method in an interfaceC, the symbolic reference toCgiven by the interface method reference is first resolved (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.1">§5.4.3.1</a>). Therefore, any exception that can be thrown as a result of failure of resolution of an interface reference can be thrown as a result of failure of interface method resolution. If the reference toCcan be successfully resolved, exceptions relating to the resolution of the interface method reference itself can be thrown.</p>

<p>When resolving an interface method reference:</p>

<ol>
<li><p>IfCis not an interface, interface method resolution throws an<code>IncompatibleClassChangeError</code>.</p></li>

<li><p>Otherwise, ifCdeclares a method with the name and descriptor specified by the interface method reference, method lookup succeeds.</p></li>

<li><p>Otherwise, if the class<code>Object</code>declares a method with the name and descriptor specified by the interface method reference, which has its<code>ACC_PUBLIC</code>flag set and does not have its<code>ACC_STATIC</code>flag set, method lookup succeeds.</p></li>

<li><p>Otherwise, if the maximally-specific superinterface methods (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.3">§5.4.3.3</a>) ofCfor the name and descriptor specified by the method reference include exactly one method that does not have its<code>ACC_ABSTRACT</code>flag set, then this method is chosen and method lookup succeeds.</p></li>

<li><p>Otherwise, if any superinterface ofCdeclares a method with the name and descriptor specified by the method reference that has neither its<code>ACC_PRIVATE</code>flag nor its<code>ACC_STATIC</code>flag set, one of these is arbitrarily chosen and method lookup succeeds.</p></li>

<li><p>Otherwise, method lookup fails.</p></li>
</ol>

<p>The result of interface method resolution is determined by whether method lookup succeeds or fails:</p>

<ul>
<li><p>If method lookup fails, interface method resolution throws a<code>NoSuchMethodError</code>.</p></li>

<li><p>If method lookup succeeds and the referenced method is not accessible (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.4">§5.4.4</a>) toD, interface method resolution throws an<code>IllegalAccessError</code>.</p></li>

<li><p>Otherwise, let<code>&lt;</code>E,<code>L1&gt;</code>be the class or interface in which the referenced interface method<code>m</code>is actually declared, and let<code>L2</code>be the defining loader ofD.</p></li>
</ul>

<p>Given that the return type of<code>m</code>isTr, and that the formal parameter types of<code>m</code>areTf1, &hellip;,Tfn, then:</p>

<p>IfTris not an array type, letT0beTr; otherwise, letT0be the element type (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.4">§2.4</a>) ofTr.</p>

<p>For<em>i</em>= 1 to<em>n</em>: IfTfiis not an array type, letTibeTfi; otherwise, letTibe the element type (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.4">§2.4</a>) ofTfi.</p>

<p>The Java Virtual Machine must impose the loading constraintsTi<code>L1</code>=Ti<code>L2</code>for<em>i</em>= 0 to<em>n</em>(<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.3.4">§5.3.4</a>).</p>

<p>The clause about accessibility is necessary because interface method resolution may pick a<code>private</code>method of interfaceC. (Prior to Java SE 8, the result of interface method resolution could be a non-<code>public</code>method of class<code>Object</code>or a<code>static</code>method of class<code>Object</code>; such results were not consistent with the inheritance model of the Java programming language, and are disallowed in Java SE 8 and above.)</p>

<h4 id="5-4-3-5-method-type-and-method-handle-resolution">5.4.3.5. Method Type and Method Handle Resolution</h4>

<p>To resolve an unresolved symbolic reference to a method type, it is as if resolution occurs of unresolved symbolic references to classes and interfaces (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.1">§5.4.3.1</a>) whose names correspond to the types given in the method descriptor (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.3.3">§4.3.3</a>).</p>

<p>Any exception that can be thrown as a result of failure of resolution of a class reference can thus be thrown as a result of failure of method type resolution.</p>

<p>The result of successful method type resolution is a<code>reference</code>to an instance of<code>java.lang.invoke.MethodType</code>which represents the method descriptor.</p>

<p>Method type resolution occurs regardless of whether the run time constant pool actually contains symbolic references to classes and interfaces indicated in the method descriptor. Also, the resolution is deemed to occur on_unresolved_symbolic references, so a failure to resolve one method type will not necessarily lead to a later failure to resolve another method type with the same textual method descriptor, if suitable classes and interfaces can be loaded by the later time.</p>

<p>Resolution of an unresolved symbolic reference to a method handle is more complicated. Each method handle resolved by the Java Virtual Machine has an equivalent instruction sequence called its<em>bytecode behavior</em>, indicated by the method handle&rsquo;s<em>kind</em>. The integer values and descriptions of the nine kinds of method handle are given in<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.5-220">Table 5.4.3.5-A</a>.</p>

<p>Symbolic references by an instruction sequence to fields or methods are indicated by<code>C.x:T</code>, where<code>x</code>and<code>T</code>are the name and descriptor (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.3.2">§4.3.2</a>,<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.3.3">§4.3.3</a>) of the field or method, and<code>C</code>is the class or interface in which the field or method is to be found.</p>

<p><strong>Table 5.4.3.5-A. Bytecode Behaviors for Method Handles</strong></p>

<table>
<thead>
<tr>
<th align="left">Kind</th>
<th align="left">Description</th>
<th align="left">Interpretation</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">1</td>
<td align="left"><code>REF_getField</code></td>
<td align="left"><code>getfield C.f:T</code></td>
</tr>

<tr>
<td align="left">2</td>
<td align="left"><code>REF_getStatic</code></td>
<td align="left"><code>getstatic C.f:T</code></td>
</tr>

<tr>
<td align="left">3</td>
<td align="left"><code>REF_putField</code></td>
<td align="left"><code>putfield C.f:T</code></td>
</tr>

<tr>
<td align="left">4</td>
<td align="left"><code>REF_putStatic</code></td>
<td align="left"><code>putstatic C.f:T</code></td>
</tr>

<tr>
<td align="left">5</td>
<td align="left"><code>REF_invokeVirtual</code></td>
<td align="left"><code>invokevirtual C.m:(A*)T</code></td>
</tr>

<tr>
<td align="left">6</td>
<td align="left"><code>REF_invokeStatic</code></td>
<td align="left"><code>invokestatic C.m:(A*)T</code></td>
</tr>

<tr>
<td align="left">7</td>
<td align="left"><code>REF_invokeSpecial</code></td>
<td align="left"><code>invokespecial C.m:(A*)T</code></td>
</tr>

<tr>
<td align="left">8</td>
<td align="left"><code>REF_newInvokeSpecial</code></td>
<td align="left"><code>new C; dup; invokespecial C.&lt;init&gt;</code>:(A*)V</td>
</tr>

<tr>
<td align="left">9</td>
<td align="left"><code>REF_invokeInterface</code></td>
<td align="left"><code>invokeinterface C.m:(A*)T</code></td>
</tr>
</tbody>
</table>

<p>Let<code>MH</code>be the symbolic reference to a method handle (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.1">§5.1</a>) being resolved. Then:</p>

<ul>
<li>LetRbe the symbolic reference to the field or method contained within<code>MH</code>.</li>
</ul>

<p>(Ris derived from the<code>CONSTANT_Fieldref</code>,<code>CONSTANT_Methodref</code>, or<code>CONSTANT_InterfaceMethodref</code>structure referred to by the<code>reference_index</code>item of the<code>CONSTANT_MethodHandle</code>from which<code>MH</code>is derived.)</p>

<ul>
<li>LetTbe the type of the field referenced byR, or the return type of the method referenced byR. LetA* be the sequence (perhaps empty) of parameter types of the method referenced byR.</li>
</ul>

<p>(TandA* are derived from the<code>CONSTANT_NameAndType</code>structure referred to by the<code>name_and_type_index</code>item in the<code>CONSTANT_Fieldref</code>,<code>CONSTANT_Methodref</code>, or<code>CONSTANT_InterfaceMethodref</code>structure from whichRis derived.)</p>

<p>To resolve<code>MH</code>, all symbolic references to classes, interfaces, fields, and methods in<code>MH</code>&rsquo;s bytecode behavior are resolved, using the following three steps:</p>

<ul>
<li><p>First,Ris resolved.</p></li>

<li><p>Second, resolution occurs as if of unresolved symbolic references to classes and interfaces whose names correspond to each type inA*, and to the typeT, in that order.</p></li>

<li><p>Third, a reference to an instance of<code>java.lang.invoke.MethodType</code>is obtained as if by resolution of an unresolved symbolic reference to a method type that contains the method descriptor specified in<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.5-260">Table 5.4.3.5-B</a>for the kind of<code>MH</code>.</p></li>
</ul>

<p>It is as if the symbolic reference to a method handle contains a symbolic reference to the method type that the resolved method handle will eventually have. The detailed structure of the method type is obtained by inspecting<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.5-260">Table 5.4.3.5-B</a>.</p>

<p>In each step, any exception that can be thrown as a result of failure of resolution of a class or interface or field or method reference can be thrown as a result of failure of method handle resolution.</p>

<p>The intent is that resolving a method handle can be done in exactly the same circumstances that the Java Virtual Machine would successfully resolve the symbolic references in the bytecode behavior. In particular, method handles to<code>private</code>and<code>protected</code>members can be created in exactly those classes for which the corresponding normal accesses are legal.</p>

<p><strong>Table 5.4.3.5-B. Method Descriptors for Method Handles</strong></p>

<table>
<thead>
<tr>
<th align="left">Kind</th>
<th align="left">Description</th>
<th align="left">Method descriptor</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">1</td>
<td align="left"><code>REF_getField</code></td>
<td align="left"><code>(C)T</code></td>
</tr>

<tr>
<td align="left">2</td>
<td align="left"><code>REF_getStatic</code></td>
<td align="left"><code>()T</code></td>
</tr>

<tr>
<td align="left">3</td>
<td align="left"><code>REF_putField</code></td>
<td align="left"><code>(C,T)V</code></td>
</tr>

<tr>
<td align="left">4</td>
<td align="left"><code>REF_putStatic</code></td>
<td align="left"><code>(T)V</code></td>
</tr>

<tr>
<td align="left">5</td>
<td align="left"><code>REF_invokeVirtual</code></td>
<td align="left"><code>(C,A*)T</code></td>
</tr>

<tr>
<td align="left">6</td>
<td align="left"><code>REF_invokeStatic</code></td>
<td align="left"><code>(A*)T</code></td>
</tr>

<tr>
<td align="left">7</td>
<td align="left"><code>REF_invokeSpecial</code></td>
<td align="left"><code>(C,A*)T</code></td>
</tr>

<tr>
<td align="left">8</td>
<td align="left"><code>REF_newInvokeSpecial</code></td>
<td align="left"><code>(A*)C</code></td>
</tr>

<tr>
<td align="left">9</td>
<td align="left"><code>REF_invokeInterface</code></td>
<td align="left"><code>(C,A*)T</code></td>
</tr>
</tbody>
</table>

<p>The result of successful method handle resolution is a<code>reference</code>to an instance of<code>java.lang.invoke.MethodHandle</code>which represents the method handle<code>MH</code>.</p>

<p>The type descriptor of this<code>java.lang.invoke.MethodHandle</code>instance is the<code>java.lang.invoke.MethodType</code>instance produced in the third step of method handle resolution above.</p>

<p>The type descriptor of a method handle is such that a valid call to<code>invokeExact</code>in<code>java.lang.invoke.MethodHandle</code>on the method handle has exactly the same stack effects as the bytecode behavior. Calling this method handle on a valid set of arguments has exactly the same effect and returns the same result (if any) as the corresponding bytecode behavior.</p>

<p>If the method referenced byRhas the<code>ACC_VARARGS</code>flag set (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.6">§4.6</a>), then the<code>java.lang.invoke.MethodHandle</code>instance is a variable arity method handle; otherwise, it is a fixed arity method handle.</p>

<p>A variable arity method handle performs argument list boxing (JLS §15.12.4.2) when invoked via<code>invoke</code>, while its behavior with respect to<code>invokeExact</code>is as if the<code>ACC_VARARGS</code>flag were not set.</p>

<p>Method handle resolution throws an<code>IncompatibleClassChangeError</code>if the method referenced byRhas the<code>ACC_VARARGS</code>flag set and eitherA* is an empty sequence or the last parameter type inA* is not an array type. That is, creation of a variable arity method handle fails.</p>

<p>An implementation of the Java Virtual Machine is not required to intern method types or method handles. That is, two distinct symbolic references to method types or method handles which are structurally identical might not resolve to the same instance of<code>java.lang.invoke.MethodType</code>or<code>java.lang.invoke.MethodHandle</code>respectively.</p>

<p>The<code>java.lang.invoke.MethodHandles</code>class in the Java SE platform API allows creation of method handles with no bytecode behavior. Their behavior is defined by the method of<code>java.lang.invoke.MethodHandles</code>that creates them. For example, a method handle may, when invoked, first apply transformations to its argument values, then supply the transformed values to the invocation of another method handle, then apply a transformation to the value returned from that invocation, then return the transformed value as its own result.</p>

<h4 id="5-4-3-6-call-site-specifier-resolution">5.4.3.6. Call Site Specifier Resolution</h4>

<p>To resolve an unresolved symbolic reference to a call site specifier involves three steps:</p>

<ul>
<li><p>A call site specifier gives a symbolic reference to a method handle which is to serve as the_bootstrap method_for a dynamic call site (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.23">§4.7.23</a>). The method handle is resolved to obtain a<code>reference</code>to an instance of<code>java.lang.invoke.MethodHandle</code>(<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.5">§5.4.3.5</a>).</p></li>

<li><p>A call site specifier gives a method descriptor,<em>TD</em>. A<code>reference</code>to an instance of<code>java.lang.invoke.MethodType</code>is obtained as if by resolution of a symbolic reference to a method type with the same parameter and return types as<em>TD</em>(<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.5">§5.4.3.5</a>).</p></li>

<li><p>A call site specifier gives zero or more<em>static arguments</em>, which communicate application-specific metadata to the bootstrap method. Any static arguments which are symbolic references to classes, method handles, or method types are resolved, as if by invocation of the_ldc_instruction (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.ldc">§<em>ldc</em></a>), to obtain<code>reference</code>s to<code>Class</code>objects,<code>java.lang.invoke.MethodHandle</code>objects, and<code>java.lang.invoke.MethodType</code>objects respectively. Any static arguments that are string literals are used to obtain<code>reference</code>s to<code>String</code>objects.</p></li>
</ul>

<p>The result of call site specifier resolution is a tuple consisting of:</p>

<ul>
<li><p>the<code>reference</code>to an instance of<code>java.lang.invoke.MethodHandle</code>,</p></li>

<li><p>the<code>reference</code>to an instance of<code>java.lang.invoke.MethodType</code>,</p></li>

<li><p>the<code>reference</code>s to instances of<code>Class</code>,<code>java.lang.invoke.MethodHandle</code>,<code>java.lang.invoke.MethodType</code>, and<code>String</code>.</p></li>
</ul>

<p>During resolution of the symbolic reference to the method handle in the call site specifier, or resolution of the symbolic reference to the method type for the method descriptor in the call site specifier, or resolution of a symbolic reference to any static argument, any of the exceptions pertaining to method type or method handle resolution may be thrown (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.5">§5.4.3.5</a>).</p>

<h3 id="5-4-4-access-control">5.4.4. Access Control</h3>

<p>A class or interfaceCis_accessible_to a class or interfaceDif and only if either of the following is true:</p>

<ul>
<li><p>Cis<code>public</code>.</p></li>

<li><p>CandDare members of the same run-time package (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.3">§5.3</a>).</p></li>
</ul>

<p>A field or methodRis accessible to a class or interfaceDif and only if any of the following is true:</p>

<ul>
<li><p>Ris<code>public</code>.</p></li>

<li><p>Ris<code>protected</code>and is declared in a classC, andDis either a subclass ofCorCitself. Furthermore, ifRis not<code>static</code>, then the symbolic reference toRmust contain a symbolic reference to a classT, such thatTis either a subclass ofD, a superclass ofD, orDitself.</p></li>

<li><p>Ris either<code>protected</code>or has default access (that is, neither<code>public</code>nor<code>protected</code>nor<code>private</code>), and is declared by a class in the same run-time package asD.</p></li>

<li><p>Ris<code>private</code>and is declared inD.</p></li>
</ul>

<p>This discussion of access control omits a related restriction on the target of a<code>protected</code>field access or method invocation (the target must be of classDor a subtype ofD). That requirement is checked as part of the verification process (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.10.1.8">§4.10.1.8</a>); it is not part of link-time access control.</p>

<h3 id="5-4-5-overriding">5.4.5. Overriding</h3>

<p>An instance method<code>mC</code>declared in classCoverrides another instance method<code>mA</code>declared in classAiff either<code>mC</code>is the same as<code>mA</code>, or all of the following are true:</p>

<ul>
<li><p>Cis a subclass ofA.</p></li>

<li><p><code>mC</code>has the same name and descriptor as<code>mA</code>.</p></li>

<li><p><code>mC</code>is not marked<code>ACC_PRIVATE</code>.</p></li>

<li><p>One of the following is true:</p>

<ul>
<li><p><code>mA</code>is marked<code>ACC_PUBLIC</code>; or is marked<code>ACC_PROTECTED</code>; or is marked neither<code>ACC_PUBLIC</code>nor<code>ACC_PROTECTED</code>nor<code>ACC_PRIVATE</code>andAbelongs to the same run-time package asC.</p></li>

<li><p><code>mC</code>overrides a method<code>m'</code>(<code>m'</code>distinct from<code>mC</code>and<code>mA</code>) such that<code>m'</code>overrides<code>mA</code>.</p></li>
</ul></li>
</ul>

<h2 id="5-5-initialization">5.5. Initialization</h2>

<p>_Initialization_of a class or interface consists of executing its class or interface initialization method (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.9">§2.9</a>).</p>

<p>A class or interfaceCmay be initialized only as a result of:</p>

<ul>
<li>The execution of any one of the Java Virtual Machine instructions<em>new</em>,<em>getstatic</em>,<em>putstatic</em>, or_invokestatic_that referencesC(<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.new">§<em>new</em></a>,<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.getstatic">§<em>getstatic</em></a>,<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.putstatic">§<em>putstatic</em></a>,<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.invokestatic">§<em>invokestatic</em></a>). These instructions reference a class or interface directly or indirectly through either a field reference or a method reference.</li>
</ul>

<p>Upon execution of a_new_instruction, the referenced class is initialized if it has not been initialized already.</p>

<p>Upon execution of a<em>getstatic</em>,<em>putstatic</em>, or_invokestatic_instruction, the class or interface that declared the resolved field or method is initialized if it has not been initialized already.</p>

<ul>
<li>The first invocation of a<code>java.lang.invoke.MethodHandle</code>instance which was the result of method handle resolution (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.5">§5.4.3.5</a>) for a method handle of kind 2 (<code>REF_getStatic</code>), 4 (<code>REF_putStatic</code>), 6 (<code>REF_invokeStatic</code>), or 8 (<code>REF_newInvokeSpecial</code>).</li>
</ul>

<p>This implies that the class of a bootstrap method is initialized when the bootstrap method is invoked for an_invokedynamic_instruction (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.invokedynamic">§<em>invokedynamic</em></a>), as part of the continuing resolution of the call site specifier.</p>

<ul>
<li><p>Invocation of certain reflective methods in the class library (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.12">§2.12</a>), for example, in class<code>Class</code>or in package<code>java.lang.reflect</code>.</p></li>

<li><p>IfCis a class, the initialization of one of its subclasses.</p></li>

<li><p>IfCis an interface that declares a non-<code>abstract</code>, non-<code>static</code>method, the initialization of a class that implementsCdirectly or indirectly.</p></li>

<li><p>IfCis a class, its designation as the initial class at Java Virtual Machine startup (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.2">§5.2</a>).</p></li>
</ul>

<p>Prior to initialization, a class or interface must be linked, that is, verified, prepared, and optionally resolved.</p>

<p>Because the Java Virtual Machine is multithreaded, initialization of a class or interface requires careful synchronization, since some other thread may be trying to initialize the same class or interface at the same time. There is also the possibility that initialization of a class or interface may be requested recursively as part of the initialization of that class or interface. The implementation of the Java Virtual Machine is responsible for taking care of synchronization and recursive initialization by using the following procedure. It assumes that the<code>Class</code>object has already been verified and prepared, and that the<code>Class</code>object contains state that indicates one of four situations:</p>

<ul>
<li><p>This<code>Class</code>object is verified and prepared but not initialized.</p></li>

<li><p>This<code>Class</code>object is being initialized by some particular thread.</p></li>

<li><p>This<code>Class</code>object is fully initialized and ready for use.</p></li>

<li><p>This<code>Class</code>object is in an erroneous state, perhaps because initialization was attempted and failed.</p></li>
</ul>

<p>For each class or interfaceC, there is a unique initialization lock<code>LC</code>. The mapping fromCto<code>LC</code>is left to the discretion of the Java Virtual Machine implementation. For example,<code>LC</code>could be the<code>Class</code>object forC, or the monitor associated with that<code>Class</code>object. The procedure for initializingCis then as follows:</p>

<ol>
<li><p>Synchronize on the initialization lock,<code>LC</code>, forC. This involves waiting until the current thread can acquire<code>LC</code>.</p></li>

<li><p>If the<code>Class</code>object forCindicates that initialization is in progress forCby some other thread, then release<code>LC</code>and block the current thread until informed that the in-progress initialization has completed, at which time repeat this procedure.</p></li>
</ol>

<p>Thread interrupt status is unaffected by execution of the initialization procedure.</p>

<ol>
<li><p>If the<code>Class</code>object forCindicates that initialization is in progress forCby the current thread, then this must be a recursive request for initialization. Release<code>LC</code>and complete normally.</p></li>

<li><p>If the<code>Class</code>object forCindicates thatChas already been initialized, then no further action is required. Release<code>LC</code>and complete normally.</p></li>

<li><p>If the<code>Class</code>object forCis in an erroneous state, then initialization is not possible. Release<code>LC</code>and throw a<code>NoClassDefFoundError</code>.</p></li>

<li><p>Otherwise, record the fact that initialization of the<code>Class</code>object forCis in progress by the current thread, and release<code>LC</code>.</p></li>
</ol>

<p>Then, initialize each<code>finalstatic</code>field ofCwith the constant value in its<code>ConstantValue</code>attribute (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.2">§4.7.2</a>), in the order the fields appear in the<code>ClassFile</code>structure.</p>

<ol>
<li>Next, ifCis a class rather than an interface, and its superclass has not yet been initialized, then letSCbe its superclass and letSI1, &hellip;,SInbe all superinterfaces ofC(whether direct or indirect) that declare at least one non-<code>abstract</code>, non-<code>static</code>method. The order of superinterfaces is given by a recursive enumeration over the superinterface hierarchy of each interface directly implemented byC. For each interfaceIdirectly implemented byC(in the order of the<code>interfaces</code>array ofC), the enumeration recurs onI&rsquo;s superinterfaces (in the order of the<code>interfaces</code>array ofI) before returningI.</li>
</ol>

<p>For eachSin the list [SC,SI1, &hellip;,SIn], recursively perform this entire procedure forS. If necessary, verify and prepareSfirst.</p>

<p>If the initialization ofScompletes abruptly because of a thrown exception, then acquire<code>LC</code>, label the<code>Class</code>object forCas erroneous, notify all waiting threads, release<code>LC</code>, and complete abruptly, throwing the same exception that resulted from initializingSC.</p>

<ol>
<li><p>Next, determine whether assertions are enabled forCby querying its defining class loader.</p></li>

<li><p>Next, execute the class or interface initialization method ofC.</p></li>

<li><p>If the execution of the class or interface initialization method completes normally, then acquire<code>LC</code>, label the<code>Class</code>object forCas fully initialized, notify all waiting threads, release<code>LC</code>, and complete this procedure normally.</p></li>

<li><p>Otherwise, the class or interface initialization method must have completed abruptly by throwing some exceptionE. If the class ofEis not<code>Error</code>or one of its subclasses, then create a new instance of the class<code>ExceptionInInitializerError</code>withEas the argument, and use this object in place ofEin the following step. If a new instance of<code>ExceptionInInitializerError</code>cannot be created because an<code>OutOfMemoryError</code>occurs, then use an<code>OutOfMemoryError</code>object in place ofEin the following step.</p></li>

<li><p>Acquire<code>LC</code>, label the<code>Class</code>object forCas erroneous, notify all waiting threads, release<code>LC</code>, and complete this procedure abruptly with reasonEor its replacement as determined in the previous step.</p></li>
</ol>

<p>A Java Virtual Machine implementation may optimize this procedure by eliding the lock acquisition in step 1 (and release in step <sup>4</sup>&frasl;<sub>5</sub>) when it can determine that the initialization of the class has already completed, provided that, in terms of the Java memory model, all_happens-before_orderings (JLS §17.4.5) that would exist if the lock were acquired, still exist when the optimization is performed.</p>

<h2 id="5-6-binding-native-method-implementations">5.6. Binding Native Method Implementations</h2>

<p>_Binding_is the process by which a function written in a language other than the Java programming language and implementing a<code>native</code>method is integrated into the Java Virtual Machine so that it can be executed. Although this process is traditionally referred to as linking, the term binding is used in the specification to avoid confusion with linking of classes or interfaces by the Java Virtual Machine.</p>

<h2 id="5-7-java-virtual-machine-exit">5.7. Java Virtual Machine Exit</h2>

<p>The Java Virtual Machine exits when some thread invokes the<code>exit</code>method of class<code>Runtime</code>or class<code>System</code>, or the<code>halt</code>method of class<code>Runtime</code>, and the<code>exit</code>or<code>halt</code>operation is permitted by the security manager.</p>

<p>In addition, the JNI (Java Native Interface) Specification describes termination of the Java Virtual Machine when the JNI Invocation API is used to load and unload the Java Virtual Machine.</p>

    </div>
    <footer class="post-footer">
     

     <div class="post-nav">
    <div class="post-nav-next post-nav-item">
    
        <a href="http://yangchao.me/book/annotated-jvm-specification/the-structure-of-java-virtual-machine/" rel="next" title="">
        <i class="fa fa-chevron-left"></i> 
        </a>
    
    </div>

    <div class="post-nav-prev post-nav-item">
    
        <a href="http://yangchao.me/book/annotated-jvm-specification/chapter1/" rel="prev" title="">
         <i class="fa fa-chevron-right"></i>
        </a>
    
    </div>
</div>
      
     <div class="post-nav">
<div style="border: 1px dashed #e0e0e0; padding: 10px 10px 10px 10px; background-color: #fffeee; background-repeat: no-repeat; background-attachment: scroll; background-position: 1% 50%; -moz-background-size: auto auto; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">
    <div style="float:left;margin-top:0px;">
    <img src="http://yangchao.me/images/qrcode/qrcode_8cm.jpg" width="129px" height="129px"/>
    <div style="text-align:center;">微信扫一扫交流</div>
    </div>
    <div>
        <p style="margin-top:0px;">
            标题：
        <br />作者：<a target="_blank" href="http://yangchao.me/">Chao</a>
        <br />关注：richdyang（CHAO）
        <br />声明：自由转载-非商用-非衍生-保持署名（创作共享3.0许可证）
        </p>
    </div>
</div>
<div class="clear"></div>
</div>
     
     
     




    </footer>
  </article>
</section>

          </div>
        </div>
        <div class="sidebar-toggle">
  <div class="sidebar-toggle-line-wrap">
    <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
  </div>
</div>
<aside id="sidebar" class="sidebar">
  <div class="sidebar-inner">

    <section class="site-overview sidebar-panel  sidebar-panel-active ">
      <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
        src="http://yangchao.me/img/author.jpg"
        alt="Chao" />
    <p class="site-author-name" itemprop="name">Chao</p>
    <p class="site-description motion-element" itemprop="description"> 
        Programmer &amp; Life explorer</p>
</div>
      <nav class="site-state motion-element">
    <div class="site-state-item site-state-posts">
      <a href="http://yangchao.me/post/">
        <span class="site-state-item-count">139</span>
        <span class="site-state-item-name">Blogs</span>
      </a>
    </div>
    <div class="site-state-item site-state-categories">    
        <a href="http://yangchao.me/categories/">      
         
        <span class="site-state-item-count">49</span>
        
        <span class="site-state-item-name">Categories</span>
        
        </a>
    </div>

    <div class="site-state-item site-state-tags">
        <a href="http://yangchao.me/tags/">
         
        <span class="site-state-item-count">20</span>
        
        <span class="site-state-item-name">Tags</span>
        </a>
    </div>
</nav>
      
      
<div class="links-of-author motion-element">
    
        <span class="links-of-author-item">
        <a href="https://github.com/richdyang" target="_blank" title="GitHub">
            <i class="fa fa-fw fa-github"></i>
            GitHub
        </a>
        </span>
    
        <span class="links-of-author-item">
        <a href="https://linkedin.com/in/richdyang" target="_blank" title="Linkedin">
            <i class="fa fa-fw fa-linkedin"></i>
            Linkedin
        </a>
        </span>
    
</div>

      
      <div class="links-of-blogroll motion-element inline">
<script type="text/javascript" src="//rf.revolvermaps.com/0/0/8.js?i=5b4f2ucxar6&amp;m=0&amp;s=220&amp;c=ff0000&amp;cr1=ffffff&amp;f=arial&amp;l=33&amp;bv=35" async="async"></script>
</div>

    </section>
    
  </div>
</aside>

      </div>
    </main>
   
    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  <span itemprop="copyrightYear">  &copy; 
  2009 - 2018</span>
  <span class="with-love"><i class="fa fa-heart"></i></span>
  <span class="author" itemprop="copyrightHolder">Chao Yang</span>
</div>
<div class="powered-by">
  Powered by - <a class="theme-link" href="http://gohugo.io" target="_blank" title="hugo" >Hugo v0.30.2</a>
</div>
<div class="theme-info">
  Theme by - <a class="theme-link" href="https://github.com/xtfly/hugo-theme-next" target="_blank"> NexT
  </a>
</div>


      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "//hm.baidu.com/hm.js?0b07433b4ab8d587dae7d34e71973839";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
    })();
</script>
<script type="text/javascript" src="http://tajs.qq.com/stats?sId=58416275" charset="UTF-8"></script> 
<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
<script type="text/javascript" src="http://yangchao.me/js/vendor/jquery/index.js?v=2.1.3"></script>
<script type="text/javascript" src="http://yangchao.me/js/vendor/fastclick/lib/fastclick.min.js?v=1.0.6"></script> 
<script type="text/javascript" src="http://yangchao.me/js/vendor/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
<script type="text/javascript" src="http://yangchao.me/js/vendor/velocity/velocity.min.js?v=1.2.1"></script>
<script type="text/javascript" src="http://yangchao.me/js/vendor/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="http://yangchao.me/js/vendor/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>

<script src="http://yangchao.me/js/vendor/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>

<script type="text/javascript" src="http://yangchao.me/js/utils.js"></script>
<script type="text/javascript" src="http://yangchao.me/js/motion.js"></script>
<script type="text/javascript" src="http://yangchao.me/js/affix.js"></script>
<script type="text/javascript" src="http://yangchao.me/js/schemes/pisces.js"></script>

<script type="text/javascript" src="http://yangchao.me/js/scrollspy.js"></script>
<script type="text/javascript" src="http://yangchao.me/js/post-details.js"></script>
<script type="text/javascript" src="http://yangchao.me/js/toc.js"></script>

<script type="text/javascript" src="http://yangchao.me/js/bootstrap.js"></script>

<script type="text/javascript" src="http://yangchao.me/js/search.js"></script>
</body>
</html>