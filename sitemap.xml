<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<search>
    
     <entry>
        <title>CSS in Depth - Master the box model</title>
        <url>http://yangchao.me/post/css-in-depth-master-the-box-model/</url>
        <categories>
          <category>CSS</category>
        </categories>
        <tags>
          <tag>CSS</tag><tag>Notes</tag>
        </tags>
        <content type="html">  default box model It includes 3 boxes:
 content box padding box border box  Margins don&amp;rsquo;t belong to these boxes.
difficulties with element width By default, width and height is for the content box. So it is hard to align two columns sometimes.
To avoid magic number when layout, a solution is use the calc() function to reduce the width by exactly that much.
adjusting the box model By setting box-sizing: border-box, the box model is adjusted. universal fix for border-box sizing *, ::before, ::after { box-sizing: border-box; } More robust fix when using 3rd-party libraries.
:root { box-sizing: border-box; } *, ::before, ::after { box-sizing: inherit; } adding a gutter between columns A easy way is to add a percentage margin. But the gutter&amp;rsquo;s width is based on the outer container&amp;rsquo;s width. An em-based gutter is preferred: use calc() function.
.sidebar { width: calc(30% - 1.5em); margin-left: 1.5em; } difficulties with element height Typically, it is best to avoid setting explicit height, because normal document flow is designed to work with a constrained width and an unlimited height. Contents fill the width of the viewport and then line wrap as necessary. Because of this, the height of a container is organically determined by its contents, not by the container itself.
 height property don&amp;rsquo;t support percentage value. Never height: 100%.
 When you explicitly set an element height, you run the risk of its contents overflowing the container.
overflow, overflow-x, overflow-y
 visible hidden scroll auto   alternatives to percentage-based heights Specifying height using a percentage is problematic. For percentage-based&amp;rdquo; heights to work, the parent must have an explicitly defined height.
Columns of equal height
display: table rescues this difficulty.
.container { display: table; width: 100%; } .main { display: table-cell; width: 70%; background-color: #fff; border-radius: .5em; } .sidebar { display: table-cell; width: 30%; margin-left: 1.5em; padding: 1.5em; background-color: #fff; border-radius: .5em; }</content>
    </entry>
    
     <entry>
        <title>CSS in Depth - Cascade, specificity and inheritance</title>
        <url>http://yangchao.me/post/css-in-depth-cascade-specificity-and-inheritance/</url>
        <categories>
          <category>CSS</category>
        </categories>
        <tags>
          <tag>CSS</tag><tag>Notes</tag>
        </tags>
        <content type="html">  terminology A declaration includes a property and a value: color: black; A ruleset includes a selector and a declaration block which contains a group of declarations.
body { color: black; font-family: Helvetcia; } cascade The cascade is the name for this set of rules. It determines how conflicts are resolved, and it’s a fundamental part of how the language works.
When declarations conflict, the cascade considers three things to resolve the difference:
 Stylesheet origin—Where the styles come from. Your styles are applied in conjunction with the browser’s default styles. Selector specificity—Which selectors take precedence over which. Source order — Order in which styles are declared in the stylesheet.  origin There are different types, or origins, of stylesheets. Yours are called author styles; there are also user agent styles, which are the browser’s default styles. Your styles will always override the user agent styles because the origins are different.
 !important is used to raise a declaration to a higher-priority origin.
 specificity inline style Inline styles have no selector because they are applied directly to the element they target. Inline declarations will override any declarations applied from your stylesheet or a &amp;lt;style&amp;gt; tag. To override inline declarations in your stylesheet, you’ll need to add an !important to the declaration, shifting it into a higher-priority origin.
selector specificity The exact rules of selector specificity are:
 If a selector has more IDs, it wins (that is, it’s more specific). If that results in a tie, the selector with the most classes wins. If that results in a tie, the selector with the most tag names wins.   Pseudo-class selectors (e.g, :hover) and attribute selectors (e.g, [type=&amp;quot;input&amp;quot;]) each have the same specificity as a class selector. The universal selector (*) and combinators (&amp;gt;, &#43;, ~) have no effect on specificity.
 Pitfalls: Many times developers write selectors using IDs, without realizing this creates a higher specificity, one that is hard to override later. If you need to override a style applied using an ID, you have to use another ID.
source order If the origin and the specificity are the same, then the declaration that appears later in the stylesheet — or appears in a stylesheet included later on the page — takes precedence.
inheritance If an element has no cascaded value for a given property, it may inherit one from an ancestor element.
Not all properties are inherited, however.
Primarily properties pertaining to text:
 color font, font-family, font-size, font-weight, font-variant, font-style line-height, letter-spacing text-align, text-indent, text-transform white-space, word-spacing  List properties:
 list-style, list-style-type, list-style-position, list-style-image  Table border properties:
 border-collapse, border-spacing  special values Two special values which can be applied to any property: inherit and initial.
inherit  use inheritance to take place when a cascaded value is preventing it. force inheritance of a property not normally inherited, such as border or padding.  initial  reset a property to its default value to undo styles   initial vs. auto: Sometimes, you can use the value auto do the same thing with initial, that&amp;rsquo;s because some properties&amp;rsquo; default value is auto. But auto isn&amp;rsquo;t the default value for all properties.
display: initial always reset to display: inline regardless of what type of element. Because initial only resets the default value of property, NOT the element.
 shorthand properties Most shorthand properties let you omit certain values and only specify the bits you’re concerned with. It’s important to know, however, that doing this still sets the omitted values; they’ll be set implicitly to their initial value.
order of shorthand values
 top, right, bottom, left: margin, padding horizontal, vertical: background-position, box-shadow, text-shadow  </content>
    </entry>
    
     <entry>
        <title>Javascript testing frameworks</title>
        <url>http://yangchao.me/post/javascript-testing-frameworks/</url>
        <categories>
          <category>Javascript</category>
        </categories>
        <tags>
          <tag>Javascript</tag><tag>Test</tag>
        </tags>
        <content type="html">  I wrote front-end testing code less frequently. I heard a lot of frameworks used by my colleagues, like Karma, Jasmine, Chai, Mocha, Jest. you name it.
Why so much complex? In the Java ecosystem, we have JUnit for the test runner, it provides test suites and all kinds of assert expressions. If we need to mock some dependencies, we use Mokito or others like. That&amp;rsquo;s enough.
So when it comes to Javascript, I am really confused with so many frameworks/libraries. What is worse is I don&amp;rsquo;t know their roles only from their name.
So the following I give a one sentence introduction for each of them.
 Karma: spectacular test runner for JavaScript that allows you to execute JavaScript code in multiple real browsers. Chai: a BDD / TDD assertion library for node and the browser Jasmine: a a Behaviour Driven Development testing framework for JavaScript Mocha: simple, flexible, fun javascript test framework Jest: another javascript test framework developed by Facebook  So obviously, Jasmine/Mocha/Jest can be of the similar role with some overlays.
Look at them a bit more Jasmine Jasmine provides with everything you are expected to need for your tests: a running environment, structure, reporting, assertion, and mocking tools. Has widespread Angular support.
One word: ready-to-go
Mocha Mocha is usually used with third party assertion, mocking, and spying tools (usually Enzyme and Chai).
One word: flexible and extensible
Jest Like Jasmine, everything is there.
One word: performance
See more in A complete guide to testing Javascript in 2017
</content>
    </entry>
    
     <entry>
        <title>Build OpenCV 3.3 Android SDK on Mac OSX</title>
        <url>http://yangchao.me/post/build-opencv-android-sdk/</url>
        <categories>
          <category>IoT</category>
        </categories>
        <tags>
          <tag>IoT</tag><tag>CV</tag>
        </tags>
        <content type="html">  By default, the official OpenCV Android SDK doesn&amp;rsquo;t contain the contrib libraries, like Aruco.
prerequisite  NDK r10e  https://dl.google.com/android/repository/android-ndk-r10e-darwin-x86_64.zip
 Android SDK  Note: please degrade the Android SDK tools version, 25.2.4 is fine for me http://dl-ssl.google.com/android/repository/tools_r25.2.5-macosx.zip Go to ~/Library/Android/sdk, rename tools to tools.bak, then unzip the tools_rxxx.zip to sdk/tools directory. Why? because otherwise, android command has been deprecated)
 opencv 3.3.1  git clone https://github.com/opencv/opencv.git
 opencv_contrib  git clone https://github.com/opencv/opencv.git
 CMake  brew install cmake ninja ant
How to do it Assue the following is my unziped directories in my home.
$ ls opencv opencv_contrib android-ndk-r10e  Then run these commands:
$ cd ~/opencv/ &amp;amp; mkdir build $ cd ~/opencv/platforms/android $ ./build_sdk.py --ndk_path ~/android-ndk-r10e --sdk_path ~/Library/Android/sdk --extra_modules_path ~/opencv_contrib/modules ~/opencv/build ~/opencv Go to ~/opencv/build/sdk, you can see all are there.
That&amp;rsquo;s it. Bingo!
</content>
    </entry>
    
     <entry>
        <title>A developer learns design</title>
        <url>http://yangchao.me/post/a-developer-leanrns-design/</url>
        <categories>
          <category>Design</category>
        </categories>
        <tags>
          <tag>Design</tag><tag>Affinity</tag>
        </tags>
        <content type="html">  I do not forget the time when I crafted a Flash animation in my university and I also had a dream to design a 3D game on my own.
So now I have some time to realize my dream and start a learning plan. I bought Affinity Photo and Affinity Designer which are great applications and I am pretty obsessed with these two.
I also learn how to program with Unity and 3D model with Maya. All these activities are directed by my interest. I have never expect me to be a creative professional some day, but a hobbyist is satisfactory enough for me.
The following is the video tutorials I found:
Affinity Designer Vimeo  Official Tutorials Video Tutorials  Udemy  Affinity Designer Essential Training (Lynda) Affinity Designer for UX Design (Lynda) Affinity Designer For Beginners How To Quickly Get Started with Affinity Designer Vector Logo Design in Affinity Designer Affinity Designer: The Complete Guide to Creating Vector Art Affinity Designer for beginners Affinity Designer - making seamless patterns  Tusplus  Affinity Designer category  Skillshare Affinity Designer
Affinity Photo Vimeo  Official Tutorials Video Tutorials  Udemy  Affinity Photo Essential Training (Lynda) Affinity Photo: Basic Portrait Retouching (Lynda) Affinity Photo: Raw Image Development Affinity Photo 101: Master The Develop Persona Affinity Photo: Solid Foundations Affinity Photo: The Little Box of Tricks Affinity Photo: Five Steps to Better Photos  </content>
    </entry>
    
     <entry>
        <title>Kotlin Pitfalls</title>
        <url>http://yangchao.me/post/kotlin-pitfalls/</url>
        <categories>
          <category>Tutorial</category>
        </categories>
        <tags>
          <tag>Kotlin</tag>
        </tags>
        <content type="html">  Type system val list: List&amp;lt;String&amp;gt; = java.util.ArrayList() Why does it work? java.util.ArrayList is not a subclass of kotlin.List, and kotlin.List is actually read-only.
Because in bytecode level, kotlin.List is just java.util.List! I decompile the class Kotlin compiled:
import java.util.ArrayList; import java.util.List; import kotlin.Metadata; @Metadata(mv={1, 1, 6}, bv={1, 0, 1}, k=2, d1={&amp;#34;\000\b\n\000\n\002\020\002\n\000\032\006\020\000\032\0020\001��\006\002&amp;#34;}, d2={&amp;#34;a&amp;#34;, &amp;#34;&amp;#34;, &amp;#34;kotlin_demo&amp;#34;}) public final class _1Kt { public static final void a() { List list = (List)new ArrayList(); } } You can think as if java.util.ArrayList implements kotlin.List
operator in in is an operator in Kotlin. But it means different things in different context.
in as expression When you use in as an expression, it is evaluated as a boolean value: it means contains. So unsurprising, you just need to implement a contains() method in your class.
class MyInClass { operator fun contains(bit: Int): Boolean { return true } } fun main(args: Array&amp;lt;String&amp;gt;) { val mic = MyInClass() println(1 in mic) // always print true } in within a for-loop When you use in in a for-loop, it means: iteration. So you need to implement a iterator() method.
Let&amp;rsquo;s extends MyInClass:
class MyInClass { operator fun contains(bit: Int): Boolean { return true } operator fun iterator(): Iterator&amp;lt;Int&amp;gt; { return MyIterator() } class MyIterator: Iterator&amp;lt;Int&amp;gt; { int i: Int = 0 override fun hasNext(): Boolean { return if(i &amp;lt; 10) true else false } override fun next(): Int { return i&#43;&#43; } } } fun main(args: Array&amp;lt;String&amp;gt;) { val mic = MyInClass() println(1 in mic) // always print true  for(b in mic) { // print 1, 2, 3, 4, ...9  println(b) } } Generics Kotlin&amp;rsquo;s Generic is as complex as Java&amp;rsquo;s. It introduces in out type parameters and declaration-site vs. use-site..
val map = mutableMapOf&amp;lt;Int,Int&amp;gt;() map[1] = 1 map[1] &#43; 1 // compiler complains here Although we declare the value of map is Int which means it cannot be null. But map.get(..) return Int? which can be null. Wield?!
val map = mutableMapOf&amp;lt;Int,Int?&amp;gt;() println(map[1]) println(1 in map.keys) map[1] = null println(map[1]) println(1 in map.keys) So map.get(..) cannot differentiate if the key doesn&amp;rsquo;t exist or just its value is set as null. The best way to differentiate is to use key in map.keys.
</content>
    </entry>
    
     <entry>
        <title>pseudo-random number &amp; shuffle</title>
        <url>http://yangchao.me/post/pseudo-random-number-shuffle/</url>
        <categories>
          
        </categories>
        <tags>
          
        </tags>
        <content type="html">  Pseudo random number Given a seed, and you will always get the next number, which is predictable. So that is reason why it is called pseudo random.
A simple algorithm is Linear congruential generator.
 next random = (a * random &#43; c) mod 2^32  The initial random is seed.
Java implementation In next(bits) method:
nextseed = (oldseed * multiplier &#43; addend) &amp;amp; mask; here, multiplier is 0x5DEECE66DL, addend is 0xBL, mask is (1L &amp;lt;&amp;lt; 48) - 1.
Shuffle Shuffling is a procedure used to randomize a deck of playing cards to provide an element of chance in card games.
Fisher–Yates shuffle
implementation For the unshuffled subarray, always select a random element swapping with the last one.
public void shuffle(int[] arr) { for(int len = arr.length; len &amp;gt; 1; --len) { int index = new Random().nextInt(len); int temp = arr[index]; arr[index] = arr[len-1]; arr[len-1] = temp; } } Please refer to Collections.shuffle(..). This algorithm has O(N) time complexity.
Practice generate a 4-digit PIN code with no consecutive digits being the same 1232 is legal, but 1233 is illegal.
public static void main(String[] args) { List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(); // generate all PINs 	for(int i=0; i&amp;lt;= 9999; &#43;&#43;i) { String pin = padding(i); if(!pin.matches(&amp;#34;\\d*(\\d)\\1\\d*&amp;#34;)) { list.add(pin); } } // shuffle  Collections.shuffle(list); // each time, select the last PIN  int last = list.size() - 1; String pin = list.get(last); list.remove(last); System.out.println(pin); } private static String padding(int i) { int remaining = i; int d4 = remaining / 1000; remaining %= 1000; int d3 = remaining / 100; remaining %= 100; int d2 = remaining / 10; remaining %= 10; int d1 = remaining; return &amp;#34;&amp;#34; &#43; d4 &#43; d3 &#43; d2 &#43; d1; }</content>
    </entry>
    
     <entry>
        <title>Swift 3.0 for a Java or ES6/TypeScript developer</title>
        <url>http://yangchao.me/post/swift-3-for-a-java-or-es6-typescript-developer/</url>
        <categories>
          
        </categories>
        <tags>
          
        </tags>
        <content type="html">  Basic Operators Assignment Operator let b = 10 // constant var a = 5	// variable a = b let is not the same as that in ES6. It is more or like final in Java. It means the variable (value or reference) cannot be changed once initialization.
But let in Swift has stronger semantics, which enable immutability or constant. It means not only the reference cannot be mutable but also the object it refers cannot be mutable.
// swift let arr = [1, 2, 3] arr[0] = 3 // error// java final int[] arr = [1, 2, 3] arr[0] = 3 // ok multiple assignment with tuple:
let (x, y) = (1, 2) == vs. ===, != vs. !== == is the equal operator, while === is identity operator which is used to test wthether two object references both refer to the same object instance.
tuples are compared from left to right.
(1, &amp;#34;zebra&amp;#34;) &amp;lt; (2, &amp;#34;apple) (3, &amp;#34;apple&amp;#34;) &amp;lt; (3, &amp;#34;bird&amp;#34;) Nil-Colaescing Operator var a : String? = &amp;#34;aaaa&amp;#34; var b = a ?? b a ?? b is shorthand for a != nil ? a! : b
Range Operators  closed range operator: a...b half-open range operator: a..&amp;lt;b  Strings and Characters Every string is composed of encoding-indepent Unicode characters.
String type is a value type. When you pass a String to a function or assign to a constant/variable, its value is copied.
 Actually, it seems to have the similar attribute of immutability as that in Java.
 Character Character can be created from a single-character string literal.
let ch : Character = &amp;quot;1&amp;quot;
String Interpolation String interpolation in Swift is different from that in Javascript.
let a = 3 let message = &amp;#34;the number is: \(a), its double is: \(Double(a) * 2)&amp;#34; In ES6:
let a = 3 let message = `the number is: ${a}, its double is: ${a*2}` Unicode  Unicode code point is a number for every character in Unicode. Unicode scalar is any Unicode code point in the range U&#43;0000 ~ U&#43;D7FF or U&#43;E000 ~ U&#43;10FFFF. The range in U&#43;D800 ~ U&#43;DFFF is for surrogate pair code points.
  escaped special charaters: \0, \\, \t, \n, \r, \&amp;quot;, \&#39; .. Unicode scalar: \u{00FF} &amp;hellip;  The unicode literal is different from that in Java and Javascript. In Java/Javascript, it is like \u00FF without brackets.
Swift Character is not only single Unicode character, it can combine one or more Unicode scalars. Actually, every instance of Swift&amp;rsquo;s Character represents a single extended grapheme cluster.
let eAcute: Character = &amp;#34;\u{E9}&amp;#34; let combinedEacute: Character = &amp;#34;\u{65}\u{301}&amp;#34; // e followed by ́ // both are rednered as é  Using extended grapheme clusters makes Swift&amp;rsquo;s Character is so much different from characters in other programming languages.
 Accessing and Mofifying a String Due to the representation of Swift Character, the access and modification ways are special accordingly.
Each String value has an associated index type, String.Index.
String has startIndex and endIndex properties, which is the half-open range with endIndex exclusive.
let greeting = &amp;#34;Hello world!&amp;#34; greeting[greeting.startIndex] // H var index = greeting.index(before: greeting.endIndex) greeting[index] // ! index = greeting.index(after: greeting.startIndex) greeting[index] // u index = greeting.index(greeting.startIndex, offsetBy: 2) greeting[index] // l Control Flow switch No need to use explict break in each case branch.
But if you want the behaviours when missing break in Java, you can use the fallthrough keyword.
 Interval Matching  let number = 62 let desc : String switch number { case 0: desc = &amp;#34;no&amp;#34; case 1..&amp;lt;5: desc = &amp;#34;a few&amp;#34; case 5..&amp;lt;12: desc = &amp;#34;several&amp;#34; default: desc = &amp;#34;many&amp;#34; }  compound cases  let someCharacter: Character = &amp;#34;e&amp;#34; switch someCharacter { case &amp;#34;a&amp;#34;, &amp;#34;e&amp;#34;, &amp;#34;i&amp;#34;, &amp;#34;o&amp;#34;, &amp;#34;u&amp;#34;: print(&amp;#34;\(someCharacter)is a vowel&amp;#34;) case &amp;#34;b&amp;#34;, &amp;#34;c&amp;#34;, &amp;#34;d&amp;#34;, &amp;#34;f&amp;#34;, &amp;#34;g&amp;#34;, &amp;#34;h&amp;#34;, &amp;#34;j&amp;#34;, &amp;#34;k&amp;#34;, &amp;#34;l&amp;#34;, &amp;#34;m&amp;#34;, &amp;#34;n&amp;#34;, &amp;#34;p&amp;#34;, &amp;#34;q&amp;#34;, &amp;#34;r&amp;#34;, &amp;#34;s&amp;#34;, &amp;#34;t&amp;#34;, &amp;#34;v&amp;#34;, &amp;#34;w&amp;#34;, &amp;#34;x&amp;#34;, &amp;#34;y&amp;#34;, &amp;#34;z&amp;#34;: print(&amp;#34;\(someCharacter)is a consonant&amp;#34;) default: print(&amp;#34;\(someCharacter)is not a vowel or a consonant&amp;#34;) }  test multiple values with tuple  let somePoint = (1, 1) switch somePoint { case (0, 0): print(&amp;#34;(0, 0) is at the origin&amp;#34;) case (_, 0): print(&amp;#34;(\(somePoint.0), 0) is on the x-axis&amp;#34;) case (0, _): print(&amp;#34;(0, \(somePoint.1)) is on the y-axis&amp;#34;) case (-2...2, -2...2): print(&amp;#34;(\(somePoint.0), \(somePoint.1)) is inside the box&amp;#34;) default: print(&amp;#34;(\(somePoint.0), \(somePoint.1)) is outside of the box&amp;#34;) }”  value binding  let anotherPoint = (2, 0) switch anotherPoint { case (let x, 0): print(&amp;#34;on the x-axis with an x value of \(x)&amp;#34;) case (0, let y): print(&amp;#34;on the y-axis with a y value of \(y)&amp;#34;) case let (x, y): print(&amp;#34;somewhere else at (\(x), \(y))&amp;#34;) }  where  let yetAnotherPoint = (1, -1) switch yetAnotherPoint { case let (x, y) where x == y: print(&amp;#34;(\(x), \(y)) is on the line x == y&amp;#34;) case let (x, y) where x == -y: print(&amp;#34;(\(x), \(y)) is on the line x == -y&amp;#34;) case let (x, y): print(&amp;#34;(\(x), \(y)) is just some arbitrary point&amp;#34;) }</content>
    </entry>
    
     <entry>
        <title>ElementRef vs. ViewContainerRef vs. TemplateRef</title>
        <url>http://yangchao.me/post/elementref-viewcontainerref-templateref/</url>
        <categories>
          
        </categories>
        <tags>
          
        </tags>
        <content type="html"> In Angular2, there are many *Ref class: ElementRef, ViewContainerRef, TemplateRef.
What do they means?
 Nearly every components (Components, Attribute Directives, Structural Directives) have ViewContainerRef, which is the host of its view.  ViewContainerRef has two important methods: createEmbeddedView(templateRef: TemplateRef&amp;lt;C&amp;gt;, context?: C, index?: number) : EmbeddedViewRef&amp;lt;C&amp;gt; This method is to create a view from a HTML template. createComponent(componentFactory: ComponentFactory&amp;lt;C&amp;gt;, index?: number, injector?: Injector, projectableNodes?: any[][]) : ComponentRef&amp;lt;C&amp;gt; This method is to initialize a component and insert its host view to the view container.
 From ViewContainerRef, we can get its ElementRef (further access its native DOM element). For structural directives, since they are implemented through HTML template element, so it can get a TemplateRef.   ViewContainerRef is a DOM element (container) where I can put your newly component as a sibling to this element. This may be counter-intuitive.
 // Component import {AfterContentInit, Component, ElementRef, ViewContainerRef} from &amp;#39;@angular/core&amp;#39;; @Component({ selector: &amp;#39;app&amp;#39;, template: ` &amp;lt;h1&amp;gt;My App&amp;lt;/h1&amp;gt; &amp;lt;pre style=&amp;#34;background: #eee; padding: 1rem; border-radius: 3px; overflow: auto;&amp;#34;&amp;gt; &amp;lt;code&amp;gt;{{ node }}&amp;lt;/code&amp;gt; &amp;lt;/pre&amp;gt; ` }) export class App implements AfterContentInit { node: string; constructor(private viewContainerRef: ViewContainerRef) { } ngAfterContentInit() { let elementRef = this.viewContainerRef.element; const tmp = document.createElement(&amp;#39;div&amp;#39;); const el = elementRef.nativeElement.cloneNode(true); console.log(elementRef) console.log(this.viewContainerRef) tmp.appendChild(el); this.node = tmp.innerHTML; } }// Attribute Directive import {Directive, ViewContainerRef, ElementRef, Renderer} from &amp;#39;angular2/core&amp;#39;; @Directive({ selector: &amp;#39;[my-outline]&amp;#39;, host: { &amp;#39;(mouseenter)&amp;#39;: &amp;#39;onMouseEnter()&amp;#39;, &amp;#39;(mouseleave)&amp;#39;: &amp;#39;onMouseLeave()&amp;#39; } }) export class MyOutline { constructor(private viewContainerRef:ViewContainerRef, private _element: ElementRef, private _renderer:Renderer) { } onMouseEnter() { this._outlineToggle(true); } onMouseLeave() { this._outlineToggle(false); } private _outlineToggle() { console.log(this.viewContainerRef) this._renderer.setElementStyle(this._element.nativeElement, &amp;#39;border&amp;#39;, &amp;#39;solid red 1px&amp;#39; ); } }// Structural Directive import {Directive, Input} from &amp;#39;angular2/core&amp;#39;; import {TemplateRef, ViewContainerRef} from &amp;#39;angular2/core&amp;#39;; @Directive({ selector: &amp;#39;[repeatMe]&amp;#39; }) export class RepeatMe { constructor( private _templateRef: TemplateRef, private _viewContainer: ViewContainerRef ) {} @Input() set repeatMe(count: int) { for (var i = 0; i &amp;lt; count; i&#43;&#43;) { this._viewContainer.createEmbeddedView(this._templateRef); } } } In Angular2, the View is refered to the template of a component defined in the @Component decorator.
There are another view query docorators in Angualar.
import { Component, ViewChild } from &amp;#39;@angular/core&amp;#39;; import { UserProfile } from &amp;#39;../user-profile&amp;#39;; @Component({ template: &amp;#39;&amp;lt;user-profile (click)=&amp;#34;update()&amp;#34;&amp;gt;&amp;lt;/user-profile&amp;gt;&amp;#39;, }) export class MasterPage { // ViewChild takes a class type or a reference name string.  // Here we are using the type  @ViewChild(UserProfile) userProfile: UserProfile constructor() { } ngAfterViewInit() { // After the view is initialized, this.userProfile will be available  this.update(); } update() { this.userProfile.sendData(); } } Here we use @ViewChild to query the component, since the view is associated with a component.
</content>
    </entry>
    
     <entry>
        <title>ThreadLocal</title>
        <url>http://yangchao.me/post/threadlocal/</url>
        <categories>
          
        </categories>
        <tags>
          
        </tags>
        <content type="html">  how to use? Basically, ThreadLocal is used for these scenarios: whenever you set a value/reference within this thread, you can get it from this thread. But it cannot guarantee you can ONLY get it from this thread.
When wrongly used, it may cause something counter-intuitive. For example, when you set a value/reference to a ThreadLocal, you also share it with other threads (say other threads can access the reference and mutable it.
public class ThreadLocalHolder { private ThreadLocal&amp;lt;SomeObject&amp;gt; threadLocal = new ThreadLocal&amp;lt;SomeObject&amp;gt;() { protected SomeObject initialValue() { // set the initial value when first getting or after removing  return SomeObject.DEFAULT; } }; public void foo() { getAndPrint(); threadLocal.set(new SomeObject(Thread.currentThread().getId())); getAndPrint(); threadLocal.remove(); getAndPrint(); } private void getAndPrint() { SomeObject someObject = threadLocal.get(); System.out.println(String.format(&amp;#34;Thread %d: %d&amp;#34;, Thread.currentThread().getId(), someObject.getValue())); } } class SomeObject { public static SomeObject DEFAULT = new SomeObject(0L); private long value; public SomeObject(long value) { this.value = value; } public long getValue() { return this.value; } public void setValue(long value) { this.value = value; } }public class Main { public static void main(String[] args) throws InterruptedException { final ThreadLocalHolder threadLocalHolder = new ThreadLocalHolder(); final int threadCount = 200; final CountDownLatch countDownLatch = new CountDownLatch(threadCount); ExecutorService executorService = Executors.newFixedThreadPool(threadCount); for(int i=0; i&amp;lt; threadCount; &#43;&#43;i) { executorService.submit(new Runnable() { public void run() { threadLocalHolder.foo(); countDownLatch.countDown(); } }); } countDownLatch.await(); executorService.shutdown(); } } Possible &amp;ldquo;incorrect&amp;rdquo; usage: Here we share the reference by setting it to the a field of ThreadLocalHolder, so another thread can mutate its value. From the respective of the first thread, this thread sets it but its state can still be visible and modified by other threads. Sometime it seems to voilate the original purpose of ThreadLocal. public class ThreadLocalHolder { private ThreadLocal&amp;lt;SomeObject&amp;gt; threadLocal = new ThreadLocal&amp;lt;SomeObject&amp;gt;() { protected SomeObject initialValue() { // set the initial value when first getting or after removing  return SomeObject.DEFAULT; } }; public volatile SomeObject shared; public void foo() throws InterruptedException { getAndPrint(); this.shared = new SomeObject(Thread.currentThread().getId()); threadLocal.set(shared); Thread.sleep(3000); getAndPrint(); threadLocal.remove(); getAndPrint(); } private void getAndPrint() { SomeObject someObject = threadLocal.get(); System.out.println(String.format(&amp;#34;Thread %d: %d at %d&amp;#34;, Thread.currentThread().getId(), someObject.getValue(), System.nanoTime())); } } class SomeObject { public static SomeObject DEFAULT = new SomeObject(0L); private long value; public SomeObject(long value) { this.value = value; } public long getValue() { return this.value; } public void setValue(long value) { this.value = value; } } Simply test it:
public class Main { public static void main(String[] args) throws InterruptedException { final ThreadLocalHolder threadLocalHolder = new ThreadLocalHolder(); final int threadCount = 3; final CyclicBarrier cyclicBarrier = new CyclicBarrier(threadCount); ExecutorService executorService = Executors.newFixedThreadPool(threadCount); Runnable runnable = new Runnable() { public void run() { try { cyclicBarrier.await(); } catch (InterruptedException e) { e.printStackTrace(); } catch (BrokenBarrierException e) { e.printStackTrace(); } try { threadLocalHolder.foo(); } catch (InterruptedException e) { e.printStackTrace(); } } }; executorService.submit(runnable); executorService.submit(runnable); executorService.submit(new Runnable() { public void run() { try { cyclicBarrier.await(); } catch (InterruptedException e) { e.printStackTrace(); } catch (BrokenBarrierException e) { e.printStackTrace(); } while(threadLocalHolder.shared == null) { } threadLocalHolder.shared.setValue(9999); } }); executorService.shutdown(); } } Another hack is we reflection another Thread&amp;rsquo;s threadlocals.
 implementation details In the first place, we don&amp;rsquo;t dive into the source code. We can think of how to implement it on our own.
Circumstance: - Whenever a native thread is created, a Thread object is instantiated in the heap. You can simply think it as the &amp;ldquo;handle&amp;rdquo; or &amp;ldquo;mirror&amp;rdquo; of the native thread. - we should be able to define multiple ThreadLocal. - Every ThreadLocal is associated with ONLY one value/reference within a thread.
As per the above requirement, it&amp;rsquo;s easy to think of this solution: - we use Thread object to maintain a threadlocal map: [ThreadLocal, Value] - when set is invoked, firstly get the Thread object of current thread and get its threadlocal map and put the value into it. - when get is invoked, firstly get the Thread object of current thread and get its threadlocal map and get the value from it.
So the most important class here is the ThreadLocalMap. Every Thread object has a ThreadLocalMap: threadlocals.
ThreadLocal.ThreadLocalMap.Entry The Entry is a WeakReference to its key ThreadLocal, so it doesn&amp;rsquo;t prevent the ThreadLocal from being reclaimed by GC. If all the references to the ThreadLocal object are weak of soft, GC can reclaim it even entry reference to it. At this time, entry.get() will return null and therefore this entry can be expunged from table. Such entries are referred to &amp;ldquo;stale entries&amp;rdquo;. When to clean these &amp;ldquo;stale entries&amp;rdquo;? - Threadlocal#get(..) - Threadlocal#set(..) - Threadlocal#remove(..)
ThreadLocalMap: hash table open addressing It don&amp;rsquo;t use ‘LinkList&amp;rsquo; to resolve conflicts, instead use &amp;ldquo;Open addressing&amp;rdquo;.
find next slot until the slot is empty
private void set(ThreadLocal&amp;lt;?&amp;gt; key, Object value) { // We don&amp;#39;t use a fast path as with get() because it is at  // least as common to use set() to create new entries as  // it is to replace existing ones, in which case, a fast  // path would fail more often than not.  Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode &amp;amp; (len-1); for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) { ThreadLocal&amp;lt;?&amp;gt; k = e.get(); if (k == key) { e.value = value; return; } if (k == null) { replaceStaleEntry(key, value, i); return; } } tab[i] = new Entry(key, value); int sz = &#43;&#43;size; if (!cleanSomeSlots(i, sz) &amp;amp;&amp;amp; sz &amp;gt;= threshold) rehash(); } How to find next index? Simple, just increment i modulo len ((i &#43; 1 &amp;lt; len) ? i &#43; 1 : 0);
from hashcode to slot index Like HashMap does: hashcode &amp;amp; (length - 1)
ThreadLocal hashcode //TODO
Is ThreadLocal thread safe? Refer to: - http://stackoverflow.com/a/27188314/4344443 - http://stackoverflow.com/a/15653015/4344443
Basically, the ThreadLocalMap itself is not thread-safe, but it is associated with a Thread object, which makes it can be only accessed by one thread. So if you don&amp;rsquo;t use abnormal access ways (like reflection), it can ensure thread-safe.
</content>
    </entry>
    
     <entry>
        <title>Dive into JMM</title>
        <url>http://yangchao.me/post/dive-into-jmm/</url>
        <categories>
          
        </categories>
        <tags>
          
        </tags>
        <content type="html">  JMM is an advanced and abstract topic in Java. It provides well-defined semantics for synchronization and help us reason the code execution in a multi-thread enviorionment.
Keywords: main memory, local memory, reordering, visibility, memory barrier/fence
What do the issues come from? References  The JSR-133 Cookbook for Compiler Writers Memory Barriers and JVM Concurrency  //TODO
</content>
    </entry>
    
     <entry>
        <title>Double Checked Locking in lazy-initialization Singleton</title>
        <url>http://yangchao.me/post/double-checked-locking-in-singleton/</url>
        <categories>
          
        </categories>
        <tags>
          
        </tags>
        <content type="html">  double-checked locking idiom (aka. DCL) broken versions Here we follow the evolution process of how to create a lazy-initialization singleton.
// naive version public class Singleton { private static Singleton DEFAULT; public static Singleton getDefault() { if(DEFAULT == null) { DEFAULT = new Singleton(); } return DEFAULT; } private Singleton() {} // other instance methods  } Race condition: - when thread 1 has executed if(DEFAULT == null) and then is preempted by thread 2. - Thread 2 checks DEFAULT is null, it instantiates the DEFAULT. - Thread 1 starts executing again, then it instantiates the DEFAULT once again and overwrites the DEFAULT reference.
Actually, more than one instances are created in the heap.
Now we fix it to synchronize the instantiation.
// synchronized version public class Singleton { private static Singleton DEFAULT; public static synchronized Singleton getDefault() { if(DEFAULT == null) { DEFAULT = new Singleton(); } return DEFAULT; } private Singleton() {} // other instance methods  } whenever we need to fetch the singleton, we need to synchronize no matter whether the singleton is null.
This version is inherently thread safe but not efficient.
Now we continue to fix it by reducing the locking range.
// reducing locking range public class Singleton { private static Singleton DEFAULT; public static Singleton getDefault() { if(DEFAULT == null) { synchronized(Singleton.class) { DEFAULT = new Singleton(); } } return DEFAULT; } private Singleton() {} // other instance methods  } Race condition: - when thread 1 has executed if(DEFAULT == null) { and then fail to acquire lock which is occupied by thread 2. - Thread 2 instantiates the DEFAULT and releases the lock. - Thread 1 acquire the lock and continue to execute, then it instantiates the DEFAULT once again and overwrites the DEFAULT reference.
We continue to fix the problem.
// double-checked locking public class Singleton { private static Singleton DEFAULT; public static Singleton getDefault() { if(DEFAULT == null) { synchronized(Singleton.class) { if(DEFAULT == null) { DEFAULT = new Singleton(); } } } return DEFAULT; } private Singleton() {} // other instance methods  } But this still has problems. DEFAULT = new Singleton() can be reordered by compiler or cpu. It may be compiled to multiple instructions:
 1 new #1 &amp;lt;playground/singleton/naive/Singleton&amp;gt; 2 dup 3 invokespecial #19 &amp;lt;playground/singleton/naive/Singleton.&amp;lt;init&amp;gt;&amp;gt; 4 putstatic #17 &amp;lt;playground/singleton/naive/Singleton.DEFAULT&amp;gt;  The 4th instruction can even be executed before the 3rd instruction. NOTE: Usually, compiler reordering happens in native instruction level, so JIT compilier, not AoT compiler does that. Here we use bytecode instructions just for demonstrations.
That means another thread can see a non-null reference to a Singleton object, but see the default values for fields of the Singleton object, rather than the values set in the constructor. Using the partially constructed object is of some risks.
 synchronized and reordering Does synchronized prevent reordering? It prevents some re-ordering. You can still have re-ordering outside the synchronized block and inside the synchronized block, but not from inside a synchronized block, to outside it.
 The above cases can be found with details here: The &amp;ldquo;Double-Checked Locking is Broken&amp;rdquo; Declaration
workable version However, after JDK 5.0, the fixed JMM make volatile have clear semantics. So we can make the above version workable.
// double-checked locking enhanced by volatile; this version is workable. public class Singleton { private static volatile Singleton DEFAULT; public static Singleton getDefault() { if(DEFAULT == null) { synchronized(Singleton.class) { if(DEFAULT == null) { DEFAULT = new Singleton(); } } } return DEFAULT; } private Singleton() {} // other instance methods  } Here, the volatile is the key. From the semantics of volatile, it makes the actions that happen before the write to helper in the code must, when the program executes, actually happen before the write to helper — no sneaky reordering is allowed.
 1 new #1 &amp;lt;playground/singleton/naive/Singleton&amp;gt; 2 dup 3 invokespecial #19 &amp;lt;playground/singleton/naive/Singleton.&amp;lt;init&amp;gt;&amp;gt; |__ store barrier __| 4 putstatic #17 &amp;lt;playground/singleton/naive/Singleton.DEFAULT&amp;gt;  You can see there should be a store barrier for pubstatic, which make the instructions before it cannot be reordered to after it.
Please refer to http://jeremymanson.blogspot.jp/2008/05/double-checked-locking.html
Better ways I don&amp;rsquo;t know how the lazy-initialization makes sense. Some more concise and thread-safe eager-initialization ways:
// final public class Singleton { public static Singleton DEFAULT = new Singleton(); private Singleton() {} // other instance methods  } or static factory way:
// final / static factory public class Singleton { private static Singleton DEFAULT = new Singleton(); public static Singleton getDefault() { return DEFAULT; } private Singleton() {} // other instance methods  } &amp;lt;clinint&amp;gt; is invoked by JVM, it can guarantee the thread safe and the write visible to threads. For better reasoning, we can add extra final to the static field.
Refer to: https://docs.oracle.com/javase/specs/jls/se8/html/jls-12.html#jls-12.4.2 https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.5
&amp;ldquo;Java Concurrency in Practice&amp;rdquo; provides a way of lazy-initialization placeholder pattern.
// lazy-initialization placeholder public class Singleton { private static class SingletonHolder { public static Singleton DEFAULT = new Singleton(); } public static Singleton getDefault() { return SingletonHolder.DEFAULT; } private Singleton() {} // other instance methods  } Another way is to use enum.
// enum public enum Singleton { DEFAULT; private Singleton() {} // other instance methods  } This way is from the book &amp;ldquo;Effective Java&amp;rdquo;.
</content>
    </entry>
    
     <entry>
        <title>thread interrupt and cancelable mechanism</title>
        <url>http://yangchao.me/post/thread-interrupt-and-cancelable-mechanism/</url>
        <categories>
          
        </categories>
        <tags>
          
        </tags>
        <content type="html">  To begin with, I issue some questions: - what does Thread#interrupt() do? - what is the difference between Thread#isInterrupted() and Thread.interrupted? - do I have to respond to interruption event? - when an InterruptedException is thrown? - how should I handle the caught InterruptedException? - how do I implement a cancelable mechanism for my task by polling interruption event? - apart from wait(), sleep(), join(), are there other scenarios throwing InterruptedException? - can we implement the similar interruption handling ways as wait() or like? - can LockSupport#park() respond to interruption and throw InterruptedException? - is interruption event underrated? do we need to especially consider responding interruption when we write multi-thread code?
thread interruption APIs Now there are two thread t and u.
Thread interruption is a collaboration mechanism which is NOT peremptory. Thread t can interrupt thread u, and the result depends on whether thread u responds this interruption.
A thread has an interruption status. Thread#interrupt() just set this status. This status can be checked by invoke Thread#isInterrupted(). And Thread.interrupted() is just a shortcut of getting the interruption status of current thread and then clearing this status.
Additionally, in the following scenarios, the interrupt status will be clear with throwing InterruptedException: - m.wait(), then thread u will be removed from the wait set of m, after re-locking the m&amp;rsquo;s monitor, throw InterruptedException. - tt.join(), actually equivalent to tt.wait() until not active, same as the above. - sleep(), not need to reacquire any lock before throwing InterruptedException.
//TODO
</content>
    </entry>
    
     <entry>
        <title>Java array has length field?</title>
        <url>http://yangchao.me/post/java-array-has-length-field/</url>
        <categories>
          
        </categories>
        <tags>
          
        </tags>
        <content type="html">  Today, a coworker asked me in which part of object header the length of an array object is stored. Since in my impression, the object header is of two machine words. But a book said for array, there must be length information stored in the object header. But where?
array is special There is no &amp;ldquo;class definition&amp;rdquo; of an array (you can&amp;rsquo;t find it in any .class file), they&amp;rsquo;re a part of the language itself.
This is quoted from JLS:
 10.7. Array Members
The members of an array type are all of the following:
The public final field length, which contains the number of components of the array. length may be positive or zero. The public method clone, which overrides the method of the same name in class Object and throws no checked exceptions. The return type of the clone method of an array type T[] is T[].
A clone of a multidimensional array is shallow, which is to say that it creates only a single new array. Subarrays are shared. All the members inherited from class Object; the only method of Object that is not inherited is its clone method.
 length is a field of array class? No. It is not a field of an array class. You cannot reflect it from its class.
String[] arr = {&amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;}; Field field = arr.getClass().getField(&amp;#34;length&amp;#34;); System.out.println(field.get(arr)); To be disappointed, you cannot get this length field. specify length when array creation public void foo(int i) { String[] arr = new String[i]; int l = arr.length; } The following is the decompiled bytecode:
public void foo(int); flags: ACC_PUBLIC Code: stack=1, locals=4, args_size=2 0: iload_1 1: anewarray #16 // class java/lang/String 4: astore_2 5: aload_2 6: arraylength 7: istore_3 8: return LineNumberTable: line 6: 0 line 7: 5 line 8: 8 LocalVariableTable: Start Length Slot Name Signature 0 9 0 this Lplayground/ArrayLength; 0 9 1 i I 5 4 2 arr [Ljava/lang/String; 8 1 3 l I  get length using specilized opcode arraylength is a specialized opcode to get the array length.
where to store this length This is really JVM implementation related. From the The Java HotSpot Performance Engine Architecture
 Two-Word Object Headers The Java HotSpot VM uses a two machine-word object header, as opposed to three words in the Classic VM. Since the average Java object size is small, this has a significant impact on space consumption &amp;ndash; saving approximately eight percent in heap size for typical applications. The first header word contains information such as the identity hash code and GC status information. The second is a reference to the object&amp;rsquo;s class. Only arrays have a third header field, for the array size.
 NOTE: Hotspot uses an extra word in the object header to store the array length.
To verfiy this statement, we write some code to view the object header
import org.openjdk.jol.info.ClassLayout; import org.openjdk.jol.vm.VM; public class ObjectHeaderView { public static void main(String[] args) throws Exception { System.out.println(VM.current().details()); A a = new A(); A[] arr = new A[100]; System.out.println(ClassLayout.parseInstance(a).toPrintable()); System.out.println(ClassLayout.parseInstance(arr).toPrintable()); } } class A {} This is the output:
# Running 64-bit HotSpot VM. # Using compressed oop with 3-bit shift. # Using compressed klass with 3-bit shift. # WARNING | Compressed references base/shifts are guessed by the experiment! # WARNING | Therefore, computed addresses are just guesses, and ARE NOT RELIABLE. # WARNING | Make sure to attach Serviceability Agent to get the reliable addresses. # Objects are 8 bytes aligned. # Field sizes by type: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes] # Array element sizes: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes] playground.A object internals: OFFSET SIZE TYPE DESCRIPTION VALUE 0 4 (object header) 01 00 00 00 (00000001 00000000 00000000 00000000) (1) 4 4 (object header) 00 00 00 00 (00000000 00000000 00000000 00000000) (0) 8 4 (object header) 33 de 0c f8 (00110011 11011110 00001100 11111000) (-133374413) 12 4 (loss due to the next object alignment) Instance size: 16 bytes Space losses: 0 bytes internal &#43; 4 bytes external = 4 bytes total [Lplayground.A; object internals: OFFSET SIZE TYPE DESCRIPTION VALUE 0 4 (object header) 01 00 00 00 (00000001 00000000 00000000 00000000) (1) 4 4 (object header) 00 00 00 00 (00000000 00000000 00000000 00000000) (0) 8 4 (object header) 85 de 0c f8 (10000101 11011110 00001100 11111000) (-133374331) 12 4 (object header) 64 00 00 00 (01100100 00000000 00000000 00000000) (100) 16 400 playground.A [Lplayground.A;.&amp;lt;elements&amp;gt; N/A Instance size: 416 bytes Space losses: 0 bytes internal &#43; 0 bytes external = 0 bytes total You can see, for JDK 7 on 64-bit MacOS: - normal object has one-word (64-bit) mark word and half-word (32-bit) kclass pointer(due to use of compressed oop). - array object has one-word mark word, half-word kclass pointer and extra half-word arrary size. (in the example, its value is 100).
More implementation details, please refer to: - markOop.hpp - oop.hpp
</content>
    </entry>
    
     <entry>
        <title>String intern</title>
        <url>http://yangchao.me/post/string-intern/</url>
        <categories>
          
        </categories>
        <tags>
          
        </tags>
        <content type="html">  Several simple code snippets // Sample1 char[] chars = {&amp;#39;h&amp;#39;, &amp;#39;e&amp;#39;, &amp;#39;l&amp;#39;, &amp;#39;l&amp;#39;, &amp;#39;o&amp;#39;}; String str1 = new String(chars); System.out.println(str1 == str1.intern()); print: true
// Sample2 String str1 = new String(&amp;#34;hello&amp;#34;); System.out.println(str1 == str1.intern()); print: false
// Sample3 String a = &amp;#34;hello&amp;#34;; String b = new String(&amp;#34;hello&amp;#34;); String c = new String(&amp;#34;h&amp;#34; &#43; &amp;#34;e&amp;#34; &#43; &amp;#34;l&amp;#34; &#43; &amp;#34;l&amp;#34; &#43; &amp;#34;o&amp;#34;); String d = b.intern(); How many String objects is created? Answer is 3. Are you right?
questions  when and where is the String object from string literal created, even if we don&amp;rsquo;t explicitly initialize it? what happens for intern()? how is the &amp;ldquo;pool of strings&amp;rdquo; implemented? what&amp;rsquo;s the difference of two constructors between String(char[]) and String(String)?  constant string loading and intern As we know, string literal is compiled into constant pool of the class file. And the bytecode to load it is ldc.
public class StringLiteral { public StringLiteral() { String str = &amp;#34;hello&amp;#34;; } } will be compiled to:
 Constant pool: #1 = Methodref #4.#16 // java/lang/Object.&amp;quot;&amp;lt;init&amp;gt;&amp;quot;:()V #2 = String #17 // hello #3 = Class #18 // StringLiteral #4 = Class #19 // java/lang/Object #5 = Utf8 &amp;lt;init&amp;gt; #6 = Utf8 ()V #7 = Utf8 Code #8 = Utf8 LineNumberTable #9 = Utf8 LocalVariableTable #10 = Utf8 this #11 = Utf8 LStringLiteral; #12 = Utf8 str #13 = Utf8 Ljava/lang/String; #14 = Utf8 SourceFile #15 = Utf8 StringLiteral.java #16 = NameAndType #5:#6 // &amp;quot;&amp;lt;init&amp;gt;&amp;quot;:()V #17 = Utf8 hello #18 = Utf8 StringLiteral #19 = Utf8 java/lang/Object { public StringLiteral(); flags: ACC_PUBLIC Code: stack=1, locals=2, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&amp;quot;&amp;lt;init&amp;gt;&amp;quot;:()V 4: ldc #2 // String hello 6: astore_1 7: return LineNumberTable: line 5: 0 line 6: 4 line 7: 7 LocalVariableTable: Start Length Slot Name Signature 0 8 0 this LStringLiteral; 7 1 1 str Ljava/lang/String; }  when ldc is executed, it must firstly resolve the symbol to the actual reference if not resolved.
NOTICE:
 4: ldc #2 // String hello 6: astore_1  will find #2 in constant pool:
 #2 = String #17 // hello #17 = Utf8 hello  Initially, #2 is Constant_String_info symbol, and it assoiciates with #17 which is Constant_Utf8_info (UTF-8 encoding char array).
// line2111-2161 share/vm/interpreter/bytecodeInterpreter.cpp CASE(_ldc): { u2 index; bool wide = false; int incr = 2; // frequent case  if (opcode == Bytecodes::_ldc) { index = pc[1]; } else { index = Bytes::get_Java_u2(pc&#43;1); incr = 3; wide = true; } ConstantPool* constants = METHOD-&amp;gt;constants(); switch (constants-&amp;gt;tag_at(index).value()) { .... case JVM_CONSTANT_String: { oop result = constants-&amp;gt;resolved_references()-&amp;gt;obj_at(index); if (result == NULL) { CALL_VM(InterpreterRuntime::resolve_ldc(THREAD, (Bytecodes::Code) opcode), handle_exception); SET_STACK_OBJECT(THREAD-&amp;gt;vm_result(), 0); THREAD-&amp;gt;set_vm_result(NULL); } else { VERIFY_OOP(result); SET_STACK_OBJECT(result, 0); } break; } .... } when it&amp;rsquo;s JVM_CONSTANT_String, jvm first checks resolved reference in line oop result = constants-&amp;gt;resolved_references()-&amp;gt;obj_at(index);. If it is not resolved, then call InterpreterRuntime::resolve_ldc(THREAD, (Bytecodes::Code) opcode).
// line125-142 share/vm/interpreter/interpreterRuntime.cpp IRT_ENTRY(void, InterpreterRuntime::resolve_ldc(JavaThread* thread, Bytecodes::Code bytecode)) { assert(bytecode == Bytecodes::_fast_aldc || bytecode == Bytecodes::_fast_aldc_w, &amp;#34;wrong bc&amp;#34;); ResourceMark rm(thread); methodHandle m (thread, method(thread)); Bytecode_loadconstant ldc(m, bci(thread)); oop result = ldc.resolve_constant(CHECK); #ifdef ASSERT  { // The bytecode wrappers aren&amp;#39;t GC-safe so construct a new one  Bytecode_loadconstant ldc2(m, bci(thread)); oop coop = m-&amp;gt;constants()-&amp;gt;resolved_references()-&amp;gt;obj_at(ldc2.cache_index()); assert(result == coop, &amp;#34;expected result for assembly code&amp;#34;); } #endif  thread-&amp;gt;set_vm_result(result); } IRT_END here, it then calls Bytecode_loadconstant::resolve_constant(..).
// line217-226 share/vm/interpreter/bytecode.cpp oop Bytecode_loadconstant::resolve_constant(TRAPS) const { assert(_method.not_null(), &amp;#34;must supply method to resolve constant&amp;#34;); int index = raw_index(); ConstantPool* constants = _method-&amp;gt;constants(); if (has_cache_index()) { return constants-&amp;gt;resolve_cached_constant_at(index, THREAD); } else { return constants-&amp;gt;resolve_constant_at(index, THREAD); } } here, no cache temporarily, it calls constants-&amp;gt;resolve_constant_at(index, THREAD).
// line705-709 share/vm/oops/constantPool.hpp  // Resolve late bound constants.  oop resolve_constant_at(int index, TRAPS) { constantPoolHandle h_this(THREAD, this); return resolve_constant_at_impl(h_this, index, _no_index_sentinel, THREAD); }// line614-718 shared/vm/oops/contantPool.cpp // Called to resolve constants in the constant pool and return an oop. // Some constant pool entries cache their resolved oop. This is also // called to create oops from constants to use in arguments for invokedynamic oop ConstantPool::resolve_constant_at_impl(constantPoolHandle this_oop, int index, int cache_index, TRAPS) { oop result_oop = NULL; Handle throw_exception; if (cache_index == _possible_index_sentinel) { // It is possible that this constant is one which is cached in the objects.  // We&amp;#39;ll do a linear search. This should be OK because this usage is rare.  assert(index &amp;gt; 0, &amp;#34;valid index&amp;#34;); cache_index = this_oop-&amp;gt;cp_to_object_index(index); } assert(cache_index == _no_index_sentinel || cache_index &amp;gt;= 0, &amp;#34;&amp;#34;); assert(index == _no_index_sentinel || index &amp;gt;= 0, &amp;#34;&amp;#34;); if (cache_index &amp;gt;= 0) { result_oop = this_oop-&amp;gt;resolved_references()-&amp;gt;obj_at(cache_index); if (result_oop != NULL) { return result_oop; // That was easy...  } index = this_oop-&amp;gt;object_to_cp_index(cache_index); } jvalue prim_value; // temp used only in a few cases below  int tag_value = this_oop-&amp;gt;tag_at(index).value(); switch (tag_value) { .... case JVM_CONSTANT_String: assert(cache_index != _no_index_sentinel, &amp;#34;should have been set&amp;#34;); if (this_oop-&amp;gt;is_pseudo_string_at(index)) { result_oop = this_oop-&amp;gt;pseudo_string_at(index, cache_index); break; } result_oop = string_at_impl(this_oop, index, cache_index, CHECK_NULL); break; .... } if (cache_index &amp;gt;= 0) { // Cache the oop here also.  Handle result_handle(THREAD, result_oop); MonitorLockerEx ml(this_oop-&amp;gt;lock()); // don&amp;#39;t know if we really need this  oop result = this_oop-&amp;gt;resolved_references()-&amp;gt;obj_at(cache_index); // Benign race condition: resolved_references may already be filled in while we were trying to lock.  // The important thing here is that all threads pick up the same result.  // It doesn&amp;#39;t matter which racing thread wins, as long as only one  // result is used by all threads, and all future queries.  // That result may be either a resolved constant or a failure exception.  if (result == NULL) { this_oop-&amp;gt;resolved_references()-&amp;gt;obj_at_put(cache_index, result_handle()); return result_handle(); } else { // Return the winning thread&amp;#39;s result. This can be different than  // result_handle() for MethodHandles.  return result; } } else { return result_oop; } } And then calls string_at_impl.
// line816-825 share/vm/oops/contantPool.cpp oop ConstantPool::string_at_impl(constantPoolHandle this_oop, int which, int obj_index, TRAPS) { // If the string has already been interned, this entry will be non-null  oop str = this_oop-&amp;gt;resolved_references()-&amp;gt;obj_at(obj_index); if (str != NULL) return str; Symbol* sym = this_oop-&amp;gt;unresolved_string_at(which); str = StringTable::intern(sym, CHECK_(NULL)); this_oop-&amp;gt;string_at_put(which, obj_index, str); assert(java_lang_String::is_instance(str), &amp;#34;must be string&amp;#34;); return str; } Finally, we find these two lines:
Symbol* sym = this_oop-&amp;gt;unresolved_string_at(which); str = StringTable::intern(sym, CHECK_(NULL)); Here sym is Utf8 the String is associate with.
// vm/classfile/symbolTable.cpp oop StringTable::intern(Symbol* symbol, TRAPS) { if (symbol == NULL) return NULL; ResourceMark rm(THREAD); int length; jchar* chars = symbol-&amp;gt;as_unicode(length); Handle string; oop result = intern(string, chars, length, CHECK_NULL); return result; } oop StringTable::intern(Handle string_or_null, jchar* name, int len, TRAPS) { unsigned int hashValue = hash_string(name, len); int index = the_table()-&amp;gt;hash_to_index(hashValue); oop found_string = the_table()-&amp;gt;lookup(index, name, len, hashValue); // Found  if (found_string != NULL) return found_string; debug_only(StableMemoryChecker smc(name, len * sizeof(name[0]))); assert(!Universe::heap()-&amp;gt;is_in_reserved(name), &amp;#34;proposed name of symbol must be stable&amp;#34;); Handle string; // try to reuse the string if possible  if (!string_or_null.is_null()) { string = string_or_null; } else { string = java_lang_String::create_from_unicode(name, len, CHECK_NULL); } // Grab the StringTable_lock before getting the_table() because it could  // change at safepoint.  MutexLocker ml(StringTable_lock, THREAD); // Otherwise, add to symbol to table  return the_table()-&amp;gt;basic_add(index, string, name, len, hashValue, CHECK_NULL); } oop StringTable::basic_add(int index_arg, Handle string, jchar* name, int len, unsigned int hashValue_arg, TRAPS) { assert(java_lang_String::equals(string(), name, len), &amp;#34;string must be properly initialized&amp;#34;); // Cannot hit a safepoint in this function because the &amp;#34;this&amp;#34; pointer can move.  No_Safepoint_Verifier nsv; // Check if the symbol table has been rehashed, if so, need to recalculate  // the hash value and index before second lookup.  unsigned int hashValue; int index; if (use_alternate_hashcode()) { hashValue = hash_string(name, len); index = hash_to_index(hashValue); } else { hashValue = hashValue_arg; index = index_arg; } // Since look-up was done lock-free, we need to check if another  // thread beat us in the race to insert the symbol.  oop test = lookup(index, name, len, hashValue); // calls lookup(u1*, int)  if (test != NULL) { // Entry already added  return test; } HashtableEntry&amp;lt;oop, mtSymbol&amp;gt;* entry = new_entry(hashValue, string()); add_entry(index, entry); return string(); } Firstly, it converts the Utf8 symbol to Java char array. Then using this char array to crate a String object by java_lang_String::create_from_unicode(name, len, CHECK_NULL);. Finally, add this oop of String to the table and return its oop. Here the_table is StringTable. StringTable is just a Hashtable.
// line185-192 shared/vm/classfile/javaClasses.cpp Handle java_lang_String::create_from_unicode(jchar* unicode, int length, TRAPS) { Handle h_obj = basic_create(length, CHECK_NH); typeArrayOop buffer = value(h_obj()); for (int index = 0; index &amp;lt; length; index&#43;&#43;) { buffer-&amp;gt;char_at_put(index, unicode[index]); } return h_obj; } explicitly call String#intern() This is the JNI method of String#intern():
// share/native/java/lang/String.c JNIEXPORT jobject JNICALL Java_java_lang_String_intern(JNIEnv *env, jobject this) { return JVM_InternString(env, this); }// share/vm/prims/jvm.cpp JVM_ENTRY(jstring, JVM_InternString(JNIEnv *env, jstring str)) JVMWrapper(&amp;#34;JVM_InternString&amp;#34;); JvmtiVMObjectAllocEventCollector oam; if (str == NULL) return NULL; oop string = JNIHandles::resolve_non_null(str); oop result = StringTable::intern(string, CHECK_NULL); return (jstring) JNIHandles::make_local(env, result); JVM_END You can see: oop result = StringTable::intern(string, CHECK_NULL); It calls the same method as the above code when loading constant string.
visualization StringTable has a static field _the_table and it can be accessed directly by StringTable::the_table(); So actually this is a JVM internal data structure belonging to JVM. It is globally created in universe. It makes no sense to say it is located in the method area.
for Sample1 for Sample2 for Sample3 </content>
    </entry>
    
     <entry>
        <title>How JVM handle method invocation</title>
        <url>http://yangchao.me/post/how-jvm-handle-method-invocation/</url>
        <categories>
          
        </categories>
        <tags>
          
        </tags>
        <content type="html">  Introduction Five forms of method invocation in Java: - invokevirtual - invokeinterface - invokestatic - invokespecial - invokedynamic
invokestatic and invokevirtual Of these, invokestatic and invokevirtual are easy to understand. invokevirtual is the default behaviour when we invoke an instance method. invokestatic is used to invoke the class method based on the type of the reference, not the class of the object when we invoke the static method through the instance rather than the class name.
class Superclass { public static void interestingMethod() { System.out.println(&amp;#34;Superclass&amp;#39;s interesting method.&amp;#34;); } } class Subclass extends Superclass { public static void interestingMethod() { System.out.println(&amp;#34;Subclass&amp;#39;s interesting method.&amp;#34;); } public static void main(String args[]) { Subclass sub = new Subclass(); sub.interestingMethod(); Superclass sub1 = new Subclass(); sub1.interestingMethod(); } } It will print: Subclass&amp;rsquo;s interesting method. Superclass&amp;rsquo;s interesting method. invokespecial Now let&amp;rsquo;s see where invokespecial is used. - invocation of instance initialization (&amp;lt;init&amp;gt;) methods - invocation of methods using the super keyword - invocation of private methods
class Superclass { private void interestingMethod() { System.out.println(&amp;#34;Superclass&amp;#39;s interesting method.&amp;#34;); } void exampleMethod() { interestingMethod(); // invokespecial  } } class Subclass extends Superclass { void interestingMethod() { System.out.println(&amp;#34;Subclass&amp;#39;s interesting method.&amp;#34;); } public static void main(String args[]) { Subclass me = new Subclass(); me.exampleMethod(); } } This code snippet will print: Superclass&amp;rsquo;s interesting method.
Now we just change Superclass#interestingMethod() to package or protected modifier. Then, it will print: Subclass&amp;rsquo;s interesting method.
invokeinterface vs. invokevirtual invokeinterface opcode performs the same function as invokevirtual. The only difference is that invokeinterface is used when the reference is of an interface type.
difference explanation But why we need a different opcode: invokevirtual vs. invokeinterface? The essential idea is that invokevirtual makes it possible for JVM to cache methods resolution results.
This is an explanation from Stackoverflow.
 Each Java class is associated with a virtual method table that contains &amp;ldquo;links&amp;rdquo; to the bytecode of each method of a class. That table is inherited from the superclass of a particular class and extended with regard to the new methods of a subclass. E.g.,
class BaseClass { public void method1() { } public void method2() { } public void method3() { } }
class NextClass extends BaseClass { public void method2() { } // overridden from BaseClass public void method4() { } } results in the tables
BaseClass 1. BaseClass/method1() 2. BaseClass/method2() 3. BaseClass/method3()
NextClass 1. BaseClass/method1() 2. NextClass/method2() 3. BaseClass/method3() 4. NextClass/method4() Note, how the virtual method table of NextClass retains the order of entries of the table of BaseClass and just overwrites the &amp;ldquo;link&amp;rdquo; of method2() which it overrides.
An implementation of the JVM can thus optimize a call to invokevirtual by remembering that BaseClass/method3() will always be the third entry in the virtual method table of any object this method will ever be invoked on.
With invokeinterface this optimization is not possible. E.g.,
interface MyInterface { void ifaceMethod(); }
class AnotherClass extends NextClass implements MyInterface { public void method4() { } // overridden from NextClass public void ifaceMethod() { } }
class MyClass implements MyInterface { public void method5() { } public void ifaceMethod() { } } This class hierarchy results in the virtual method tables
AnotherClass 1. BaseClass/method1() 2. NextClass/method2() 3. BaseClass/method3() 4. AnotherClass/method4() 5. MyInterface/ifaceMethod()
MyClass 1. MyClass/method5() 2. MyInterface/ifaceMethod() As you can see, AnotherClass contains the interface&amp;rsquo;s method in its fifth entry and MyClass contains it in its second entry. To actually find the correct entry in the virtual method table, a call to a method with invokeinterface will always have to search the complete table without a chance for the style of optimization that invokevirtual does.
There are additional differences like the fact, that invokeinterface can be used together with object references that do not actually implement the interface. Therefore, invokeinterface will have to check at runtime whether a method exists in the table and potentially throw an exception. If you want to dive deeper into the topic, I suggest, e.g., &amp;ldquo;Efficient Implementation of Java Interfaces: Invokeinterface Considered Harmless&amp;rdquo;.
 vitual / interface dispatching performance benchmark A benchmark code to compare invokevirtual with invokeinterface performance. invokeinterface is 38% slower. If volatile modifier is removed from aand i (and it becomes possible for JVM to cache methods resolution results), the performance becomes comparable for both cases and the code runs ~10x faster than with volatile variables. A background in essence is &amp;ldquo;interfaces do not exist in runtime&amp;rdquo; so virtual dispatching can&amp;rsquo;t be applied to interface methods. The idea is very well explained above. Below is a benchmark to compare invokevirtual with invokeinterface performance. Prevents JVM from optimizing out invokeinterface by declaring target object volatile.
public class InvokevirtualVsInvokeinterface { private static interface I { public int getInteger (); } private static class A implements I { public int getInteger () { return 0; } } private static class B extends A { } static volatile I i = new B(); static volatile A a = new B(); public static void main(String[] args) { { long tm1 = System.nanoTime(); for (int k = 0; k &amp;lt; 100000000; &#43;&#43;k) { a.getInteger(); } long tm2 = System.nanoTime(); System.out.println(&amp;#34;invokevirtual took &amp;#34; &#43; (Math.abs(tm2 - tm1) / 1000) &#43; &amp;#34; us&amp;#34;); } { long tm1 = System.nanoTime(); for (int k = 0; k &amp;lt; 100000000; &#43;&#43;k) { i.getInteger(); } long tm2 = System.nanoTime(); System.out.println(&amp;#34;invokeinterface took &amp;#34; &#43; (Math.abs(tm2 - tm1) / 1000) &#43; &amp;#34; us&amp;#34;); } // Output on Intel Xeon X5570 @ 2.93GHz:  // invokevirtual took 41170 us  // invokeinterface took 66305 us  } } and the corresponding bytecode (the output of &amp;ldquo;javap -c&amp;rdquo;)
// Compiled from &amp;#34;InvokevirtualVsInvokeinterface.java&amp;#34; public class InvokevirtualVsInvokeinterface extends java.lang.Object{ static volatile InvokevirtualVsInvokeinterface$I i; static volatile InvokevirtualVsInvokeinterface$A a; public InvokevirtualVsInvokeinterface(); Code: 0:	aload_0 1:	invokespecial	#1; //Method java/lang/Object.&amp;#34;&amp;lt;init&amp;gt;&amp;#34;:()V 4:	return public static void main(java.lang.String[]); Code: 0:	invokestatic	#2; //Method java/lang/System.nanoTime:()J 3:	lstore_1 4:	iconst_0 5:	istore_3 6:	iload_3 7:	ldc	#3; //int 100000000 9:	if_icmpge	25 12:	getstatic	#4; //Field a:LInvokevirtualVsInvokeinterface$A; 15:	invokevirtual	#5; //Method InvokevirtualVsInvokeinterface$A.getInteger:()I 18:	pop 19:	iinc	3, 1 22:	goto	6 25:	invokestatic	#2; //Method java/lang/System.nanoTime:()J 28:	lstore_3 29:	getstatic	#6; //Field java/lang/System.out:Ljava/io/PrintStream; 32:	new	#7; //class java/lang/StringBuilder 35:	dup 36:	invokespecial	#8; //Method java/lang/StringBuilder.&amp;#34;&amp;lt;init&amp;gt;&amp;#34;:()V 39:	ldc	#9; //String invokevirtual took 41:	invokevirtual	#10; //Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 44:	lload_3 45:	lload_1 46:	lsub 47:	invokestatic	#11; //Method java/lang/Math.abs:(J)J 50:	ldc2_w	#12; //long 1000l 53:	ldiv 54:	invokevirtual	#14; //Method java/lang/StringBuilder.append:(J)Ljava/lang/StringBuilder; 57:	ldc	#15; //String us 59:	invokevirtual	#10; //Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 62:	invokevirtual	#16; //Method java/lang/StringBuilder.toString:()Ljava/lang/String; 65:	invokevirtual	#17; //Method java/io/PrintStream.println:(Ljava/lang/String;)V 68:	invokestatic	#2; //Method java/lang/System.nanoTime:()J 71:	lstore_1 72:	iconst_0 73:	istore_3 74:	iload_3 75:	ldc	#3; //int 100000000 77:	if_icmpge	95 80:	getstatic	#18; //Field i:LInvokevirtualVsInvokeinterface$I; 83:	invokeinterface	#19, 1; //InterfaceMethod InvokevirtualVsInvokeinterface$I.getInteger:()I 88:	pop 89:	iinc	3, 1 92:	goto	74 95:	invokestatic	#2; //Method java/lang/System.nanoTime:()J 98:	lstore_3 99:	getstatic	#6; //Field java/lang/System.out:Ljava/io/PrintStream; 102:	new	#7; //class java/lang/StringBuilder 105:	dup 106:	invokespecial	#8; //Method java/lang/StringBuilder.&amp;#34;&amp;lt;init&amp;gt;&amp;#34;:()V 109:	ldc	#20; //String invokeinterface took 111:	invokevirtual	#10; //Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 114:	lload_3 115:	lload_1 116:	lsub 117:	invokestatic	#11; //Method java/lang/Math.abs:(J)J 120:	ldc2_w	#12; //long 1000l 123:	ldiv 124:	invokevirtual	#14; //Method java/lang/StringBuilder.append:(J)Ljava/lang/StringBuilder; 127:	ldc	#15; //String us 129:	invokevirtual	#10; //Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 132:	invokevirtual	#16; //Method java/lang/StringBuilder.toString:()Ljava/lang/String; 135:	invokevirtual	#17; //Method java/io/PrintStream.println:(Ljava/lang/String;)V 138:	return static {}; Code: 0:	new	#21; //class InvokevirtualVsInvokeinterface$B 3:	dup 4:	aconst_null 5:	invokespecial	#22; //Method InvokevirtualVsInvokeinterface$B.&amp;#34;&amp;lt;init&amp;gt;&amp;#34;:(LInvokevirtualVsInvokeinterface$1;)V 8:	putstatic	#18; //Field i:LInvokevirtualVsInvokeinterface$I; 11:	new	#21; //class InvokevirtualVsInvokeinterface$B 14:	dup 15:	aconst_null 16:	invokespecial	#22; //Method InvokevirtualVsInvokeinterface$B.&amp;#34;&amp;lt;init&amp;gt;&amp;#34;:(LInvokevirtualVsInvokeinterface$1;)V 19:	putstatic	#4; //Field a:LInvokevirtualVsInvokeinterface$A; 22:	return } vtable and itable in OpenJDK source code //In Progress
references Efficient Implementation of Java Interfaces: Invokeinterface Considered Harmless
</content>
    </entry>
    
     <entry>
        <title>Dynamic Proxy revisit</title>
        <url>http://yangchao.me/post/dynamic-proxy-revisit/</url>
        <categories>
          
        </categories>
        <tags>
          
        </tags>
        <content type="html">  Dynamic Proxy in JDK Proxy is a class which can get the proxy class and create the proxy instance. It has a private default constructor and a protected constructor with a contractor argument: InvocationHandler.
InvocationHandler is an interface which we can apply our code into the generated proxy class. It has only one method: Object invoke(Object proxy, Method method, Object[] args)
Proxy has four static methods:
static Class&amp;lt;?&amp;gt; getProxyClass(ClassLoader loader, Class&amp;lt;?&amp;gt;... interfaces) static Object newProxyInstance(ClassLoader loader, Class&amp;lt;?&amp;gt;[] interfaces, InvocationHandler h) static boolean isProxyClass(Class&amp;lt;?&amp;gt; cl) static InvocationHandler getInvocationHandler(Object proxy) Now let us see how to generate a proxy class in memory. The main logic is in ProxyClassFactory: firstly it call the ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags) to generate the bytes of class file, and then it invokes the native method of Proxy static native Class&amp;lt;?&amp;gt; defineClass0(ClassLoader loader, String name, byte[] b, int off, int len) to load and resolve the bytes into a Class.
So the two static methods ProxyGenerator.generateProxyClass(..) and Proxy.defineClass0(..) are very important.
Proxy.defineClass0(..) makes that we don&amp;rsquo;t need to define a ClassLoader to load a class from raw bytes. We will use it as a utility method later.
ProxyGenerator has no secret since it just generates the bytecode following the class file format in the JVM specification. // https://github.com/openjdk-mirror/jdk7u-jdk/blob/master/src/share/classes/sun/misc/ProxyGenerator.java package sun.misc; import java.io.ByteArrayOutputStream; import java.io.DataOutputStream; import java.io.FileOutputStream; import java.io.IOException; import java.io.OutputStream; import java.lang.reflect.Array; import java.lang.reflect.Method; import java.util.ArrayList; import java.util.HashMap; import java.util.LinkedList; import java.util.List; import java.util.ListIterator; import java.util.Map; import sun.security.action.GetBooleanAction; /** * ProxyGenerator contains the code to generate a dynamic proxy class * for the java.lang.reflect.Proxy API. * * The external interfaces to ProxyGenerator is the static * &amp;#34;generateProxyClass&amp;#34; method. * * @author Peter Jones * @since 1.3 */ public class ProxyGenerator { /* * In the comments below, &amp;#34;JVMS&amp;#34; refers to The Java Virtual Machine * Specification Second Edition and &amp;#34;JLS&amp;#34; refers to the original * version of The Java Language Specification, unless otherwise * specified. */ /* generate 1.5-era class file version */ private static final int CLASSFILE_MAJOR_VERSION = 49; private static final int CLASSFILE_MINOR_VERSION = 0; /* * beginning of constants copied from * sun.tools.java.RuntimeConstants (which no longer exists): */ /* constant pool tags */ private static final int CONSTANT_UTF8 = 1; private static final int CONSTANT_UNICODE = 2; private static final int CONSTANT_INTEGER = 3; private static final int CONSTANT_FLOAT = 4; private static final int CONSTANT_LONG = 5; private static final int CONSTANT_DOUBLE = 6; private static final int CONSTANT_CLASS = 7; private static final int CONSTANT_STRING = 8; private static final int CONSTANT_FIELD = 9; private static final int CONSTANT_METHOD = 10; private static final int CONSTANT_INTERFACEMETHOD = 11; private static final int CONSTANT_NAMEANDTYPE = 12; /* access and modifier flags */ private static final int ACC_PUBLIC = 0x00000001; private static final int ACC_PRIVATE = 0x00000002; // private static final int ACC_PROTECTED = 0x00000004;  private static final int ACC_STATIC = 0x00000008; private static final int ACC_FINAL = 0x00000010; // private static final int ACC_SYNCHRONIZED = 0x00000020; // private static final int ACC_VOLATILE = 0x00000040; // private static final int ACC_TRANSIENT = 0x00000080; // private static final int ACC_NATIVE = 0x00000100; // private static final int ACC_INTERFACE = 0x00000200; // private static final int ACC_ABSTRACT = 0x00000400;  private static final int ACC_SUPER = 0x00000020; // private static final int ACC_STRICT = 0x00000800;  /* opcodes */ // private static final int opc_nop = 0;  private static final int opc_aconst_null = 1; // private static final int opc_iconst_m1 = 2;  private static final int opc_iconst_0 = 3; // private static final int opc_iconst_1 = 4; // private static final int opc_iconst_2 = 5; // private static final int opc_iconst_3 = 6; // private static final int opc_iconst_4 = 7; // private static final int opc_iconst_5 = 8; // private static final int opc_lconst_0 = 9; // private static final int opc_lconst_1 = 10; // private static final int opc_fconst_0 = 11; // private static final int opc_fconst_1 = 12; // private static final int opc_fconst_2 = 13; // private static final int opc_dconst_0 = 14; // private static final int opc_dconst_1 = 15;  private static final int opc_bipush = 16; private static final int opc_sipush = 17; private static final int opc_ldc = 18; private static final int opc_ldc_w = 19; // private static final int opc_ldc2_w = 20;  private static final int opc_iload = 21; private static final int opc_lload = 22; private static final int opc_fload = 23; private static final int opc_dload = 24; private static final int opc_aload = 25; private static final int opc_iload_0 = 26; // private static final int opc_iload_1 = 27; // private static final int opc_iload_2 = 28; // private static final int opc_iload_3 = 29;  private static final int opc_lload_0 = 30; // private static final int opc_lload_1 = 31; // private static final int opc_lload_2 = 32; // private static final int opc_lload_3 = 33;  private static final int opc_fload_0 = 34; // private static final int opc_fload_1 = 35; // private static final int opc_fload_2 = 36; // private static final int opc_fload_3 = 37;  private static final int opc_dload_0 = 38; // private static final int opc_dload_1 = 39; // private static final int opc_dload_2 = 40; // private static final int opc_dload_3 = 41;  private static final int opc_aload_0 = 42; // private static final int opc_aload_1 = 43; // private static final int opc_aload_2 = 44; // private static final int opc_aload_3 = 45; // private static final int opc_iaload = 46; // private static final int opc_laload = 47; // private static final int opc_faload = 48; // private static final int opc_daload = 49; // private static final int opc_aaload = 50; // private static final int opc_baload = 51; // private static final int opc_caload = 52; // private static final int opc_saload = 53; // private static final int opc_istore = 54; // private static final int opc_lstore = 55; // private static final int opc_fstore = 56; // private static final int opc_dstore = 57;  private static final int opc_astore = 58; // private static final int opc_istore_0 = 59; // private static final int opc_istore_1 = 60; // private static final int opc_istore_2 = 61; // private static final int opc_istore_3 = 62; // private static final int opc_lstore_0 = 63; // private static final int opc_lstore_1 = 64; // private static final int opc_lstore_2 = 65; // private static final int opc_lstore_3 = 66; // private static final int opc_fstore_0 = 67; // private static final int opc_fstore_1 = 68; // private static final int opc_fstore_2 = 69; // private static final int opc_fstore_3 = 70; // private static final int opc_dstore_0 = 71; // private static final int opc_dstore_1 = 72; // private static final int opc_dstore_2 = 73; // private static final int opc_dstore_3 = 74;  private static final int opc_astore_0 = 75; // private static final int opc_astore_1 = 76; // private static final int opc_astore_2 = 77; // private static final int opc_astore_3 = 78; // private static final int opc_iastore = 79; // private static final int opc_lastore = 80; // private static final int opc_fastore = 81; // private static final int opc_dastore = 82;  private static final int opc_aastore = 83; // private static final int opc_bastore = 84; // private static final int opc_castore = 85; // private static final int opc_sastore = 86;  private static final int opc_pop = 87; // private static final int opc_pop2 = 88;  private static final int opc_dup = 89; // private static final int opc_dup_x1 = 90; // private static final int opc_dup_x2 = 91; // private static final int opc_dup2 = 92; // private static final int opc_dup2_x1 = 93; // private static final int opc_dup2_x2 = 94; // private static final int opc_swap = 95; // private static final int opc_iadd = 96; // private static final int opc_ladd = 97; // private static final int opc_fadd = 98; // private static final int opc_dadd = 99; // private static final int opc_isub = 100; // private static final int opc_lsub = 101; // private static final int opc_fsub = 102; // private static final int opc_dsub = 103; // private static final int opc_imul = 104; // private static final int opc_lmul = 105; // private static final int opc_fmul = 106; // private static final int opc_dmul = 107; // private static final int opc_idiv = 108; // private static final int opc_ldiv = 109; // private static final int opc_fdiv = 110; // private static final int opc_ddiv = 111; // private static final int opc_irem = 112; // private static final int opc_lrem = 113; // private static final int opc_frem = 114; // private static final int opc_drem = 115; // private static final int opc_ineg = 116; // private static final int opc_lneg = 117; // private static final int opc_fneg = 118; // private static final int opc_dneg = 119; // private static final int opc_ishl = 120; // private static final int opc_lshl = 121; // private static final int opc_ishr = 122; // private static final int opc_lshr = 123; // private static final int opc_iushr = 124; // private static final int opc_lushr = 125; // private static final int opc_iand = 126; // private static final int opc_land = 127; // private static final int opc_ior = 128; // private static final int opc_lor = 129; // private static final int opc_ixor = 130; // private static final int opc_lxor = 131; // private static final int opc_iinc = 132; // private static final int opc_i2l = 133; // private static final int opc_i2f = 134; // private static final int opc_i2d = 135; // private static final int opc_l2i = 136; // private static final int opc_l2f = 137; // private static final int opc_l2d = 138; // private static final int opc_f2i = 139; // private static final int opc_f2l = 140; // private static final int opc_f2d = 141; // private static final int opc_d2i = 142; // private static final int opc_d2l = 143; // private static final int opc_d2f = 144; // private static final int opc_i2b = 145; // private static final int opc_i2c = 146; // private static final int opc_i2s = 147; // private static final int opc_lcmp = 148; // private static final int opc_fcmpl = 149; // private static final int opc_fcmpg = 150; // private static final int opc_dcmpl = 151; // private static final int opc_dcmpg = 152; // private static final int opc_ifeq = 153; // private static final int opc_ifne = 154; // private static final int opc_iflt = 155; // private static final int opc_ifge = 156; // private static final int opc_ifgt = 157; // private static final int opc_ifle = 158; // private static final int opc_if_icmpeq = 159; // private static final int opc_if_icmpne = 160; // private static final int opc_if_icmplt = 161; // private static final int opc_if_icmpge = 162; // private static final int opc_if_icmpgt = 163; // private static final int opc_if_icmple = 164; // private static final int opc_if_acmpeq = 165; // private static final int opc_if_acmpne = 166; // private static final int opc_goto = 167; // private static final int opc_jsr = 168; // private static final int opc_ret = 169; // private static final int opc_tableswitch = 170; // private static final int opc_lookupswitch = 171;  private static final int opc_ireturn = 172; private static final int opc_lreturn = 173; private static final int opc_freturn = 174; private static final int opc_dreturn = 175; private static final int opc_areturn = 176; private static final int opc_return = 177; private static final int opc_getstatic = 178; private static final int opc_putstatic = 179; private static final int opc_getfield = 180; // private static final int opc_putfield = 181;  private static final int opc_invokevirtual = 182; private static final int opc_invokespecial = 183; private static final int opc_invokestatic = 184; private static final int opc_invokeinterface = 185; private static final int opc_new = 187; // private static final int opc_newarray = 188;  private static final int opc_anewarray = 189; // private static final int opc_arraylength = 190;  private static final int opc_athrow = 191; private static final int opc_checkcast = 192; // private static final int opc_instanceof = 193; // private static final int opc_monitorenter = 194; // private static final int opc_monitorexit = 195;  private static final int opc_wide = 196; // private static final int opc_multianewarray = 197; // private static final int opc_ifnull = 198; // private static final int opc_ifnonnull = 199; // private static final int opc_goto_w = 200; // private static final int opc_jsr_w = 201;  // end of constants copied from sun.tools.java.RuntimeConstants  /** name of the superclass of proxy classes */ private final static String superclassName = &amp;#34;java/lang/reflect/Proxy&amp;#34;; /** name of field for storing a proxy instance&amp;#39;s invocation handler */ private final static String handlerFieldName = &amp;#34;h&amp;#34;; /** debugging flag for saving generated class files */ private final static boolean saveGeneratedFiles = java.security.AccessController.doPrivileged( new GetBooleanAction( &amp;#34;sun.misc.ProxyGenerator.saveGeneratedFiles&amp;#34;)).booleanValue(); /** * Generate a proxy class given a name and a list of proxy interfaces. */ public static byte[] generateProxyClass(final String name, Class[] interfaces) { ProxyGenerator gen = new ProxyGenerator(name, interfaces); final byte[] classFile = gen.generateClassFile(); if (saveGeneratedFiles) { java.security.AccessController.doPrivileged( new java.security.PrivilegedAction&amp;lt;Void&amp;gt;() { public Void run() { try { FileOutputStream file = new FileOutputStream(dotToSlash(name) &#43; &amp;#34;.class&amp;#34;); file.write(classFile); file.close(); return null; } catch (IOException e) { throw new InternalError( &amp;#34;I/O exception saving generated file: &amp;#34; &#43; e); } } }); } return classFile; } /* preloaded Method objects for methods in java.lang.Object */ private static Method hashCodeMethod; private static Method equalsMethod; private static Method toStringMethod; static { try { hashCodeMethod = Object.class.getMethod(&amp;#34;hashCode&amp;#34;); equalsMethod = Object.class.getMethod(&amp;#34;equals&amp;#34;, new Class[] { Object.class }); toStringMethod = Object.class.getMethod(&amp;#34;toString&amp;#34;); } catch (NoSuchMethodException e) { throw new NoSuchMethodError(e.getMessage()); } } /** name of proxy class */ private String className; /** proxy interfaces */ private Class[] interfaces; /** constant pool of class being generated */ private ConstantPool cp = new ConstantPool(); /** FieldInfo struct for each field of generated class */ private List&amp;lt;FieldInfo&amp;gt; fields = new ArrayList&amp;lt;FieldInfo&amp;gt;(); /** MethodInfo struct for each method of generated class */ private List&amp;lt;MethodInfo&amp;gt; methods = new ArrayList&amp;lt;MethodInfo&amp;gt;(); /** * maps method signature string to list of ProxyMethod objects for * proxy methods with that signature */ private Map&amp;lt;String, List&amp;lt;ProxyMethod&amp;gt;&amp;gt; proxyMethods = new HashMap&amp;lt;String,List&amp;lt;ProxyMethod&amp;gt;&amp;gt;(); /** count of ProxyMethod objects added to proxyMethods */ private int proxyMethodCount = 0; /** * Construct a ProxyGenerator to generate a proxy class with the * specified name and for the given interfaces. * * A ProxyGenerator object contains the state for the ongoing * generation of a particular proxy class. */ private ProxyGenerator(String className, Class[] interfaces) { this.className = className; this.interfaces = interfaces; } /** * Generate a class file for the proxy class. This method drives the * class file generation process. */ private byte[] generateClassFile() { /* ============================================================ * Step 1: Assemble ProxyMethod objects for all methods to * generate proxy dispatching code for. */ /* * Record that proxy methods are needed for the hashCode, equals, * and toString methods of java.lang.Object. This is done before * the methods from the proxy interfaces so that the methods from * java.lang.Object take precedence over duplicate methods in the * proxy interfaces. */ addProxyMethod(hashCodeMethod, Object.class); addProxyMethod(equalsMethod, Object.class); addProxyMethod(toStringMethod, Object.class); /* * Now record all of the methods from the proxy interfaces, giving * earlier interfaces precedence over later ones with duplicate * methods. */ for (int i = 0; i &amp;lt; interfaces.length; i&#43;&#43;) { Method[] methods = interfaces[i].getMethods(); for (int j = 0; j &amp;lt; methods.length; j&#43;&#43;) { addProxyMethod(methods[j], interfaces[i]); } } /* * For each set of proxy methods with the same signature, * verify that the methods&amp;#39; return types are compatible. */ for (List&amp;lt;ProxyMethod&amp;gt; sigmethods : proxyMethods.values()) { checkReturnTypes(sigmethods); } /* ============================================================ * Step 2: Assemble FieldInfo and MethodInfo structs for all of * fields and methods in the class we are generating. */ try { methods.add(generateConstructor()); for (List&amp;lt;ProxyMethod&amp;gt; sigmethods : proxyMethods.values()) { for (ProxyMethod pm : sigmethods) { // add static field for method&amp;#39;s Method object  fields.add(new FieldInfo(pm.methodFieldName, &amp;#34;Ljava/lang/reflect/Method;&amp;#34;, ACC_PRIVATE | ACC_STATIC)); // generate code for proxy method and add it  methods.add(pm.generateMethod()); } } methods.add(generateStaticInitializer()); } catch (IOException e) { throw new InternalError(&amp;#34;unexpected I/O Exception&amp;#34;); } if (methods.size() &amp;gt; 65535) { throw new IllegalArgumentException(&amp;#34;method limit exceeded&amp;#34;); } if (fields.size() &amp;gt; 65535) { throw new IllegalArgumentException(&amp;#34;field limit exceeded&amp;#34;); } /* ============================================================ * Step 3: Write the final class file. */ /* * Make sure that constant pool indexes are reserved for the * following items before starting to write the final class file. */ cp.getClass(dotToSlash(className)); cp.getClass(superclassName); for (int i = 0; i &amp;lt; interfaces.length; i&#43;&#43;) { cp.getClass(dotToSlash(interfaces[i].getName())); } /* * Disallow new constant pool additions beyond this point, since * we are about to write the final constant pool table. */ cp.setReadOnly(); ByteArrayOutputStream bout = new ByteArrayOutputStream(); DataOutputStream dout = new DataOutputStream(bout); try { /* * Write all the items of the &amp;#34;ClassFile&amp;#34; structure. * See JVMS section 4.1. */ // u4 magic;  dout.writeInt(0xCAFEBABE); // u2 minor_version;  dout.writeShort(CLASSFILE_MINOR_VERSION); // u2 major_version;  dout.writeShort(CLASSFILE_MAJOR_VERSION); cp.write(dout); // (write constant pool)  // u2 access_flags;  dout.writeShort(ACC_PUBLIC | ACC_FINAL | ACC_SUPER); // u2 this_class;  dout.writeShort(cp.getClass(dotToSlash(className))); // u2 super_class;  dout.writeShort(cp.getClass(superclassName)); // u2 interfaces_count;  dout.writeShort(interfaces.length); // u2 interfaces[interfaces_count];  for (int i = 0; i &amp;lt; interfaces.length; i&#43;&#43;) { dout.writeShort(cp.getClass( dotToSlash(interfaces[i].getName()))); } // u2 fields_count;  dout.writeShort(fields.size()); // field_info fields[fields_count];  for (FieldInfo f : fields) { f.write(dout); } // u2 methods_count;  dout.writeShort(methods.size()); // method_info methods[methods_count];  for (MethodInfo m : methods) { m.write(dout); } // u2 attributes_count;  dout.writeShort(0); // (no ClassFile attributes for proxy classes)  } catch (IOException e) { throw new InternalError(&amp;#34;unexpected I/O Exception&amp;#34;); } return bout.toByteArray(); } /** * Add another method to be proxied, either by creating a new * ProxyMethod object or augmenting an old one for a duplicate * method. * * &amp;#34;fromClass&amp;#34; indicates the proxy interface that the method was * found through, which may be different from (a subinterface of) * the method&amp;#39;s &amp;#34;declaring class&amp;#34;. Note that the first Method * object passed for a given name and descriptor identifies the * Method object (and thus the declaring class) that will be * passed to the invocation handler&amp;#39;s &amp;#34;invoke&amp;#34; method for a given * set of duplicate methods. */ private void addProxyMethod(Method m, Class fromClass) { String name = m.getName(); Class[] parameterTypes = m.getParameterTypes(); Class returnType = m.getReturnType(); Class[] exceptionTypes = m.getExceptionTypes(); String sig = name &#43; getParameterDescriptors(parameterTypes); List&amp;lt;ProxyMethod&amp;gt; sigmethods = proxyMethods.get(sig); if (sigmethods != null) { for (ProxyMethod pm : sigmethods) { if (returnType == pm.returnType) { /* * Found a match: reduce exception types to the * greatest set of exceptions that can thrown * compatibly with the throws clauses of both * overridden methods. */ List&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; legalExceptions = new ArrayList&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt;(); collectCompatibleTypes( exceptionTypes, pm.exceptionTypes, legalExceptions); collectCompatibleTypes( pm.exceptionTypes, exceptionTypes, legalExceptions); pm.exceptionTypes = new Class[legalExceptions.size()]; pm.exceptionTypes = legalExceptions.toArray(pm.exceptionTypes); return; } } } else { sigmethods = new ArrayList&amp;lt;ProxyMethod&amp;gt;(3); proxyMethods.put(sig, sigmethods); } sigmethods.add(new ProxyMethod(name, parameterTypes, returnType, exceptionTypes, fromClass)); } /** * For a given set of proxy methods with the same signature, check * that their return types are compatible according to the Proxy * specification. * * Specifically, if there is more than one such method, then all * of the return types must be reference types, and there must be * one return type that is assignable to each of the rest of them. */ private static void checkReturnTypes(List&amp;lt;ProxyMethod&amp;gt; methods) { /* * If there is only one method with a given signature, there * cannot be a conflict. This is the only case in which a * primitive (or void) return type is allowed. */ if (methods.size() &amp;lt; 2) { return; } /* * List of return types that are not yet known to be * assignable from (&amp;#34;covered&amp;#34; by) any of the others. */ LinkedList&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; uncoveredReturnTypes = new LinkedList&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt;();nextNewReturnType: for (ProxyMethod pm : methods) { Class&amp;lt;?&amp;gt; newReturnType = pm.returnType; if (newReturnType.isPrimitive()) { throw new IllegalArgumentException( &amp;#34;methods with same signature &amp;#34; &#43; getFriendlyMethodSignature(pm.methodName, pm.parameterTypes) &#43; &amp;#34; but incompatible return types: &amp;#34; &#43; newReturnType.getName() &#43; &amp;#34; and others&amp;#34;); } boolean added = false; /* * Compare the new return type to the existing uncovered * return types. */ ListIterator&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; liter = uncoveredReturnTypes.listIterator(); while (liter.hasNext()) { Class&amp;lt;?&amp;gt; uncoveredReturnType = liter.next(); /* * If an existing uncovered return type is assignable * to this new one, then we can forget the new one. */ if (newReturnType.isAssignableFrom(uncoveredReturnType)) { assert !added; continue nextNewReturnType; } /* * If the new return type is assignable to an existing * uncovered one, then should replace the existing one * with the new one (or just forget the existing one, * if the new one has already be put in the list). */ if (uncoveredReturnType.isAssignableFrom(newReturnType)) { // (we can assume that each return type is unique)  if (!added) { liter.set(newReturnType); added = true; } else { liter.remove(); } } } /* * If we got through the list of existing uncovered return * types without an assignability relationship, then add * the new return type to the list of uncovered ones. */ if (!added) { uncoveredReturnTypes.add(newReturnType); } } /* * We shouldn&amp;#39;t end up with more than one return type that is * not assignable from any of the others. */ if (uncoveredReturnTypes.size() &amp;gt; 1) { ProxyMethod pm = methods.get(0); throw new IllegalArgumentException( &amp;#34;methods with same signature &amp;#34; &#43; getFriendlyMethodSignature(pm.methodName, pm.parameterTypes) &#43; &amp;#34; but incompatible return types: &amp;#34; &#43; uncoveredReturnTypes); } } /** * A FieldInfo object contains information about a particular field * in the class being generated. The class mirrors the data items of * the &amp;#34;field_info&amp;#34; structure of the class file format (see JVMS 4.5). */ private class FieldInfo { public int accessFlags; public String name; public String descriptor; public FieldInfo(String name, String descriptor, int accessFlags) { this.name = name; this.descriptor = descriptor; this.accessFlags = accessFlags; /* * Make sure that constant pool indexes are reserved for the * following items before starting to write the final class file. */ cp.getUtf8(name); cp.getUtf8(descriptor); } public void write(DataOutputStream out) throws IOException { /* * Write all the items of the &amp;#34;field_info&amp;#34; structure. * See JVMS section 4.5. */ // u2 access_flags;  out.writeShort(accessFlags); // u2 name_index;  out.writeShort(cp.getUtf8(name)); // u2 descriptor_index;  out.writeShort(cp.getUtf8(descriptor)); // u2 attributes_count;  out.writeShort(0); // (no field_info attributes for proxy classes)  } } /** * An ExceptionTableEntry object holds values for the data items of * an entry in the &amp;#34;exception_table&amp;#34; item of the &amp;#34;Code&amp;#34; attribute of * &amp;#34;method_info&amp;#34; structures (see JVMS 4.7.3). */ private static class ExceptionTableEntry { public short startPc; public short endPc; public short handlerPc; public short catchType; public ExceptionTableEntry(short startPc, short endPc, short handlerPc, short catchType) { this.startPc = startPc; this.endPc = endPc; this.handlerPc = handlerPc; this.catchType = catchType; } }; /** * A MethodInfo object contains information about a particular method * in the class being generated. This class mirrors the data items of * the &amp;#34;method_info&amp;#34; structure of the class file format (see JVMS 4.6). */ private class MethodInfo { public int accessFlags; public String name; public String descriptor; public short maxStack; public short maxLocals; public ByteArrayOutputStream code = new ByteArrayOutputStream(); public List&amp;lt;ExceptionTableEntry&amp;gt; exceptionTable = new ArrayList&amp;lt;ExceptionTableEntry&amp;gt;(); public short[] declaredExceptions; public MethodInfo(String name, String descriptor, int accessFlags) { this.name = name; this.descriptor = descriptor; this.accessFlags = accessFlags; /* * Make sure that constant pool indexes are reserved for the * following items before starting to write the final class file. */ cp.getUtf8(name); cp.getUtf8(descriptor); cp.getUtf8(&amp;#34;Code&amp;#34;); cp.getUtf8(&amp;#34;Exceptions&amp;#34;); } public void write(DataOutputStream out) throws IOException { /* * Write all the items of the &amp;#34;method_info&amp;#34; structure. * See JVMS section 4.6. */ // u2 access_flags;  out.writeShort(accessFlags); // u2 name_index;  out.writeShort(cp.getUtf8(name)); // u2 descriptor_index;  out.writeShort(cp.getUtf8(descriptor)); // u2 attributes_count;  out.writeShort(2); // (two method_info attributes:)  // Write &amp;#34;Code&amp;#34; attribute. See JVMS section 4.7.3.  // u2 attribute_name_index;  out.writeShort(cp.getUtf8(&amp;#34;Code&amp;#34;)); // u4 attribute_length;  out.writeInt(12 &#43; code.size() &#43; 8 * exceptionTable.size()); // u2 max_stack;  out.writeShort(maxStack); // u2 max_locals;  out.writeShort(maxLocals); // u2 code_length;  out.writeInt(code.size()); // u1 code[code_length];  code.writeTo(out); // u2 exception_table_length;  out.writeShort(exceptionTable.size()); for (ExceptionTableEntry e : exceptionTable) { // u2 start_pc;  out.writeShort(e.startPc); // u2 end_pc;  out.writeShort(e.endPc); // u2 handler_pc;  out.writeShort(e.handlerPc); // u2 catch_type;  out.writeShort(e.catchType); } // u2 attributes_count;  out.writeShort(0); // write &amp;#34;Exceptions&amp;#34; attribute. See JVMS section 4.7.4.  // u2 attribute_name_index;  out.writeShort(cp.getUtf8(&amp;#34;Exceptions&amp;#34;)); // u4 attributes_length;  out.writeInt(2 &#43; 2 * declaredExceptions.length); // u2 number_of_exceptions;  out.writeShort(declaredExceptions.length); // u2 exception_index_table[number_of_exceptions];  for (int i = 0; i &amp;lt; declaredExceptions.length; i&#43;&#43;) { out.writeShort(declaredExceptions[i]); } } } /** * A ProxyMethod object represents a proxy method in the proxy class * being generated: a method whose implementation will encode and * dispatch invocations to the proxy instance&amp;#39;s invocation handler. */ private class ProxyMethod { public String methodName; public Class[] parameterTypes; public Class returnType; public Class[] exceptionTypes; public Class fromClass; public String methodFieldName; private ProxyMethod(String methodName, Class[] parameterTypes, Class returnType, Class[] exceptionTypes, Class fromClass) { this.methodName = methodName; this.parameterTypes = parameterTypes; this.returnType = returnType; this.exceptionTypes = exceptionTypes; this.fromClass = fromClass; this.methodFieldName = &amp;#34;m&amp;#34; &#43; proxyMethodCount&#43;&#43;; } /** * Return a MethodInfo object for this method, including generating * the code and exception table entry. */ private MethodInfo generateMethod() throws IOException { String desc = getMethodDescriptor(parameterTypes, returnType); MethodInfo minfo = new MethodInfo(methodName, desc, ACC_PUBLIC | ACC_FINAL); int[] parameterSlot = new int[parameterTypes.length]; int nextSlot = 1; for (int i = 0; i &amp;lt; parameterSlot.length; i&#43;&#43;) { parameterSlot[i] = nextSlot; nextSlot &#43;= getWordsPerType(parameterTypes[i]); } int localSlot0 = nextSlot; short pc, tryBegin = 0, tryEnd; DataOutputStream out = new DataOutputStream(minfo.code); code_aload(0, out); out.writeByte(opc_getfield); out.writeShort(cp.getFieldRef( superclassName, handlerFieldName, &amp;#34;Ljava/lang/reflect/InvocationHandler;&amp;#34;)); code_aload(0, out); out.writeByte(opc_getstatic); out.writeShort(cp.getFieldRef( dotToSlash(className), methodFieldName, &amp;#34;Ljava/lang/reflect/Method;&amp;#34;)); if (parameterTypes.length &amp;gt; 0) { code_ipush(parameterTypes.length, out); out.writeByte(opc_anewarray); out.writeShort(cp.getClass(&amp;#34;java/lang/Object&amp;#34;)); for (int i = 0; i &amp;lt; parameterTypes.length; i&#43;&#43;) { out.writeByte(opc_dup); code_ipush(i, out); codeWrapArgument(parameterTypes[i], parameterSlot[i], out); out.writeByte(opc_aastore); } } else { out.writeByte(opc_aconst_null); } out.writeByte(opc_invokeinterface); out.writeShort(cp.getInterfaceMethodRef( &amp;#34;java/lang/reflect/InvocationHandler&amp;#34;, &amp;#34;invoke&amp;#34;, &amp;#34;(Ljava/lang/Object;Ljava/lang/reflect/Method;&amp;#34; &#43; &amp;#34;[Ljava/lang/Object;)Ljava/lang/Object;&amp;#34;)); out.writeByte(4); out.writeByte(0); if (returnType == void.class) { out.writeByte(opc_pop); out.writeByte(opc_return); } else { codeUnwrapReturnValue(returnType, out); } tryEnd = pc = (short) minfo.code.size(); List&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; catchList = computeUniqueCatchList(exceptionTypes); if (catchList.size() &amp;gt; 0) { for (Class&amp;lt;?&amp;gt; ex : catchList) { minfo.exceptionTable.add(new ExceptionTableEntry( tryBegin, tryEnd, pc, cp.getClass(dotToSlash(ex.getName())))); } out.writeByte(opc_athrow); pc = (short) minfo.code.size(); minfo.exceptionTable.add(new ExceptionTableEntry( tryBegin, tryEnd, pc, cp.getClass(&amp;#34;java/lang/Throwable&amp;#34;))); code_astore(localSlot0, out); out.writeByte(opc_new); out.writeShort(cp.getClass( &amp;#34;java/lang/reflect/UndeclaredThrowableException&amp;#34;)); out.writeByte(opc_dup); code_aload(localSlot0, out); out.writeByte(opc_invokespecial); out.writeShort(cp.getMethodRef( &amp;#34;java/lang/reflect/UndeclaredThrowableException&amp;#34;, &amp;#34;&amp;lt;init&amp;gt;&amp;#34;, &amp;#34;(Ljava/lang/Throwable;)V&amp;#34;)); out.writeByte(opc_athrow); } if (minfo.code.size() &amp;gt; 65535) { throw new IllegalArgumentException(&amp;#34;code size limit exceeded&amp;#34;); } minfo.maxStack = 10; minfo.maxLocals = (short) (localSlot0 &#43; 1); minfo.declaredExceptions = new short[exceptionTypes.length]; for (int i = 0; i &amp;lt; exceptionTypes.length; i&#43;&#43;) { minfo.declaredExceptions[i] = cp.getClass( dotToSlash(exceptionTypes[i].getName())); } return minfo; } /** * Generate code for wrapping an argument of the given type * whose value can be found at the specified local variable * index, in order for it to be passed (as an Object) to the * invocation handler&amp;#39;s &amp;#34;invoke&amp;#34; method. The code is written * to the supplied stream. */ private void codeWrapArgument(Class type, int slot, DataOutputStream out) throws IOException { if (type.isPrimitive()) { PrimitiveTypeInfo prim = PrimitiveTypeInfo.get(type); if (type == int.class || type == boolean.class || type == byte.class || type == char.class || type == short.class) { code_iload(slot, out); } else if (type == long.class) { code_lload(slot, out); } else if (type == float.class) { code_fload(slot, out); } else if (type == double.class) { code_dload(slot, out); } else { throw new AssertionError(); } out.writeByte(opc_invokestatic); out.writeShort(cp.getMethodRef( prim.wrapperClassName, &amp;#34;valueOf&amp;#34;, prim.wrapperValueOfDesc)); } else { code_aload(slot, out); } } /** * Generate code for unwrapping a return value of the given * type from the invocation handler&amp;#39;s &amp;#34;invoke&amp;#34; method (as type * Object) to its correct type. The code is written to the * supplied stream. */ private void codeUnwrapReturnValue(Class type, DataOutputStream out) throws IOException { if (type.isPrimitive()) { PrimitiveTypeInfo prim = PrimitiveTypeInfo.get(type); out.writeByte(opc_checkcast); out.writeShort(cp.getClass(prim.wrapperClassName)); out.writeByte(opc_invokevirtual); out.writeShort(cp.getMethodRef( prim.wrapperClassName, prim.unwrapMethodName, prim.unwrapMethodDesc)); if (type == int.class || type == boolean.class || type == byte.class || type == char.class || type == short.class) { out.writeByte(opc_ireturn); } else if (type == long.class) { out.writeByte(opc_lreturn); } else if (type == float.class) { out.writeByte(opc_freturn); } else if (type == double.class) { out.writeByte(opc_dreturn); } else { throw new AssertionError(); } } else { out.writeByte(opc_checkcast); out.writeShort(cp.getClass(dotToSlash(type.getName()))); out.writeByte(opc_areturn); } } /** * Generate code for initializing the static field that stores * the Method object for this proxy method. The code is written * to the supplied stream. */ private void codeFieldInitialization(DataOutputStream out) throws IOException { codeClassForName(fromClass, out); code_ldc(cp.getString(methodName), out); code_ipush(parameterTypes.length, out); out.writeByte(opc_anewarray); out.writeShort(cp.getClass(&amp;#34;java/lang/Class&amp;#34;)); for (int i = 0; i &amp;lt; parameterTypes.length; i&#43;&#43;) { out.writeByte(opc_dup); code_ipush(i, out); if (parameterTypes[i].isPrimitive()) { PrimitiveTypeInfo prim = PrimitiveTypeInfo.get(parameterTypes[i]); out.writeByte(opc_getstatic); out.writeShort(cp.getFieldRef( prim.wrapperClassName, &amp;#34;TYPE&amp;#34;, &amp;#34;Ljava/lang/Class;&amp;#34;)); } else { codeClassForName(parameterTypes[i], out); } out.writeByte(opc_aastore); } out.writeByte(opc_invokevirtual); out.writeShort(cp.getMethodRef( &amp;#34;java/lang/Class&amp;#34;, &amp;#34;getMethod&amp;#34;, &amp;#34;(Ljava/lang/String;[Ljava/lang/Class;)&amp;#34; &#43; &amp;#34;Ljava/lang/reflect/Method;&amp;#34;)); out.writeByte(opc_putstatic); out.writeShort(cp.getFieldRef( dotToSlash(className), methodFieldName, &amp;#34;Ljava/lang/reflect/Method;&amp;#34;)); } } /** * Generate the constructor method for the proxy class. */ private MethodInfo generateConstructor() throws IOException { MethodInfo minfo = new MethodInfo( &amp;#34;&amp;lt;init&amp;gt;&amp;#34;, &amp;#34;(Ljava/lang/reflect/InvocationHandler;)V&amp;#34;, ACC_PUBLIC); DataOutputStream out = new DataOutputStream(minfo.code); code_aload(0, out); code_aload(1, out); out.writeByte(opc_invokespecial); out.writeShort(cp.getMethodRef( superclassName, &amp;#34;&amp;lt;init&amp;gt;&amp;#34;, &amp;#34;(Ljava/lang/reflect/InvocationHandler;)V&amp;#34;)); out.writeByte(opc_return); minfo.maxStack = 10; minfo.maxLocals = 2; minfo.declaredExceptions = new short[0]; return minfo; } /** * Generate the static initializer method for the proxy class. */ private MethodInfo generateStaticInitializer() throws IOException { MethodInfo minfo = new MethodInfo( &amp;#34;&amp;lt;clinit&amp;gt;&amp;#34;, &amp;#34;()V&amp;#34;, ACC_STATIC); int localSlot0 = 1; short pc, tryBegin = 0, tryEnd; DataOutputStream out = new DataOutputStream(minfo.code); for (List&amp;lt;ProxyMethod&amp;gt; sigmethods : proxyMethods.values()) { for (ProxyMethod pm : sigmethods) { pm.codeFieldInitialization(out); } } out.writeByte(opc_return); tryEnd = pc = (short) minfo.code.size(); minfo.exceptionTable.add(new ExceptionTableEntry( tryBegin, tryEnd, pc, cp.getClass(&amp;#34;java/lang/NoSuchMethodException&amp;#34;))); code_astore(localSlot0, out); out.writeByte(opc_new); out.writeShort(cp.getClass(&amp;#34;java/lang/NoSuchMethodError&amp;#34;)); out.writeByte(opc_dup); code_aload(localSlot0, out); out.writeByte(opc_invokevirtual); out.writeShort(cp.getMethodRef( &amp;#34;java/lang/Throwable&amp;#34;, &amp;#34;getMessage&amp;#34;, &amp;#34;()Ljava/lang/String;&amp;#34;)); out.writeByte(opc_invokespecial); out.writeShort(cp.getMethodRef( &amp;#34;java/lang/NoSuchMethodError&amp;#34;, &amp;#34;&amp;lt;init&amp;gt;&amp;#34;, &amp;#34;(Ljava/lang/String;)V&amp;#34;)); out.writeByte(opc_athrow); pc = (short) minfo.code.size(); minfo.exceptionTable.add(new ExceptionTableEntry( tryBegin, tryEnd, pc, cp.getClass(&amp;#34;java/lang/ClassNotFoundException&amp;#34;))); code_astore(localSlot0, out); out.writeByte(opc_new); out.writeShort(cp.getClass(&amp;#34;java/lang/NoClassDefFoundError&amp;#34;)); out.writeByte(opc_dup); code_aload(localSlot0, out); out.writeByte(opc_invokevirtual); out.writeShort(cp.getMethodRef( &amp;#34;java/lang/Throwable&amp;#34;, &amp;#34;getMessage&amp;#34;, &amp;#34;()Ljava/lang/String;&amp;#34;)); out.writeByte(opc_invokespecial); out.writeShort(cp.getMethodRef( &amp;#34;java/lang/NoClassDefFoundError&amp;#34;, &amp;#34;&amp;lt;init&amp;gt;&amp;#34;, &amp;#34;(Ljava/lang/String;)V&amp;#34;)); out.writeByte(opc_athrow); if (minfo.code.size() &amp;gt; 65535) { throw new IllegalArgumentException(&amp;#34;code size limit exceeded&amp;#34;); } minfo.maxStack = 10; minfo.maxLocals = (short) (localSlot0 &#43; 1); minfo.declaredExceptions = new short[0]; return minfo; } /* * =============== Code Generation Utility Methods =============== */ /* * The following methods generate code for the load or store operation * indicated by their name for the given local variable. The code is * written to the supplied stream. */ private void code_iload(int lvar, DataOutputStream out) throws IOException { codeLocalLoadStore(lvar, opc_iload, opc_iload_0, out); } private void code_lload(int lvar, DataOutputStream out) throws IOException { codeLocalLoadStore(lvar, opc_lload, opc_lload_0, out); } private void code_fload(int lvar, DataOutputStream out) throws IOException { codeLocalLoadStore(lvar, opc_fload, opc_fload_0, out); } private void code_dload(int lvar, DataOutputStream out) throws IOException { codeLocalLoadStore(lvar, opc_dload, opc_dload_0, out); } private void code_aload(int lvar, DataOutputStream out) throws IOException { codeLocalLoadStore(lvar, opc_aload, opc_aload_0, out); } // private void code_istore(int lvar, DataOutputStream out) // throws IOException // { // codeLocalLoadStore(lvar, opc_istore, opc_istore_0, out); // }  // private void code_lstore(int lvar, DataOutputStream out) // throws IOException // { // codeLocalLoadStore(lvar, opc_lstore, opc_lstore_0, out); // }  // private void code_fstore(int lvar, DataOutputStream out) // throws IOException // { // codeLocalLoadStore(lvar, opc_fstore, opc_fstore_0, out); // }  // private void code_dstore(int lvar, DataOutputStream out) // throws IOException // { // codeLocalLoadStore(lvar, opc_dstore, opc_dstore_0, out); // }  private void code_astore(int lvar, DataOutputStream out) throws IOException { codeLocalLoadStore(lvar, opc_astore, opc_astore_0, out); } /** * Generate code for a load or store instruction for the given local * variable. The code is written to the supplied stream. * * &amp;#34;opcode&amp;#34; indicates the opcode form of the desired load or store * instruction that takes an explicit local variable index, and * &amp;#34;opcode_0&amp;#34; indicates the corresponding form of the instruction * with the implicit index 0. */ private void codeLocalLoadStore(int lvar, int opcode, int opcode_0, DataOutputStream out) throws IOException { assert lvar &amp;gt;= 0 &amp;amp;&amp;amp; lvar &amp;lt;= 0xFFFF; if (lvar &amp;lt;= 3) { out.writeByte(opcode_0 &#43; lvar); } else if (lvar &amp;lt;= 0xFF) { out.writeByte(opcode); out.writeByte(lvar &amp;amp; 0xFF); } else { /* * Use the &amp;#34;wide&amp;#34; instruction modifier for local variable * indexes that do not fit into an unsigned byte. */ out.writeByte(opc_wide); out.writeByte(opcode); out.writeShort(lvar &amp;amp; 0xFFFF); } } /** * Generate code for an &amp;#34;ldc&amp;#34; instruction for the given constant pool * index (the &amp;#34;ldc_w&amp;#34; instruction is used if the index does not fit * into an unsigned byte). The code is written to the supplied stream. */ private void code_ldc(int index, DataOutputStream out) throws IOException { assert index &amp;gt;= 0 &amp;amp;&amp;amp; index &amp;lt;= 0xFFFF; if (index &amp;lt;= 0xFF) { out.writeByte(opc_ldc); out.writeByte(index &amp;amp; 0xFF); } else { out.writeByte(opc_ldc_w); out.writeShort(index &amp;amp; 0xFFFF); } } /** * Generate code to push a constant integer value on to the operand * stack, using the &amp;#34;iconst_&amp;lt;i&amp;gt;&amp;#34;, &amp;#34;bipush&amp;#34;, or &amp;#34;sipush&amp;#34; instructions * depending on the size of the value. The code is written to the * supplied stream. */ private void code_ipush(int value, DataOutputStream out) throws IOException { if (value &amp;gt;= -1 &amp;amp;&amp;amp; value &amp;lt;= 5) { out.writeByte(opc_iconst_0 &#43; value); } else if (value &amp;gt;= Byte.MIN_VALUE &amp;amp;&amp;amp; value &amp;lt;= Byte.MAX_VALUE) { out.writeByte(opc_bipush); out.writeByte(value &amp;amp; 0xFF); } else if (value &amp;gt;= Short.MIN_VALUE &amp;amp;&amp;amp; value &amp;lt;= Short.MAX_VALUE) { out.writeByte(opc_sipush); out.writeShort(value &amp;amp; 0xFFFF); } else { throw new AssertionError(); } } /** * Generate code to invoke the Class.forName with the name of the given * class to get its Class object at runtime. The code is written to * the supplied stream. Note that the code generated by this method * may caused the checked ClassNotFoundException to be thrown. */ private void codeClassForName(Class cl, DataOutputStream out) throws IOException { code_ldc(cp.getString(cl.getName()), out); out.writeByte(opc_invokestatic); out.writeShort(cp.getMethodRef( &amp;#34;java/lang/Class&amp;#34;, &amp;#34;forName&amp;#34;, &amp;#34;(Ljava/lang/String;)Ljava/lang/Class;&amp;#34;)); } /* * ==================== General Utility Methods ==================== */ /** * Convert a fully qualified class name that uses &amp;#39;.&amp;#39; as the package * separator, the external representation used by the Java language * and APIs, to a fully qualified class name that uses &amp;#39;/&amp;#39; as the * package separator, the representation used in the class file * format (see JVMS section 4.2). */ private static String dotToSlash(String name) { return name.replace(&amp;#39;.&amp;#39;, &amp;#39;/&amp;#39;); } /** * Return the &amp;#34;method descriptor&amp;#34; string for a method with the given * parameter types and return type. See JVMS section 4.3.3. */ private static String getMethodDescriptor(Class[] parameterTypes, Class returnType) { return getParameterDescriptors(parameterTypes) &#43; ((returnType == void.class) ? &amp;#34;V&amp;#34; : getFieldType(returnType)); } /** * Return the list of &amp;#34;parameter descriptor&amp;#34; strings enclosed in * parentheses corresponding to the given parameter types (in other * words, a method descriptor without a return descriptor). This * string is useful for constructing string keys for methods without * regard to their return type. */ private static String getParameterDescriptors(Class[] parameterTypes) { StringBuilder desc = new StringBuilder(&amp;#34;(&amp;#34;); for (int i = 0; i &amp;lt; parameterTypes.length; i&#43;&#43;) { desc.append(getFieldType(parameterTypes[i])); } desc.append(&amp;#39;)&amp;#39;); return desc.toString(); } /** * Return the &amp;#34;field type&amp;#34; string for the given type, appropriate for * a field descriptor, a parameter descriptor, or a return descriptor * other than &amp;#34;void&amp;#34;. See JVMS section 4.3.2. */ private static String getFieldType(Class type) { if (type.isPrimitive()) { return PrimitiveTypeInfo.get(type).baseTypeString; } else if (type.isArray()) { /* * According to JLS 20.3.2, the getName() method on Class does * return the VM type descriptor format for array classes (only); * using that should be quicker than the otherwise obvious code: * * return &amp;#34;[&amp;#34; &#43; getTypeDescriptor(type.getComponentType()); */ return type.getName().replace(&amp;#39;.&amp;#39;, &amp;#39;/&amp;#39;); } else { return &amp;#34;L&amp;#34; &#43; dotToSlash(type.getName()) &#43; &amp;#34;;&amp;#34;; } } /** * Returns a human-readable string representing the signature of a * method with the given name and parameter types. */ private static String getFriendlyMethodSignature(String name, Class[] parameterTypes) { StringBuilder sig = new StringBuilder(name); sig.append(&amp;#39;(&amp;#39;); for (int i = 0; i &amp;lt; parameterTypes.length; i&#43;&#43;) { if (i &amp;gt; 0) { sig.append(&amp;#39;,&amp;#39;); } Class parameterType = parameterTypes[i]; int dimensions = 0; while (parameterType.isArray()) { parameterType = parameterType.getComponentType(); dimensions&#43;&#43;; } sig.append(parameterType.getName()); while (dimensions-- &amp;gt; 0) { sig.append(&amp;#34;[]&amp;#34;); } } sig.append(&amp;#39;)&amp;#39;); return sig.toString(); } /** * Return the number of abstract &amp;#34;words&amp;#34;, or consecutive local variable * indexes, required to contain a value of the given type. See JVMS * section 3.6.1. * * Note that the original version of the JVMS contained a definition of * this abstract notion of a &amp;#34;word&amp;#34; in section 3.4, but that definition * was removed for the second edition. */ private static int getWordsPerType(Class type) { if (type == long.class || type == double.class) { return 2; } else { return 1; } } /** * Add to the given list all of the types in the &amp;#34;from&amp;#34; array that * are not already contained in the list and are assignable to at * least one of the types in the &amp;#34;with&amp;#34; array. * * This method is useful for computing the greatest common set of * declared exceptions from duplicate methods inherited from * different interfaces. */ private static void collectCompatibleTypes(Class&amp;lt;?&amp;gt;[] from, Class&amp;lt;?&amp;gt;[] with, List&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; list) { for (int i = 0; i &amp;lt; from.length; i&#43;&#43;) { if (!list.contains(from[i])) { for (int j = 0; j &amp;lt; with.length; j&#43;&#43;) { if (with[j].isAssignableFrom(from[i])) { list.add(from[i]); break; } } } } } /** * Given the exceptions declared in the throws clause of a proxy method, * compute the exceptions that need to be caught from the invocation * handler&amp;#39;s invoke method and rethrown intact in the method&amp;#39;s * implementation before catching other Throwables and wrapping them * in UndeclaredThrowableExceptions. * * The exceptions to be caught are returned in a List object. Each * exception in the returned list is guaranteed to not be a subclass of * any of the other exceptions in the list, so the catch blocks for * these exceptions may be generated in any order relative to each other. * * Error and RuntimeException are each always contained by the returned * list (if none of their superclasses are contained), since those * unchecked exceptions should always be rethrown intact, and thus their * subclasses will never appear in the returned list. * * The returned List will be empty if java.lang.Throwable is in the * given list of declared exceptions, indicating that no exceptions * need to be caught. */ private static List&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; computeUniqueCatchList(Class&amp;lt;?&amp;gt;[] exceptions) { List&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; uniqueList = new ArrayList&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt;(); // unique exceptions to catch  uniqueList.add(Error.class); // always catch/rethrow these  uniqueList.add(RuntimeException.class);nextException: for (int i = 0; i &amp;lt; exceptions.length; i&#43;&#43;) { Class&amp;lt;?&amp;gt; ex = exceptions[i]; if (ex.isAssignableFrom(Throwable.class)) { /* * If Throwable is declared to be thrown by the proxy method, * then no catch blocks are necessary, because the invoke * can, at most, throw Throwable anyway. */ uniqueList.clear(); break; } else if (!Throwable.class.isAssignableFrom(ex)) { /* * Ignore types that cannot be thrown by the invoke method. */ continue; } /* * Compare this exception against the current list of * exceptions that need to be caught: */ for (int j = 0; j &amp;lt; uniqueList.size();) { Class&amp;lt;?&amp;gt; ex2 = uniqueList.get(j); if (ex2.isAssignableFrom(ex)) { /* * if a superclass of this exception is already on * the list to catch, then ignore this one and continue; */ continue nextException; } else if (ex.isAssignableFrom(ex2)) { /* * if a subclass of this exception is on the list * to catch, then remove it; */ uniqueList.remove(j); } else { j&#43;&#43;; // else continue comparing.  } } // This exception is unique (so far): add it to the list to catch.  uniqueList.add(ex); } return uniqueList; } /** * A PrimitiveTypeInfo object contains assorted information about * a primitive type in its public fields. The struct for a particular * primitive type can be obtained using the static &amp;#34;get&amp;#34; method. */ private static class PrimitiveTypeInfo { /** &amp;#34;base type&amp;#34; used in various descriptors (see JVMS section 4.3.2) */ public String baseTypeString; /** name of corresponding wrapper class */ public String wrapperClassName; /** method descriptor for wrapper class &amp;#34;valueOf&amp;#34; factory method */ public String wrapperValueOfDesc; /** name of wrapper class method for retrieving primitive value */ public String unwrapMethodName; /** descriptor of same method */ public String unwrapMethodDesc; private static Map&amp;lt;Class,PrimitiveTypeInfo&amp;gt; table = new HashMap&amp;lt;Class,PrimitiveTypeInfo&amp;gt;(); static { add(byte.class, Byte.class); add(char.class, Character.class); add(double.class, Double.class); add(float.class, Float.class); add(int.class, Integer.class); add(long.class, Long.class); add(short.class, Short.class); add(boolean.class, Boolean.class); } private static void add(Class primitiveClass, Class wrapperClass) { table.put(primitiveClass, new PrimitiveTypeInfo(primitiveClass, wrapperClass)); } private PrimitiveTypeInfo(Class primitiveClass, Class wrapperClass) { assert primitiveClass.isPrimitive(); baseTypeString = Array.newInstance(primitiveClass, 0) .getClass().getName().substring(1); wrapperClassName = dotToSlash(wrapperClass.getName()); wrapperValueOfDesc = &amp;#34;(&amp;#34; &#43; baseTypeString &#43; &amp;#34;)L&amp;#34; &#43; wrapperClassName &#43; &amp;#34;;&amp;#34;; unwrapMethodName = primitiveClass.getName() &#43; &amp;#34;Value&amp;#34;; unwrapMethodDesc = &amp;#34;()&amp;#34; &#43; baseTypeString; } public static PrimitiveTypeInfo get(Class cl) { return table.get(cl); } } /** * A ConstantPool object represents the constant pool of a class file * being generated. This representation of a constant pool is designed * specifically for use by ProxyGenerator; in particular, it assumes * that constant pool entries will not need to be resorted (for example, * by their type, as the Java compiler does), so that the final index * value can be assigned and used when an entry is first created. * * Note that new entries cannot be created after the constant pool has * been written to a class file. To prevent such logic errors, a * ConstantPool instance can be marked &amp;#34;read only&amp;#34;, so that further * attempts to add new entries will fail with a runtime exception. * * See JVMS section 4.4 for more information about the constant pool * of a class file. */ private static class ConstantPool { /** * list of constant pool entries, in constant pool index order. * * This list is used when writing the constant pool to a stream * and for assigning the next index value. Note that element 0 * of this list corresponds to constant pool index 1. */ private List&amp;lt;Entry&amp;gt; pool = new ArrayList&amp;lt;Entry&amp;gt;(32); /** * maps constant pool data of all types to constant pool indexes. * * This map is used to look up the index of an existing entry for * values of all types. */ private Map&amp;lt;Object,Short&amp;gt; map = new HashMap&amp;lt;Object,Short&amp;gt;(16); /** true if no new constant pool entries may be added */ private boolean readOnly = false; /** * Get or assign the index for a CONSTANT_Utf8 entry. */ public short getUtf8(String s) { if (s == null) { throw new NullPointerException(); } return getValue(s); } /** * Get or assign the index for a CONSTANT_Integer entry. */ public short getInteger(int i) { return getValue(new Integer(i)); } /** * Get or assign the index for a CONSTANT_Float entry. */ public short getFloat(float f) { return getValue(new Float(f)); } /** * Get or assign the index for a CONSTANT_Class entry. */ public short getClass(String name) { short utf8Index = getUtf8(name); return getIndirect(new IndirectEntry( CONSTANT_CLASS, utf8Index)); } /** * Get or assign the index for a CONSTANT_String entry. */ public short getString(String s) { short utf8Index = getUtf8(s); return getIndirect(new IndirectEntry( CONSTANT_STRING, utf8Index)); } /** * Get or assign the index for a CONSTANT_FieldRef entry. */ public short getFieldRef(String className, String name, String descriptor) { short classIndex = getClass(className); short nameAndTypeIndex = getNameAndType(name, descriptor); return getIndirect(new IndirectEntry( CONSTANT_FIELD, classIndex, nameAndTypeIndex)); } /** * Get or assign the index for a CONSTANT_MethodRef entry. */ public short getMethodRef(String className, String name, String descriptor) { short classIndex = getClass(className); short nameAndTypeIndex = getNameAndType(name, descriptor); return getIndirect(new IndirectEntry( CONSTANT_METHOD, classIndex, nameAndTypeIndex)); } /** * Get or assign the index for a CONSTANT_InterfaceMethodRef entry. */ public short getInterfaceMethodRef(String className, String name, String descriptor) { short classIndex = getClass(className); short nameAndTypeIndex = getNameAndType(name, descriptor); return getIndirect(new IndirectEntry( CONSTANT_INTERFACEMETHOD, classIndex, nameAndTypeIndex)); } /** * Get or assign the index for a CONSTANT_NameAndType entry. */ public short getNameAndType(String name, String descriptor) { short nameIndex = getUtf8(name); short descriptorIndex = getUtf8(descriptor); return getIndirect(new IndirectEntry( CONSTANT_NAMEANDTYPE, nameIndex, descriptorIndex)); } /** * Set this ConstantPool instance to be &amp;#34;read only&amp;#34;. * * After this method has been called, further requests to get * an index for a non-existent entry will cause an InternalError * to be thrown instead of creating of the entry. */ public void setReadOnly() { readOnly = true; } /** * Write this constant pool to a stream as part of * the class file format. * * This consists of writing the &amp;#34;constant_pool_count&amp;#34; and * &amp;#34;constant_pool[]&amp;#34; items of the &amp;#34;ClassFile&amp;#34; structure, as * described in JVMS section 4.1. */ public void write(OutputStream out) throws IOException { DataOutputStream dataOut = new DataOutputStream(out); // constant_pool_count: number of entries plus one  dataOut.writeShort(pool.size() &#43; 1); for (Entry e : pool) { e.write(dataOut); } } /** * Add a new constant pool entry and return its index. */ private short addEntry(Entry entry) { pool.add(entry); /* * Note that this way of determining the index of the * added entry is wrong if this pool supports * CONSTANT_Long or CONSTANT_Double entries. */ if (pool.size() &amp;gt;= 65535) { throw new IllegalArgumentException( &amp;#34;constant pool size limit exceeded&amp;#34;); } return (short) pool.size(); } /** * Get or assign the index for an entry of a type that contains * a direct value. The type of the given object determines the * type of the desired entry as follows: * * java.lang.String CONSTANT_Utf8 * java.lang.Integer CONSTANT_Integer * java.lang.Float CONSTANT_Float * java.lang.Long CONSTANT_Long * java.lang.Double CONSTANT_DOUBLE */ private short getValue(Object key) { Short index = map.get(key); if (index != null) { return index.shortValue(); } else { if (readOnly) { throw new InternalError( &amp;#34;late constant pool addition: &amp;#34; &#43; key); } short i = addEntry(new ValueEntry(key)); map.put(key, new Short(i)); return i; } } /** * Get or assign the index for an entry of a type that contains * references to other constant pool entries. */ private short getIndirect(IndirectEntry e) { Short index = map.get(e); if (index != null) { return index.shortValue(); } else { if (readOnly) { throw new InternalError(&amp;#34;late constant pool addition&amp;#34;); } short i = addEntry(e); map.put(e, new Short(i)); return i; } } /** * Entry is the abstact superclass of all constant pool entry types * that can be stored in the &amp;#34;pool&amp;#34; list; its purpose is to define a * common method for writing constant pool entries to a class file. */ private static abstract class Entry { public abstract void write(DataOutputStream out) throws IOException; } /** * ValueEntry represents a constant pool entry of a type that * contains a direct value (see the comments for the &amp;#34;getValue&amp;#34; * method for a list of such types). * * ValueEntry objects are not used as keys for their entries in the * Map &amp;#34;map&amp;#34;, so no useful hashCode or equals methods are defined. */ private static class ValueEntry extends Entry { private Object value; public ValueEntry(Object value) { this.value = value; } public void write(DataOutputStream out) throws IOException { if (value instanceof String) { out.writeByte(CONSTANT_UTF8); out.writeUTF((String) value); } else if (value instanceof Integer) { out.writeByte(CONSTANT_INTEGER); out.writeInt(((Integer) value).intValue()); } else if (value instanceof Float) { out.writeByte(CONSTANT_FLOAT); out.writeFloat(((Float) value).floatValue()); } else if (value instanceof Long) { out.writeByte(CONSTANT_LONG); out.writeLong(((Long) value).longValue()); } else if (value instanceof Double) { out.writeDouble(CONSTANT_DOUBLE); out.writeDouble(((Double) value).doubleValue()); } else { throw new InternalError(&amp;#34;bogus value entry: &amp;#34; &#43; value); } } } /** * IndirectEntry represents a constant pool entry of a type that * references other constant pool entries, i.e., the following types: * * CONSTANT_Class, CONSTANT_String, CONSTANT_Fieldref, * CONSTANT_Methodref, CONSTANT_InterfaceMethodref, and * CONSTANT_NameAndType. * * Each of these entry types contains either one or two indexes of * other constant pool entries. * * IndirectEntry objects are used as the keys for their entries in * the Map &amp;#34;map&amp;#34;, so the hashCode and equals methods are overridden * to allow matching. */ private static class IndirectEntry extends Entry { private int tag; private short index0; private short index1; /** * Construct an IndirectEntry for a constant pool entry type * that contains one index of another entry. */ public IndirectEntry(int tag, short index) { this.tag = tag; this.index0 = index; this.index1 = 0; } /** * Construct an IndirectEntry for a constant pool entry type * that contains two indexes for other entries. */ public IndirectEntry(int tag, short index0, short index1) { this.tag = tag; this.index0 = index0; this.index1 = index1; } public void write(DataOutputStream out) throws IOException { out.writeByte(tag); out.writeShort(index0); /* * If this entry type contains two indexes, write * out the second, too. */ if (tag == CONSTANT_FIELD || tag == CONSTANT_METHOD || tag == CONSTANT_INTERFACEMETHOD || tag == CONSTANT_NAMEANDTYPE) { out.writeShort(index1); } } public int hashCode() { return tag &#43; index0 &#43; index1; } public boolean equals(Object obj) { if (obj instanceof IndirectEntry) { IndirectEntry other = (IndirectEntry) obj; if (tag == other.tag &amp;amp;&amp;amp; index0 == other.index0 &amp;amp;&amp;amp; index1 == other.index1) { return true; } } return false; } } } } To have an intuitive understanding of the generated class file, we turn on the option of saveGeneratedFiles.
// Target.java package dynamicproxy; public interface Target { void foo(); }// TargetProxyInvocationHandler.java package dynamicproxy; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; public class TargetProxyInvocationHandler implements InvocationHandler { public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { if(&amp;#34;foo&amp;#34;.equals(method.getName())) { System.out.println(&amp;#34;foo invoked&amp;#34;); } return null; } }// Main.java package dynamicproxy; import java.lang.reflect.Proxy; public class Main { public static void main(String[] args) { System.getProperties().put(&amp;#34;sun.misc.ProxyGenerator.saveGeneratedFiles&amp;#34;,&amp;#34;true&amp;#34;); Target b = (Target) Proxy.newProxyInstance(Target.class.getClassLoader(), new Class[] {Target.class}, new TargetProxyInvocationHandler()); System.out.println(b.getClass().toString()); b.foo(); } } And now we can find the generated Proxy class file:
// Proxy.class package com.sun.proxy; import dynamicproxy.Target; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; import java.lang.reflect.UndeclaredThrowableException; public final class $Proxy0 extends Proxy implements Target { private static Method m0; private static Method m1; private static Method m2; private static Method m3; static { try { m0 = Class.forName(&amp;#34;java.lang.Object&amp;#34;).getMethod(&amp;#34;hashCode&amp;#34;, new Class[0]); m1 = Class.forName(&amp;#34;java.lang.Object&amp;#34;).getMethod(&amp;#34;equals&amp;#34;, new Class[]{Class.forName(&amp;#34;java.lang.Object&amp;#34;)}); m2 = Class.forName(&amp;#34;java.lang.Object&amp;#34;).getMethod(&amp;#34;toString&amp;#34;, new Class[0]); m3 = Class.forName(&amp;#34;dynamicproxy.Target&amp;#34;).getMethod(&amp;#34;foo&amp;#34;, new Class[0]); } catch (NoSuchMethodException var2) { throw new NoSuchMethodError(var2.getMessage()); } catch (ClassNotFoundException var3) { throw new NoClassDefFoundError(var3.getMessage()); } } public $Proxy0(InvocationHandler var1) throws { super(var1); } public final int hashCode() throws { try { return ((Integer)super.h.invoke(this, m0, (Object[])null)).intValue(); } catch (RuntimeException | Error var2) { throw var2; } catch (Throwable var3) { throw new UndeclaredThrowableException(var3); } } public final boolean equals(Object var1) throws { try { return ((Boolean)super.h.invoke(this, m1, new Object[]{var1})).booleanValue(); } catch (RuntimeException | Error var3) { throw var3; } catch (Throwable var4) { throw new UndeclaredThrowableException(var4); } } public final String toString() throws { try { return (String)super.h.invoke(this, m2, (Object[])null); } catch (RuntimeException | Error var2) { throw var2; } catch (Throwable var3) { throw new UndeclaredThrowableException(var3); } } public final void foo() throws { try { super.h.invoke(this, m3, (Object[])null); } catch (RuntimeException | Error var2) { throw var2; } catch (Throwable var3) { throw new UndeclaredThrowableException(var3); } } } Implement Dynamic Proxy supporting Class A restriction of the Proxy provided by JDK is that we can only get a proxy for an interface rather than a class.
But can we implement this feature on our own?
Obviously, we need to modify ProxyGenerator to control the generation of the final class as our expectation.
package dynamicproxy.supportclass; import java.io.ByteArrayOutputStream; import java.io.DataOutputStream; import java.io.FileOutputStream; import java.io.IOException; import java.io.OutputStream; import java.lang.reflect.Array; import java.lang.reflect.Method; import java.util.ArrayList; import java.util.HashMap; import java.util.LinkedList; import java.util.List; import java.util.ListIterator; import java.util.Map; import sun.security.action.GetBooleanAction; /** * ProxyGeneratorEx contains the code to generate a dynamic proxy class * for any class. */ public class ProxyGeneratorEx { /* * In the comments below, &amp;#34;JVMS&amp;#34; refers to The Java Virtual Machine * Specification Second Edition and &amp;#34;JLS&amp;#34; refers to the original * version of The Java Language Specification, unless otherwise * specified. */ /* generate 1.5-era class file version */ private static final int CLASSFILE_MAJOR_VERSION = 49; private static final int CLASSFILE_MINOR_VERSION = 0; /* * beginning of constants copied from * sun.tools.java.RuntimeConstants (which no longer exists): */ /* constant pool tags */ private static final int CONSTANT_UTF8 = 1; private static final int CONSTANT_UNICODE = 2; private static final int CONSTANT_INTEGER = 3; private static final int CONSTANT_FLOAT = 4; private static final int CONSTANT_LONG = 5; private static final int CONSTANT_DOUBLE = 6; private static final int CONSTANT_CLASS = 7; private static final int CONSTANT_STRING = 8; private static final int CONSTANT_FIELD = 9; private static final int CONSTANT_METHOD = 10; private static final int CONSTANT_INTERFACEMETHOD = 11; private static final int CONSTANT_NAMEANDTYPE = 12; /* access and modifier flags */ private static final int ACC_PUBLIC = 0x00000001; private static final int ACC_PRIVATE = 0x00000002; // private static final int ACC_PROTECTED = 0x00000004;  private static final int ACC_STATIC = 0x00000008; private static final int ACC_FINAL = 0x00000010; // private static final int ACC_SYNCHRONIZED = 0x00000020; // private static final int ACC_VOLATILE = 0x00000040; // private static final int ACC_TRANSIENT = 0x00000080; // private static final int ACC_NATIVE = 0x00000100; // private static final int ACC_INTERFACE = 0x00000200; // private static final int ACC_ABSTRACT = 0x00000400;  private static final int ACC_SUPER = 0x00000020; // private static final int ACC_STRICT = 0x00000800;  /* opcodes */ // private static final int opc_nop = 0;  private static final int opc_aconst_null = 1; // private static final int opc_iconst_m1 = 2;  private static final int opc_iconst_0 = 3; // private static final int opc_iconst_1 = 4; // private static final int opc_iconst_2 = 5; // private static final int opc_iconst_3 = 6; // private static final int opc_iconst_4 = 7; // private static final int opc_iconst_5 = 8; // private static final int opc_lconst_0 = 9; // private static final int opc_lconst_1 = 10; // private static final int opc_fconst_0 = 11; // private static final int opc_fconst_1 = 12; // private static final int opc_fconst_2 = 13; // private static final int opc_dconst_0 = 14; // private static final int opc_dconst_1 = 15;  private static final int opc_bipush = 16; private static final int opc_sipush = 17; private static final int opc_ldc = 18; private static final int opc_ldc_w = 19; // private static final int opc_ldc2_w = 20;  private static final int opc_iload = 21; private static final int opc_lload = 22; private static final int opc_fload = 23; private static final int opc_dload = 24; private static final int opc_aload = 25; private static final int opc_iload_0 = 26; // private static final int opc_iload_1 = 27; // private static final int opc_iload_2 = 28; // private static final int opc_iload_3 = 29;  private static final int opc_lload_0 = 30; // private static final int opc_lload_1 = 31; // private static final int opc_lload_2 = 32; // private static final int opc_lload_3 = 33;  private static final int opc_fload_0 = 34; // private static final int opc_fload_1 = 35; // private static final int opc_fload_2 = 36; // private static final int opc_fload_3 = 37;  private static final int opc_dload_0 = 38; // private static final int opc_dload_1 = 39; // private static final int opc_dload_2 = 40; // private static final int opc_dload_3 = 41;  private static final int opc_aload_0 = 42; // private static final int opc_aload_1 = 43; // private static final int opc_aload_2 = 44; // private static final int opc_aload_3 = 45; // private static final int opc_iaload = 46; // private static final int opc_laload = 47; // private static final int opc_faload = 48; // private static final int opc_daload = 49; // private static final int opc_aaload = 50; // private static final int opc_baload = 51; // private static final int opc_caload = 52; // private static final int opc_saload = 53; // private static final int opc_istore = 54; // private static final int opc_lstore = 55; // private static final int opc_fstore = 56; // private static final int opc_dstore = 57;  private static final int opc_astore = 58; // private static final int opc_istore_0 = 59; // private static final int opc_istore_1 = 60; // private static final int opc_istore_2 = 61; // private static final int opc_istore_3 = 62; // private static final int opc_lstore_0 = 63; // private static final int opc_lstore_1 = 64; // private static final int opc_lstore_2 = 65; // private static final int opc_lstore_3 = 66; // private static final int opc_fstore_0 = 67; // private static final int opc_fstore_1 = 68; // private static final int opc_fstore_2 = 69; // private static final int opc_fstore_3 = 70; // private static final int opc_dstore_0 = 71; // private static final int opc_dstore_1 = 72; // private static final int opc_dstore_2 = 73; // private static final int opc_dstore_3 = 74;  private static final int opc_astore_0 = 75; // private static final int opc_astore_1 = 76; // private static final int opc_astore_2 = 77; // private static final int opc_astore_3 = 78; // private static final int opc_iastore = 79; // private static final int opc_lastore = 80; // private static final int opc_fastore = 81; // private static final int opc_dastore = 82;  private static final int opc_aastore = 83; // private static final int opc_bastore = 84; // private static final int opc_castore = 85; // private static final int opc_sastore = 86;  private static final int opc_pop = 87; // private static final int opc_pop2 = 88;  private static final int opc_dup = 89; // private static final int opc_dup_x1 = 90; // private static final int opc_dup_x2 = 91; // private static final int opc_dup2 = 92; // private static final int opc_dup2_x1 = 93; // private static final int opc_dup2_x2 = 94; // private static final int opc_swap = 95; // private static final int opc_iadd = 96; // private static final int opc_ladd = 97; // private static final int opc_fadd = 98; // private static final int opc_dadd = 99; // private static final int opc_isub = 100; // private static final int opc_lsub = 101; // private static final int opc_fsub = 102; // private static final int opc_dsub = 103; // private static final int opc_imul = 104; // private static final int opc_lmul = 105; // private static final int opc_fmul = 106; // private static final int opc_dmul = 107; // private static final int opc_idiv = 108; // private static final int opc_ldiv = 109; // private static final int opc_fdiv = 110; // private static final int opc_ddiv = 111; // private static final int opc_irem = 112; // private static final int opc_lrem = 113; // private static final int opc_frem = 114; // private static final int opc_drem = 115; // private static final int opc_ineg = 116; // private static final int opc_lneg = 117; // private static final int opc_fneg = 118; // private static final int opc_dneg = 119; // private static final int opc_ishl = 120; // private static final int opc_lshl = 121; // private static final int opc_ishr = 122; // private static final int opc_lshr = 123; // private static final int opc_iushr = 124; // private static final int opc_lushr = 125; // private static final int opc_iand = 126; // private static final int opc_land = 127; // private static final int opc_ior = 128; // private static final int opc_lor = 129; // private static final int opc_ixor = 130; // private static final int opc_lxor = 131; // private static final int opc_iinc = 132; // private static final int opc_i2l = 133; // private static final int opc_i2f = 134; // private static final int opc_i2d = 135; // private static final int opc_l2i = 136; // private static final int opc_l2f = 137; // private static final int opc_l2d = 138; // private static final int opc_f2i = 139; // private static final int opc_f2l = 140; // private static final int opc_f2d = 141; // private static final int opc_d2i = 142; // private static final int opc_d2l = 143; // private static final int opc_d2f = 144; // private static final int opc_i2b = 145; // private static final int opc_i2c = 146; // private static final int opc_i2s = 147; // private static final int opc_lcmp = 148; // private static final int opc_fcmpl = 149; // private static final int opc_fcmpg = 150; // private static final int opc_dcmpl = 151; // private static final int opc_dcmpg = 152; // private static final int opc_ifeq = 153; // private static final int opc_ifne = 154; // private static final int opc_iflt = 155; // private static final int opc_ifge = 156; // private static final int opc_ifgt = 157; // private static final int opc_ifle = 158; // private static final int opc_if_icmpeq = 159; // private static final int opc_if_icmpne = 160; // private static final int opc_if_icmplt = 161; // private static final int opc_if_icmpge = 162; // private static final int opc_if_icmpgt = 163; // private static final int opc_if_icmple = 164; // private static final int opc_if_acmpeq = 165; // private static final int opc_if_acmpne = 166; // private static final int opc_goto = 167; // private static final int opc_jsr = 168; // private static final int opc_ret = 169; // private static final int opc_tableswitch = 170; // private static final int opc_lookupswitch = 171;  private static final int opc_ireturn = 172; private static final int opc_lreturn = 173; private static final int opc_freturn = 174; private static final int opc_dreturn = 175; private static final int opc_areturn = 176; private static final int opc_return = 177; private static final int opc_getstatic = 178; private static final int opc_putstatic = 179; private static final int opc_getfield = 180; private static final int opc_putfield = 181; private static final int opc_invokevirtual = 182; private static final int opc_invokespecial = 183; private static final int opc_invokestatic = 184; private static final int opc_invokeinterface = 185; private static final int opc_new = 187; // private static final int opc_newarray = 188;  private static final int opc_anewarray = 189; // private static final int opc_arraylength = 190;  private static final int opc_athrow = 191; private static final int opc_checkcast = 192; // private static final int opc_instanceof = 193; // private static final int opc_monitorenter = 194; // private static final int opc_monitorexit = 195;  private static final int opc_wide = 196; // private static final int opc_multianewarray = 197; // private static final int opc_ifnull = 198; // private static final int opc_ifnonnull = 199; // private static final int opc_goto_w = 200; // private static final int opc_jsr_w = 201;  // end of constants copied from sun.tools.java.RuntimeConstants  /** name of the superclass of proxy classes */ private String superclassName; /** name of field for storing a proxy instance&amp;#39;s invocation handler */ private final static String handlerFieldName = &amp;#34;h&amp;#34;; /** debugging flag for saving generated class files */ private final static boolean saveGeneratedFiles = java.security.AccessController.doPrivileged( new GetBooleanAction( &amp;#34;sun.misc.ProxyGeneratorEx.saveGeneratedFiles&amp;#34;)).booleanValue(); /** * Generate a proxy class given a name and a list of proxy interfaces. */ public static byte[] generateProxyClass(final String name, Class superclass, Class[] interfaces) { ProxyGeneratorEx gen = new ProxyGeneratorEx(name, superclass, interfaces); final byte[] classFile = gen.generateClassFile(); if (saveGeneratedFiles) { java.security.AccessController.doPrivileged( new java.security.PrivilegedAction&amp;lt;Void&amp;gt;() { public Void run() { try { FileOutputStream file = new FileOutputStream(dotToSlash(name) &#43; &amp;#34;.class&amp;#34;); file.write(classFile); file.close(); return null; } catch (IOException e) { throw new InternalError( &amp;#34;I/O exception saving generated file: &amp;#34; &#43; e); } } }); } return classFile; } /* preloaded Method objects for methods in java.lang.Object */ private static Method hashCodeMethod; private static Method equalsMethod; private static Method toStringMethod; static { try { hashCodeMethod = Object.class.getMethod(&amp;#34;hashCode&amp;#34;); equalsMethod = Object.class.getMethod(&amp;#34;equals&amp;#34;, new Class[] { Object.class }); toStringMethod = Object.class.getMethod(&amp;#34;toString&amp;#34;); } catch (NoSuchMethodException e) { throw new NoSuchMethodError(e.getMessage()); } } /** name of proxy class */ private String className; /** proxy interfaces */ private Class[] interfaces; /** constant pool of class being generated */ private ConstantPool cp = new ConstantPool(); /** FieldInfo struct for each field of generated class */ private List&amp;lt;FieldInfo&amp;gt; fields = new ArrayList&amp;lt;FieldInfo&amp;gt;(); /** MethodInfo struct for each method of generated class */ private List&amp;lt;MethodInfo&amp;gt; methods = new ArrayList&amp;lt;MethodInfo&amp;gt;(); /** * maps method signature string to list of ProxyMethod objects for * proxy methods with that signature */ private Map&amp;lt;String, List&amp;lt;ProxyMethod&amp;gt;&amp;gt; proxyMethods = new HashMap&amp;lt;String,List&amp;lt;ProxyMethod&amp;gt;&amp;gt;(); /** count of ProxyMethod objects added to proxyMethods */ private int proxyMethodCount = 0; private Class superclass; /** * Construct a ProxyGeneratorEx to generate a proxy class with the * specified name and for the given interfaces. * * A ProxyGeneratorEx object contains the state for the ongoing * generation of a particular proxy class. */ private ProxyGeneratorEx(String className, Class supperclass, Class[] interfaces) { this.className = className; this.superclassName = dotToSlash(supperclass.getName()); this.superclass = supperclass; this.interfaces = interfaces; } /** * Generate a class file for the proxy class. This method drives the * class file generation process. */ private byte[] generateClassFile() { /* ============================================================ * Step 1: Assemble ProxyMethod objects for all methods to * generate proxy dispatching code for. */ /* * Record that proxy methods are needed for the hashCode, equals, * and toString methods of java.lang.Object. This is done before * the methods from the proxy interfaces so that the methods from * java.lang.Object take precedence over duplicate methods in the * proxy interfaces. */ addProxyMethod(hashCodeMethod, Object.class); addProxyMethod(equalsMethod, Object.class); addProxyMethod(toStringMethod, Object.class); /* * Now record all of the methods from the proxy interfaces, giving * earlier interfaces precedence over later ones with duplicate * methods. */ for (int i = 0; i &amp;lt; interfaces.length; i&#43;&#43;) { Method[] methods = interfaces[i].getMethods(); for (int j = 0; j &amp;lt; methods.length; j&#43;&#43;) { addProxyMethod(methods[j], interfaces[i]); } } // Now record all of the methods from the proxy superclass  Method[] superclassMethods = superclass.getDeclaredMethods(); for (int j = 0; j &amp;lt; superclassMethods.length; j&#43;&#43;) { addProxyMethod(superclassMethods[j], superclass); } /* * For each set of proxy methods with the same signature, * verify that the methods&amp;#39; return types are compatible. */ for (List&amp;lt;ProxyMethod&amp;gt; sigmethods : proxyMethods.values()) { checkReturnTypes(sigmethods); } /* ============================================================ * Step 2: Assemble FieldInfo and MethodInfo structs for all of * fields and methods in the class we are generating. */ try { methods.add(generateConstructor()); for (List&amp;lt;ProxyMethod&amp;gt; sigmethods : proxyMethods.values()) { for (ProxyMethod pm : sigmethods) { // add static field for method&amp;#39;s Method object  fields.add(new FieldInfo(pm.methodFieldName, &amp;#34;Ljava/lang/reflect/Method;&amp;#34;, ACC_PRIVATE | ACC_STATIC)); // generate code for proxy method and add it  methods.add(pm.generateMethod()); } } // add field: InvocationHandler  fields.add(new FieldInfo(handlerFieldName, &amp;#34;Ljava/lang/reflect/InvocationHandler;&amp;#34;, ACC_PRIVATE)); methods.add(generateStaticInitializer()); } catch (IOException e) { throw new InternalError(&amp;#34;unexpected I/O Exception&amp;#34;); } if (methods.size() &amp;gt; 65535) { throw new IllegalArgumentException(&amp;#34;method limit exceeded&amp;#34;); } if (fields.size() &amp;gt; 65535) { throw new IllegalArgumentException(&amp;#34;field limit exceeded&amp;#34;); } /* ============================================================ * Step 3: Write the final class file. */ /* * Make sure that constant pool indexes are reserved for the * following items before starting to write the final class file. */ cp.getClass(dotToSlash(className)); cp.getClass(superclassName); for (int i = 0; i &amp;lt; interfaces.length; i&#43;&#43;) { cp.getClass(dotToSlash(interfaces[i].getName())); } /* * Disallow new constant pool additions beyond this point, since * we are about to write the final constant pool table. */ cp.setReadOnly(); ByteArrayOutputStream bout = new ByteArrayOutputStream(); DataOutputStream dout = new DataOutputStream(bout); try { /* * Write all the items of the &amp;#34;ClassFile&amp;#34; structure. * See JVMS section 4.1. */ // u4 magic;  dout.writeInt(0xCAFEBABE); // u2 minor_version;  dout.writeShort(CLASSFILE_MINOR_VERSION); // u2 major_version;  dout.writeShort(CLASSFILE_MAJOR_VERSION); cp.write(dout); // (write constant pool)  // u2 access_flags;  dout.writeShort(ACC_PUBLIC | ACC_FINAL | ACC_SUPER); // u2 this_class;  dout.writeShort(cp.getClass(dotToSlash(className))); // u2 super_class;  dout.writeShort(cp.getClass(superclassName)); // u2 interfaces_count;  dout.writeShort(interfaces.length); // u2 interfaces[interfaces_count];  for (int i = 0; i &amp;lt; interfaces.length; i&#43;&#43;) { dout.writeShort(cp.getClass( dotToSlash(interfaces[i].getName()))); } // u2 fields_count;  dout.writeShort(fields.size()); // field_info fields[fields_count];  for (FieldInfo f : fields) { f.write(dout); } // u2 methods_count;  dout.writeShort(methods.size()); // method_info methods[methods_count];  for (MethodInfo m : methods) { m.write(dout); } // u2 attributes_count;  dout.writeShort(0); // (no ClassFile attributes for proxy classes)  } catch (IOException e) { throw new InternalError(&amp;#34;unexpected I/O Exception&amp;#34;); } return bout.toByteArray(); } /** * Add another method to be proxied, either by creating a new * ProxyMethod object or augmenting an old one for a duplicate * method. * * &amp;#34;fromClass&amp;#34; indicates the proxy interface that the method was * found through, which may be different from (a subinterface of) * the method&amp;#39;s &amp;#34;declaring class&amp;#34;. Note that the first Method * object passed for a given name and descriptor identifies the * Method object (and thus the declaring class) that will be * passed to the invocation handler&amp;#39;s &amp;#34;invoke&amp;#34; method for a given * set of duplicate methods. */ private void addProxyMethod(Method m, Class fromClass) { String name = m.getName(); Class[] parameterTypes = m.getParameterTypes(); Class returnType = m.getReturnType(); Class[] exceptionTypes = m.getExceptionTypes(); String sig = name &#43; getParameterDescriptors(parameterTypes); List&amp;lt;ProxyMethod&amp;gt; sigmethods = proxyMethods.get(sig); if (sigmethods != null) { for (ProxyMethod pm : sigmethods) { if (returnType == pm.returnType) { /* * Found a match: reduce exception types to the * greatest set of exceptions that can thrown * compatibly with the throws clauses of both * overridden methods. */ List&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; legalExceptions = new ArrayList&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt;(); collectCompatibleTypes( exceptionTypes, pm.exceptionTypes, legalExceptions); collectCompatibleTypes( pm.exceptionTypes, exceptionTypes, legalExceptions); pm.exceptionTypes = new Class[legalExceptions.size()]; pm.exceptionTypes = legalExceptions.toArray(pm.exceptionTypes); return; } } } else { sigmethods = new ArrayList&amp;lt;ProxyMethod&amp;gt;(3); proxyMethods.put(sig, sigmethods); } sigmethods.add(new ProxyMethod(name, parameterTypes, returnType, exceptionTypes, fromClass)); } /** * For a given set of proxy methods with the same signature, check * that their return types are compatible according to the Proxy * specification. * * Specifically, if there is more than one such method, then all * of the return types must be reference types, and there must be * one return type that is assignable to each of the rest of them. */ private static void checkReturnTypes(List&amp;lt;ProxyMethod&amp;gt; methods) { /* * If there is only one method with a given signature, there * cannot be a conflict. This is the only case in which a * primitive (or void) return type is allowed. */ if (methods.size() &amp;lt; 2) { return; } /* * List of return types that are not yet known to be * assignable from (&amp;#34;covered&amp;#34; by) any of the others. */ LinkedList&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; uncoveredReturnTypes = new LinkedList&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt;();nextNewReturnType: for (ProxyMethod pm : methods) { Class&amp;lt;?&amp;gt; newReturnType = pm.returnType; if (newReturnType.isPrimitive()) { throw new IllegalArgumentException( &amp;#34;methods with same signature &amp;#34; &#43; getFriendlyMethodSignature(pm.methodName, pm.parameterTypes) &#43; &amp;#34; but incompatible return types: &amp;#34; &#43; newReturnType.getName() &#43; &amp;#34; and others&amp;#34;); } boolean added = false; /* * Compare the new return type to the existing uncovered * return types. */ ListIterator&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; liter = uncoveredReturnTypes.listIterator(); while (liter.hasNext()) { Class&amp;lt;?&amp;gt; uncoveredReturnType = liter.next(); /* * If an existing uncovered return type is assignable * to this new one, then we can forget the new one. */ if (newReturnType.isAssignableFrom(uncoveredReturnType)) { assert !added; continue nextNewReturnType; } /* * If the new return type is assignable to an existing * uncovered one, then should replace the existing one * with the new one (or just forget the existing one, * if the new one has already be put in the list). */ if (uncoveredReturnType.isAssignableFrom(newReturnType)) { // (we can assume that each return type is unique)  if (!added) { liter.set(newReturnType); added = true; } else { liter.remove(); } } } /* * If we got through the list of existing uncovered return * types without an assignability relationship, then add * the new return type to the list of uncovered ones. */ if (!added) { uncoveredReturnTypes.add(newReturnType); } } /* * We shouldn&amp;#39;t end up with more than one return type that is * not assignable from any of the others. */ if (uncoveredReturnTypes.size() &amp;gt; 1) { ProxyMethod pm = methods.get(0); throw new IllegalArgumentException( &amp;#34;methods with same signature &amp;#34; &#43; getFriendlyMethodSignature(pm.methodName, pm.parameterTypes) &#43; &amp;#34; but incompatible return types: &amp;#34; &#43; uncoveredReturnTypes); } } /** * A FieldInfo object contains information about a particular field * in the class being generated. The class mirrors the data items of * the &amp;#34;field_info&amp;#34; structure of the class file format (see JVMS 4.5). */ private class FieldInfo { public int accessFlags; public String name; public String descriptor; public FieldInfo(String name, String descriptor, int accessFlags) { this.name = name; this.descriptor = descriptor; this.accessFlags = accessFlags; /* * Make sure that constant pool indexes are reserved for the * following items before starting to write the final class file. */ cp.getUtf8(name); cp.getUtf8(descriptor); } public void write(DataOutputStream out) throws IOException { /* * Write all the items of the &amp;#34;field_info&amp;#34; structure. * See JVMS section 4.5. */ // u2 access_flags;  out.writeShort(accessFlags); // u2 name_index;  out.writeShort(cp.getUtf8(name)); // u2 descriptor_index;  out.writeShort(cp.getUtf8(descriptor)); // u2 attributes_count;  out.writeShort(0); // (no field_info attributes for proxy classes)  } } /** * An ExceptionTableEntry object holds values for the data items of * an entry in the &amp;#34;exception_table&amp;#34; item of the &amp;#34;Code&amp;#34; attribute of * &amp;#34;method_info&amp;#34; structures (see JVMS 4.7.3). */ private static class ExceptionTableEntry { public short startPc; public short endPc; public short handlerPc; public short catchType; public ExceptionTableEntry(short startPc, short endPc, short handlerPc, short catchType) { this.startPc = startPc; this.endPc = endPc; this.handlerPc = handlerPc; this.catchType = catchType; } }; /** * A MethodInfo object contains information about a particular method * in the class being generated. This class mirrors the data items of * the &amp;#34;method_info&amp;#34; structure of the class file format (see JVMS 4.6). */ private class MethodInfo { public int accessFlags; public String name; public String descriptor; public short maxStack; public short maxLocals; public ByteArrayOutputStream code = new ByteArrayOutputStream(); public List&amp;lt;ExceptionTableEntry&amp;gt; exceptionTable = new ArrayList&amp;lt;ExceptionTableEntry&amp;gt;(); public short[] declaredExceptions; public MethodInfo(String name, String descriptor, int accessFlags) { this.name = name; this.descriptor = descriptor; this.accessFlags = accessFlags; /* * Make sure that constant pool indexes are reserved for the * following items before starting to write the final class file. */ cp.getUtf8(name); cp.getUtf8(descriptor); cp.getUtf8(&amp;#34;Code&amp;#34;); cp.getUtf8(&amp;#34;Exceptions&amp;#34;); } public void write(DataOutputStream out) throws IOException { /* * Write all the items of the &amp;#34;method_info&amp;#34; structure. * See JVMS section 4.6. */ // u2 access_flags;  out.writeShort(accessFlags); // u2 name_index;  out.writeShort(cp.getUtf8(name)); // u2 descriptor_index;  out.writeShort(cp.getUtf8(descriptor)); // u2 attributes_count;  out.writeShort(2); // (two method_info attributes:)  // Write &amp;#34;Code&amp;#34; attribute. See JVMS section 4.7.3.  // u2 attribute_name_index;  out.writeShort(cp.getUtf8(&amp;#34;Code&amp;#34;)); // u4 attribute_length;  out.writeInt(12 &#43; code.size() &#43; 8 * exceptionTable.size()); // u2 max_stack;  out.writeShort(maxStack); // u2 max_locals;  out.writeShort(maxLocals); // u2 code_length;  out.writeInt(code.size()); // u1 code[code_length];  code.writeTo(out); // u2 exception_table_length;  out.writeShort(exceptionTable.size()); for (ExceptionTableEntry e : exceptionTable) { // u2 start_pc;  out.writeShort(e.startPc); // u2 end_pc;  out.writeShort(e.endPc); // u2 handler_pc;  out.writeShort(e.handlerPc); // u2 catch_type;  out.writeShort(e.catchType); } // u2 attributes_count;  out.writeShort(0); // write &amp;#34;Exceptions&amp;#34; attribute. See JVMS section 4.7.4.  // u2 attribute_name_index;  out.writeShort(cp.getUtf8(&amp;#34;Exceptions&amp;#34;)); // u4 attributes_length;  out.writeInt(2 &#43; 2 * declaredExceptions.length); // u2 number_of_exceptions;  out.writeShort(declaredExceptions.length); // u2 exception_index_table[number_of_exceptions];  for (int i = 0; i &amp;lt; declaredExceptions.length; i&#43;&#43;) { out.writeShort(declaredExceptions[i]); } } } /** * A ProxyMethod object represents a proxy method in the proxy class * being generated: a method whose implementation will encode and * dispatch invocations to the proxy instance&amp;#39;s invocation handler. */ private class ProxyMethod { public String methodName; public Class[] parameterTypes; public Class returnType; public Class[] exceptionTypes; public Class fromClass; public String methodFieldName; private ProxyMethod(String methodName, Class[] parameterTypes, Class returnType, Class[] exceptionTypes, Class fromClass) { this.methodName = methodName; this.parameterTypes = parameterTypes; this.returnType = returnType; this.exceptionTypes = exceptionTypes; this.fromClass = fromClass; this.methodFieldName = &amp;#34;m&amp;#34; &#43; proxyMethodCount&#43;&#43;; } /** * Return a MethodInfo object for this method, including generating * the code and exception table entry. */ private MethodInfo generateMethod() throws IOException { String desc = getMethodDescriptor(parameterTypes, returnType); MethodInfo minfo = new MethodInfo(methodName, desc, ACC_PUBLIC | ACC_FINAL); int[] parameterSlot = new int[parameterTypes.length]; int nextSlot = 1; for (int i = 0; i &amp;lt; parameterSlot.length; i&#43;&#43;) { parameterSlot[i] = nextSlot; nextSlot &#43;= getWordsPerType(parameterTypes[i]); } int localSlot0 = nextSlot; short pc, tryBegin = 0, tryEnd; DataOutputStream out = new DataOutputStream(minfo.code); code_aload(0, out); out.writeByte(opc_getfield); out.writeShort(cp.getFieldRef( className, handlerFieldName, &amp;#34;Ljava/lang/reflect/InvocationHandler;&amp;#34;)); code_aload(0, out); out.writeByte(opc_getstatic); out.writeShort(cp.getFieldRef( dotToSlash(className), methodFieldName, &amp;#34;Ljava/lang/reflect/Method;&amp;#34;)); if (parameterTypes.length &amp;gt; 0) { code_ipush(parameterTypes.length, out); out.writeByte(opc_anewarray); out.writeShort(cp.getClass(&amp;#34;java/lang/Object&amp;#34;)); for (int i = 0; i &amp;lt; parameterTypes.length; i&#43;&#43;) { out.writeByte(opc_dup); code_ipush(i, out); codeWrapArgument(parameterTypes[i], parameterSlot[i], out); out.writeByte(opc_aastore); } } else { out.writeByte(opc_aconst_null); } out.writeByte(opc_invokeinterface); out.writeShort(cp.getInterfaceMethodRef( &amp;#34;java/lang/reflect/InvocationHandler&amp;#34;, &amp;#34;invoke&amp;#34;, &amp;#34;(Ljava/lang/Object;Ljava/lang/reflect/Method;&amp;#34; &#43; &amp;#34;[Ljava/lang/Object;)Ljava/lang/Object;&amp;#34;)); out.writeByte(4); out.writeByte(0); if (returnType == void.class) { out.writeByte(opc_pop); out.writeByte(opc_return); } else { codeUnwrapReturnValue(returnType, out); } tryEnd = pc = (short) minfo.code.size(); List&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; catchList = computeUniqueCatchList(exceptionTypes); if (catchList.size() &amp;gt; 0) { for (Class&amp;lt;?&amp;gt; ex : catchList) { minfo.exceptionTable.add(new ExceptionTableEntry( tryBegin, tryEnd, pc, cp.getClass(dotToSlash(ex.getName())))); } out.writeByte(opc_athrow); pc = (short) minfo.code.size(); minfo.exceptionTable.add(new ExceptionTableEntry( tryBegin, tryEnd, pc, cp.getClass(&amp;#34;java/lang/Throwable&amp;#34;))); code_astore(localSlot0, out); out.writeByte(opc_new); out.writeShort(cp.getClass( &amp;#34;java/lang/reflect/UndeclaredThrowableException&amp;#34;)); out.writeByte(opc_dup); code_aload(localSlot0, out); out.writeByte(opc_invokespecial); out.writeShort(cp.getMethodRef( &amp;#34;java/lang/reflect/UndeclaredThrowableException&amp;#34;, &amp;#34;&amp;lt;init&amp;gt;&amp;#34;, &amp;#34;(Ljava/lang/Throwable;)V&amp;#34;)); out.writeByte(opc_athrow); } if (minfo.code.size() &amp;gt; 65535) { throw new IllegalArgumentException(&amp;#34;code size limit exceeded&amp;#34;); } minfo.maxStack = 10; minfo.maxLocals = (short) (localSlot0 &#43; 1); minfo.declaredExceptions = new short[exceptionTypes.length]; for (int i = 0; i &amp;lt; exceptionTypes.length; i&#43;&#43;) { minfo.declaredExceptions[i] = cp.getClass( dotToSlash(exceptionTypes[i].getName())); } return minfo; } /** * Generate code for wrapping an argument of the given type * whose value can be found at the specified local variable * index, in order for it to be passed (as an Object) to the * invocation handler&amp;#39;s &amp;#34;invoke&amp;#34; method. The code is written * to the supplied stream. */ private void codeWrapArgument(Class type, int slot, DataOutputStream out) throws IOException { if (type.isPrimitive()) { PrimitiveTypeInfo prim = PrimitiveTypeInfo.get(type); if (type == int.class || type == boolean.class || type == byte.class || type == char.class || type == short.class) { code_iload(slot, out); } else if (type == long.class) { code_lload(slot, out); } else if (type == float.class) { code_fload(slot, out); } else if (type == double.class) { code_dload(slot, out); } else { throw new AssertionError(); } out.writeByte(opc_invokestatic); out.writeShort(cp.getMethodRef( prim.wrapperClassName, &amp;#34;valueOf&amp;#34;, prim.wrapperValueOfDesc)); } else { code_aload(slot, out); } } /** * Generate code for unwrapping a return value of the given * type from the invocation handler&amp;#39;s &amp;#34;invoke&amp;#34; method (as type * Object) to its correct type. The code is written to the * supplied stream. */ private void codeUnwrapReturnValue(Class type, DataOutputStream out) throws IOException { if (type.isPrimitive()) { PrimitiveTypeInfo prim = PrimitiveTypeInfo.get(type); out.writeByte(opc_checkcast); out.writeShort(cp.getClass(prim.wrapperClassName)); out.writeByte(opc_invokevirtual); out.writeShort(cp.getMethodRef( prim.wrapperClassName, prim.unwrapMethodName, prim.unwrapMethodDesc)); if (type == int.class || type == boolean.class || type == byte.class || type == char.class || type == short.class) { out.writeByte(opc_ireturn); } else if (type == long.class) { out.writeByte(opc_lreturn); } else if (type == float.class) { out.writeByte(opc_freturn); } else if (type == double.class) { out.writeByte(opc_dreturn); } else { throw new AssertionError(); } } else { out.writeByte(opc_checkcast); out.writeShort(cp.getClass(dotToSlash(type.getName()))); out.writeByte(opc_areturn); } } /** * Generate code for initializing the static field that stores * the Method object for this proxy method. The code is written * to the supplied stream. */ private void codeFieldInitialization(DataOutputStream out) throws IOException { codeClassForName(fromClass, out); code_ldc(cp.getString(methodName), out); code_ipush(parameterTypes.length, out); out.writeByte(opc_anewarray); out.writeShort(cp.getClass(&amp;#34;java/lang/Class&amp;#34;)); for (int i = 0; i &amp;lt; parameterTypes.length; i&#43;&#43;) { out.writeByte(opc_dup); code_ipush(i, out); if (parameterTypes[i].isPrimitive()) { PrimitiveTypeInfo prim = PrimitiveTypeInfo.get(parameterTypes[i]); out.writeByte(opc_getstatic); out.writeShort(cp.getFieldRef( prim.wrapperClassName, &amp;#34;TYPE&amp;#34;, &amp;#34;Ljava/lang/Class;&amp;#34;)); } else { codeClassForName(parameterTypes[i], out); } out.writeByte(opc_aastore); } out.writeByte(opc_invokevirtual); out.writeShort(cp.getMethodRef( &amp;#34;java/lang/Class&amp;#34;, &amp;#34;getMethod&amp;#34;, &amp;#34;(Ljava/lang/String;[Ljava/lang/Class;)&amp;#34; &#43; &amp;#34;Ljava/lang/reflect/Method;&amp;#34;)); out.writeByte(opc_putstatic); out.writeShort(cp.getFieldRef( dotToSlash(className), methodFieldName, &amp;#34;Ljava/lang/reflect/Method;&amp;#34;)); } } /** * Generate the constructor method for the proxy class. */ private MethodInfo generateConstructor() throws IOException { MethodInfo minfo = new MethodInfo( &amp;#34;&amp;lt;init&amp;gt;&amp;#34;, &amp;#34;(Ljava/lang/reflect/InvocationHandler;)V&amp;#34;, ACC_PUBLIC); DataOutputStream out = new DataOutputStream(minfo.code); code_aload(0, out); out.writeByte(opc_invokespecial); out.writeShort(cp.getMethodRef( superclassName, &amp;#34;&amp;lt;init&amp;gt;&amp;#34;, &amp;#34;()V&amp;#34;)); code_aload(0, out); code_aload(1, out); // write field h  out.writeByte(opc_putfield); out.writeShort(cp.getFieldRef(className, handlerFieldName, &amp;#34;Ljava/lang/reflect/InvocationHandler;&amp;#34;)); out.writeByte(opc_return); minfo.maxStack = 10; minfo.maxLocals = 2; minfo.declaredExceptions = new short[0]; return minfo; } /** * Generate the static initializer method for the proxy class. */ private MethodInfo generateStaticInitializer() throws IOException { MethodInfo minfo = new MethodInfo( &amp;#34;&amp;lt;clinit&amp;gt;&amp;#34;, &amp;#34;()V&amp;#34;, ACC_STATIC); int localSlot0 = 1; short pc, tryBegin = 0, tryEnd; DataOutputStream out = new DataOutputStream(minfo.code); for (List&amp;lt;ProxyMethod&amp;gt; sigmethods : proxyMethods.values()) { for (ProxyMethod pm : sigmethods) { pm.codeFieldInitialization(out); } } out.writeByte(opc_return); tryEnd = pc = (short) minfo.code.size(); minfo.exceptionTable.add(new ExceptionTableEntry( tryBegin, tryEnd, pc, cp.getClass(&amp;#34;java/lang/NoSuchMethodException&amp;#34;))); code_astore(localSlot0, out); out.writeByte(opc_new); out.writeShort(cp.getClass(&amp;#34;java/lang/NoSuchMethodError&amp;#34;)); out.writeByte(opc_dup); code_aload(localSlot0, out); out.writeByte(opc_invokevirtual); out.writeShort(cp.getMethodRef( &amp;#34;java/lang/Throwable&amp;#34;, &amp;#34;getMessage&amp;#34;, &amp;#34;()Ljava/lang/String;&amp;#34;)); out.writeByte(opc_invokespecial); out.writeShort(cp.getMethodRef( &amp;#34;java/lang/NoSuchMethodError&amp;#34;, &amp;#34;&amp;lt;init&amp;gt;&amp;#34;, &amp;#34;(Ljava/lang/String;)V&amp;#34;)); out.writeByte(opc_athrow); pc = (short) minfo.code.size(); minfo.exceptionTable.add(new ExceptionTableEntry( tryBegin, tryEnd, pc, cp.getClass(&amp;#34;java/lang/ClassNotFoundException&amp;#34;))); code_astore(localSlot0, out); out.writeByte(opc_new); out.writeShort(cp.getClass(&amp;#34;java/lang/NoClassDefFoundError&amp;#34;)); out.writeByte(opc_dup); code_aload(localSlot0, out); out.writeByte(opc_invokevirtual); out.writeShort(cp.getMethodRef( &amp;#34;java/lang/Throwable&amp;#34;, &amp;#34;getMessage&amp;#34;, &amp;#34;()Ljava/lang/String;&amp;#34;)); out.writeByte(opc_invokespecial); out.writeShort(cp.getMethodRef( &amp;#34;java/lang/NoClassDefFoundError&amp;#34;, &amp;#34;&amp;lt;init&amp;gt;&amp;#34;, &amp;#34;(Ljava/lang/String;)V&amp;#34;)); out.writeByte(opc_athrow); if (minfo.code.size() &amp;gt; 65535) { throw new IllegalArgumentException(&amp;#34;code size limit exceeded&amp;#34;); } minfo.maxStack = 10; minfo.maxLocals = (short) (localSlot0 &#43; 1); minfo.declaredExceptions = new short[0]; return minfo; } /* * =============== Code Generation Utility Methods =============== */ /* * The following methods generate code for the load or store operation * indicated by their name for the given local variable. The code is * written to the supplied stream. */ private void code_iload(int lvar, DataOutputStream out) throws IOException { codeLocalLoadStore(lvar, opc_iload, opc_iload_0, out); } private void code_lload(int lvar, DataOutputStream out) throws IOException { codeLocalLoadStore(lvar, opc_lload, opc_lload_0, out); } private void code_fload(int lvar, DataOutputStream out) throws IOException { codeLocalLoadStore(lvar, opc_fload, opc_fload_0, out); } private void code_dload(int lvar, DataOutputStream out) throws IOException { codeLocalLoadStore(lvar, opc_dload, opc_dload_0, out); } private void code_aload(int lvar, DataOutputStream out) throws IOException { codeLocalLoadStore(lvar, opc_aload, opc_aload_0, out); } // private void code_istore(int lvar, DataOutputStream out) // throws IOException // { // codeLocalLoadStore(lvar, opc_istore, opc_istore_0, out); // }  // private void code_lstore(int lvar, DataOutputStream out) // throws IOException // { // codeLocalLoadStore(lvar, opc_lstore, opc_lstore_0, out); // }  // private void code_fstore(int lvar, DataOutputStream out) // throws IOException // { // codeLocalLoadStore(lvar, opc_fstore, opc_fstore_0, out); // }  // private void code_dstore(int lvar, DataOutputStream out) // throws IOException // { // codeLocalLoadStore(lvar, opc_dstore, opc_dstore_0, out); // }  private void code_astore(int lvar, DataOutputStream out) throws IOException { codeLocalLoadStore(lvar, opc_astore, opc_astore_0, out); } /** * Generate code for a load or store instruction for the given local * variable. The code is written to the supplied stream. * * &amp;#34;opcode&amp;#34; indicates the opcode form of the desired load or store * instruction that takes an explicit local variable index, and * &amp;#34;opcode_0&amp;#34; indicates the corresponding form of the instruction * with the implicit index 0. */ private void codeLocalLoadStore(int lvar, int opcode, int opcode_0, DataOutputStream out) throws IOException { assert lvar &amp;gt;= 0 &amp;amp;&amp;amp; lvar &amp;lt;= 0xFFFF; if (lvar &amp;lt;= 3) { out.writeByte(opcode_0 &#43; lvar); } else if (lvar &amp;lt;= 0xFF) { out.writeByte(opcode); out.writeByte(lvar &amp;amp; 0xFF); } else { /* * Use the &amp;#34;wide&amp;#34; instruction modifier for local variable * indexes that do not fit into an unsigned byte. */ out.writeByte(opc_wide); out.writeByte(opcode); out.writeShort(lvar &amp;amp; 0xFFFF); } } /** * Generate code for an &amp;#34;ldc&amp;#34; instruction for the given constant pool * index (the &amp;#34;ldc_w&amp;#34; instruction is used if the index does not fit * into an unsigned byte). The code is written to the supplied stream. */ private void code_ldc(int index, DataOutputStream out) throws IOException { assert index &amp;gt;= 0 &amp;amp;&amp;amp; index &amp;lt;= 0xFFFF; if (index &amp;lt;= 0xFF) { out.writeByte(opc_ldc); out.writeByte(index &amp;amp; 0xFF); } else { out.writeByte(opc_ldc_w); out.writeShort(index &amp;amp; 0xFFFF); } } /** * Generate code to push a constant integer value on to the operand * stack, using the &amp;#34;iconst_&amp;lt;i&amp;gt;&amp;#34;, &amp;#34;bipush&amp;#34;, or &amp;#34;sipush&amp;#34; instructions * depending on the size of the value. The code is written to the * supplied stream. */ private void code_ipush(int value, DataOutputStream out) throws IOException { if (value &amp;gt;= -1 &amp;amp;&amp;amp; value &amp;lt;= 5) { out.writeByte(opc_iconst_0 &#43; value); } else if (value &amp;gt;= Byte.MIN_VALUE &amp;amp;&amp;amp; value &amp;lt;= Byte.MAX_VALUE) { out.writeByte(opc_bipush); out.writeByte(value &amp;amp; 0xFF); } else if (value &amp;gt;= Short.MIN_VALUE &amp;amp;&amp;amp; value &amp;lt;= Short.MAX_VALUE) { out.writeByte(opc_sipush); out.writeShort(value &amp;amp; 0xFFFF); } else { throw new AssertionError(); } } /** * Generate code to invoke the Class.forName with the name of the given * class to get its Class object at runtime. The code is written to * the supplied stream. Note that the code generated by this method * may caused the checked ClassNotFoundException to be thrown. */ private void codeClassForName(Class cl, DataOutputStream out) throws IOException { code_ldc(cp.getString(cl.getName()), out); out.writeByte(opc_invokestatic); out.writeShort(cp.getMethodRef( &amp;#34;java/lang/Class&amp;#34;, &amp;#34;forName&amp;#34;, &amp;#34;(Ljava/lang/String;)Ljava/lang/Class;&amp;#34;)); } /* * ==================== General Utility Methods ==================== */ /** * Convert a fully qualified class name that uses &amp;#39;.&amp;#39; as the package * separator, the external representation used by the Java language * and APIs, to a fully qualified class name that uses &amp;#39;/&amp;#39; as the * package separator, the representation used in the class file * format (see JVMS section 4.2). */ private static String dotToSlash(String name) { return name.replace(&amp;#39;.&amp;#39;, &amp;#39;/&amp;#39;); } /** * Return the &amp;#34;method descriptor&amp;#34; string for a method with the given * parameter types and return type. See JVMS section 4.3.3. */ private static String getMethodDescriptor(Class[] parameterTypes, Class returnType) { return getParameterDescriptors(parameterTypes) &#43; ((returnType == void.class) ? &amp;#34;V&amp;#34; : getFieldType(returnType)); } /** * Return the list of &amp;#34;parameter descriptor&amp;#34; strings enclosed in * parentheses corresponding to the given parameter types (in other * words, a method descriptor without a return descriptor). This * string is useful for constructing string keys for methods without * regard to their return type. */ private static String getParameterDescriptors(Class[] parameterTypes) { StringBuilder desc = new StringBuilder(&amp;#34;(&amp;#34;); for (int i = 0; i &amp;lt; parameterTypes.length; i&#43;&#43;) { desc.append(getFieldType(parameterTypes[i])); } desc.append(&amp;#39;)&amp;#39;); return desc.toString(); } /** * Return the &amp;#34;field type&amp;#34; string for the given type, appropriate for * a field descriptor, a parameter descriptor, or a return descriptor * other than &amp;#34;void&amp;#34;. See JVMS section 4.3.2. */ private static String getFieldType(Class type) { if (type.isPrimitive()) { return PrimitiveTypeInfo.get(type).baseTypeString; } else if (type.isArray()) { /* * According to JLS 20.3.2, the getName() method on Class does * return the VM type descriptor format for array classes (only); * using that should be quicker than the otherwise obvious code: * * return &amp;#34;[&amp;#34; &#43; getTypeDescriptor(type.getComponentType()); */ return type.getName().replace(&amp;#39;.&amp;#39;, &amp;#39;/&amp;#39;); } else { return &amp;#34;L&amp;#34; &#43; dotToSlash(type.getName()) &#43; &amp;#34;;&amp;#34;; } } /** * Returns a human-readable string representing the signature of a * method with the given name and parameter types. */ private static String getFriendlyMethodSignature(String name, Class[] parameterTypes) { StringBuilder sig = new StringBuilder(name); sig.append(&amp;#39;(&amp;#39;); for (int i = 0; i &amp;lt; parameterTypes.length; i&#43;&#43;) { if (i &amp;gt; 0) { sig.append(&amp;#39;,&amp;#39;); } Class parameterType = parameterTypes[i]; int dimensions = 0; while (parameterType.isArray()) { parameterType = parameterType.getComponentType(); dimensions&#43;&#43;; } sig.append(parameterType.getName()); while (dimensions-- &amp;gt; 0) { sig.append(&amp;#34;[]&amp;#34;); } } sig.append(&amp;#39;)&amp;#39;); return sig.toString(); } /** * Return the number of abstract &amp;#34;words&amp;#34;, or consecutive local variable * indexes, required to contain a value of the given type. See JVMS * section 3.6.1. * * Note that the original version of the JVMS contained a definition of * this abstract notion of a &amp;#34;word&amp;#34; in section 3.4, but that definition * was removed for the second edition. */ private static int getWordsPerType(Class type) { if (type == long.class || type == double.class) { return 2; } else { return 1; } } /** * Add to the given list all of the types in the &amp;#34;from&amp;#34; array that * are not already contained in the list and are assignable to at * least one of the types in the &amp;#34;with&amp;#34; array. * * This method is useful for computing the greatest common set of * declared exceptions from duplicate methods inherited from * different interfaces. */ private static void collectCompatibleTypes(Class&amp;lt;?&amp;gt;[] from, Class&amp;lt;?&amp;gt;[] with, List&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; list) { for (int i = 0; i &amp;lt; from.length; i&#43;&#43;) { if (!list.contains(from[i])) { for (int j = 0; j &amp;lt; with.length; j&#43;&#43;) { if (with[j].isAssignableFrom(from[i])) { list.add(from[i]); break; } } } } } /** * Given the exceptions declared in the throws clause of a proxy method, * compute the exceptions that need to be caught from the invocation * handler&amp;#39;s invoke method and rethrown intact in the method&amp;#39;s * implementation before catching other Throwables and wrapping them * in UndeclaredThrowableExceptions. * * The exceptions to be caught are returned in a List object. Each * exception in the returned list is guaranteed to not be a subclass of * any of the other exceptions in the list, so the catch blocks for * these exceptions may be generated in any order relative to each other. * * Error and RuntimeException are each always contained by the returned * list (if none of their superclasses are contained), since those * unchecked exceptions should always be rethrown intact, and thus their * subclasses will never appear in the returned list. * * The returned List will be empty if java.lang.Throwable is in the * given list of declared exceptions, indicating that no exceptions * need to be caught. */ private static List&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; computeUniqueCatchList(Class&amp;lt;?&amp;gt;[] exceptions) { List&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; uniqueList = new ArrayList&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt;(); // unique exceptions to catch  uniqueList.add(Error.class); // always catch/rethrow these  uniqueList.add(RuntimeException.class);nextException: for (int i = 0; i &amp;lt; exceptions.length; i&#43;&#43;) { Class&amp;lt;?&amp;gt; ex = exceptions[i]; if (ex.isAssignableFrom(Throwable.class)) { /* * If Throwable is declared to be thrown by the proxy method, * then no catch blocks are necessary, because the invoke * can, at most, throw Throwable anyway. */ uniqueList.clear(); break; } else if (!Throwable.class.isAssignableFrom(ex)) { /* * Ignore types that cannot be thrown by the invoke method. */ continue; } /* * Compare this exception against the current list of * exceptions that need to be caught: */ for (int j = 0; j &amp;lt; uniqueList.size();) { Class&amp;lt;?&amp;gt; ex2 = uniqueList.get(j); if (ex2.isAssignableFrom(ex)) { /* * if a superclass of this exception is already on * the list to catch, then ignore this one and continue; */ continue nextException; } else if (ex.isAssignableFrom(ex2)) { /* * if a subclass of this exception is on the list * to catch, then remove it; */ uniqueList.remove(j); } else { j&#43;&#43;; // else continue comparing.  } } // This exception is unique (so far): add it to the list to catch.  uniqueList.add(ex); } return uniqueList; } /** * A PrimitiveTypeInfo object contains assorted information about * a primitive type in its public fields. The struct for a particular * primitive type can be obtained using the static &amp;#34;get&amp;#34; method. */ private static class PrimitiveTypeInfo { /** &amp;#34;base type&amp;#34; used in various descriptors (see JVMS section 4.3.2) */ public String baseTypeString; /** name of corresponding wrapper class */ public String wrapperClassName; /** method descriptor for wrapper class &amp;#34;valueOf&amp;#34; factory method */ public String wrapperValueOfDesc; /** name of wrapper class method for retrieving primitive value */ public String unwrapMethodName; /** descriptor of same method */ public String unwrapMethodDesc; private static Map&amp;lt;Class,PrimitiveTypeInfo&amp;gt; table = new HashMap&amp;lt;Class,PrimitiveTypeInfo&amp;gt;(); static { add(byte.class, Byte.class); add(char.class, Character.class); add(double.class, Double.class); add(float.class, Float.class); add(int.class, Integer.class); add(long.class, Long.class); add(short.class, Short.class); add(boolean.class, Boolean.class); } private static void add(Class primitiveClass, Class wrapperClass) { table.put(primitiveClass, new PrimitiveTypeInfo(primitiveClass, wrapperClass)); } private PrimitiveTypeInfo(Class primitiveClass, Class wrapperClass) { assert primitiveClass.isPrimitive(); baseTypeString = Array.newInstance(primitiveClass, 0) .getClass().getName().substring(1); wrapperClassName = dotToSlash(wrapperClass.getName()); wrapperValueOfDesc = &amp;#34;(&amp;#34; &#43; baseTypeString &#43; &amp;#34;)L&amp;#34; &#43; wrapperClassName &#43; &amp;#34;;&amp;#34;; unwrapMethodName = primitiveClass.getName() &#43; &amp;#34;Value&amp;#34;; unwrapMethodDesc = &amp;#34;()&amp;#34; &#43; baseTypeString; } public static PrimitiveTypeInfo get(Class cl) { return table.get(cl); } } /** * A ConstantPool object represents the constant pool of a class file * being generated. This representation of a constant pool is designed * specifically for use by ProxyGeneratorEx; in particular, it assumes * that constant pool entries will not need to be resorted (for example, * by their type, as the Java compiler does), so that the final index * value can be assigned and used when an entry is first created. * * Note that new entries cannot be created after the constant pool has * been written to a class file. To prevent such logic errors, a * ConstantPool instance can be marked &amp;#34;read only&amp;#34;, so that further * attempts to add new entries will fail with a runtime exception. * * See JVMS section 4.4 for more information about the constant pool * of a class file. */ private static class ConstantPool { /** * list of constant pool entries, in constant pool index order. * * This list is used when writing the constant pool to a stream * and for assigning the next index value. Note that element 0 * of this list corresponds to constant pool index 1. */ private List&amp;lt;Entry&amp;gt; pool = new ArrayList&amp;lt;Entry&amp;gt;(32); /** * maps constant pool data of all types to constant pool indexes. * * This map is used to look up the index of an existing entry for * values of all types. */ private Map&amp;lt;Object,Short&amp;gt; map = new HashMap&amp;lt;Object,Short&amp;gt;(16); /** true if no new constant pool entries may be added */ private boolean readOnly = false; /** * Get or assign the index for a CONSTANT_Utf8 entry. */ public short getUtf8(String s) { if (s == null) { throw new NullPointerException(); } return getValue(s); } /** * Get or assign the index for a CONSTANT_Integer entry. */ public short getInteger(int i) { return getValue(new Integer(i)); } /** * Get or assign the index for a CONSTANT_Float entry. */ public short getFloat(float f) { return getValue(new Float(f)); } /** * Get or assign the index for a CONSTANT_Class entry. */ public short getClass(String name) { short utf8Index = getUtf8(name); return getIndirect(new IndirectEntry( CONSTANT_CLASS, utf8Index)); } /** * Get or assign the index for a CONSTANT_String entry. */ public short getString(String s) { short utf8Index = getUtf8(s); return getIndirect(new IndirectEntry( CONSTANT_STRING, utf8Index)); } /** * Get or assign the index for a CONSTANT_FieldRef entry. */ public short getFieldRef(String className, String name, String descriptor) { short classIndex = getClass(className); short nameAndTypeIndex = getNameAndType(name, descriptor); return getIndirect(new IndirectEntry( CONSTANT_FIELD, classIndex, nameAndTypeIndex)); } /** * Get or assign the index for a CONSTANT_MethodRef entry. */ public short getMethodRef(String className, String name, String descriptor) { short classIndex = getClass(className); short nameAndTypeIndex = getNameAndType(name, descriptor); return getIndirect(new IndirectEntry( CONSTANT_METHOD, classIndex, nameAndTypeIndex)); } /** * Get or assign the index for a CONSTANT_InterfaceMethodRef entry. */ public short getInterfaceMethodRef(String className, String name, String descriptor) { short classIndex = getClass(className); short nameAndTypeIndex = getNameAndType(name, descriptor); return getIndirect(new IndirectEntry( CONSTANT_INTERFACEMETHOD, classIndex, nameAndTypeIndex)); } /** * Get or assign the index for a CONSTANT_NameAndType entry. */ public short getNameAndType(String name, String descriptor) { short nameIndex = getUtf8(name); short descriptorIndex = getUtf8(descriptor); return getIndirect(new IndirectEntry( CONSTANT_NAMEANDTYPE, nameIndex, descriptorIndex)); } /** * Set this ConstantPool instance to be &amp;#34;read only&amp;#34;. * * After this method has been called, further requests to get * an index for a non-existent entry will cause an InternalError * to be thrown instead of creating of the entry. */ public void setReadOnly() { readOnly = true; } /** * Write this constant pool to a stream as part of * the class file format. * * This consists of writing the &amp;#34;constant_pool_count&amp;#34; and * &amp;#34;constant_pool[]&amp;#34; items of the &amp;#34;ClassFile&amp;#34; structure, as * described in JVMS section 4.1. */ public void write(OutputStream out) throws IOException { DataOutputStream dataOut = new DataOutputStream(out); // constant_pool_count: number of entries plus one  dataOut.writeShort(pool.size() &#43; 1); for (Entry e : pool) { e.write(dataOut); } } /** * Add a new constant pool entry and return its index. */ private short addEntry(Entry entry) { pool.add(entry); /* * Note that this way of determining the index of the * added entry is wrong if this pool supports * CONSTANT_Long or CONSTANT_Double entries. */ if (pool.size() &amp;gt;= 65535) { throw new IllegalArgumentException( &amp;#34;constant pool size limit exceeded&amp;#34;); } return (short) pool.size(); } /** * Get or assign the index for an entry of a type that contains * a direct value. The type of the given object determines the * type of the desired entry as follows: * * java.lang.String CONSTANT_Utf8 * java.lang.Integer CONSTANT_Integer * java.lang.Float CONSTANT_Float * java.lang.Long CONSTANT_Long * java.lang.Double CONSTANT_DOUBLE */ private short getValue(Object key) { Short index = map.get(key); if (index != null) { return index.shortValue(); } else { if (readOnly) { throw new InternalError( &amp;#34;late constant pool addition: &amp;#34; &#43; key); } short i = addEntry(new ValueEntry(key)); map.put(key, new Short(i)); return i; } } /** * Get or assign the index for an entry of a type that contains * references to other constant pool entries. */ private short getIndirect(IndirectEntry e) { Short index = map.get(e); if (index != null) { return index.shortValue(); } else { if (readOnly) { throw new InternalError(&amp;#34;late constant pool addition&amp;#34;); } short i = addEntry(e); map.put(e, new Short(i)); return i; } } /** * Entry is the abstact superclass of all constant pool entry types * that can be stored in the &amp;#34;pool&amp;#34; list; its purpose is to define a * common method for writing constant pool entries to a class file. */ private static abstract class Entry { public abstract void write(DataOutputStream out) throws IOException; } /** * ValueEntry represents a constant pool entry of a type that * contains a direct value (see the comments for the &amp;#34;getValue&amp;#34; * method for a list of such types). * * ValueEntry objects are not used as keys for their entries in the * Map &amp;#34;map&amp;#34;, so no useful hashCode or equals methods are defined. */ private static class ValueEntry extends Entry { private Object value; public ValueEntry(Object value) { this.value = value; } public void write(DataOutputStream out) throws IOException { if (value instanceof String) { out.writeByte(CONSTANT_UTF8); out.writeUTF((String) value); } else if (value instanceof Integer) { out.writeByte(CONSTANT_INTEGER); out.writeInt(((Integer) value).intValue()); } else if (value instanceof Float) { out.writeByte(CONSTANT_FLOAT); out.writeFloat(((Float) value).floatValue()); } else if (value instanceof Long) { out.writeByte(CONSTANT_LONG); out.writeLong(((Long) value).longValue()); } else if (value instanceof Double) { out.writeDouble(CONSTANT_DOUBLE); out.writeDouble(((Double) value).doubleValue()); } else { throw new InternalError(&amp;#34;bogus value entry: &amp;#34; &#43; value); } } } /** * IndirectEntry represents a constant pool entry of a type that * references other constant pool entries, i.e., the following types: * * CONSTANT_Class, CONSTANT_String, CONSTANT_Fieldref, * CONSTANT_Methodref, CONSTANT_InterfaceMethodref, and * CONSTANT_NameAndType. * * Each of these entry types contains either one or two indexes of * other constant pool entries. * * IndirectEntry objects are used as the keys for their entries in * the Map &amp;#34;map&amp;#34;, so the hashCode and equals methods are overridden * to allow matching. */ private static class IndirectEntry extends Entry { private int tag; private short index0; private short index1; /** * Construct an IndirectEntry for a constant pool entry type * that contains one index of another entry. */ public IndirectEntry(int tag, short index) { this.tag = tag; this.index0 = index; this.index1 = 0; } /** * Construct an IndirectEntry for a constant pool entry type * that contains two indexes for other entries. */ public IndirectEntry(int tag, short index0, short index1) { this.tag = tag; this.index0 = index0; this.index1 = index1; } public void write(DataOutputStream out) throws IOException { out.writeByte(tag); out.writeShort(index0); /* * If this entry type contains two indexes, write * out the second, too. */ if (tag == CONSTANT_FIELD || tag == CONSTANT_METHOD || tag == CONSTANT_INTERFACEMETHOD || tag == CONSTANT_NAMEANDTYPE) { out.writeShort(index1); } } public int hashCode() { return tag &#43; index0 &#43; index1; } public boolean equals(Object obj) { if (obj instanceof IndirectEntry) { IndirectEntry other = (IndirectEntry) obj; if (tag == other.tag &amp;amp;&amp;amp; index0 == other.index0 &amp;amp;&amp;amp; index1 == other.index1) { return true; } } return false; } } } } And this is the modified Proxy which I name ProxyEx:
// ProxyEx.java package dynamicproxy.supportclass; import java.lang.reflect.*; public class ProxyEx { public static Class&amp;lt;?&amp;gt; getProxyClass(ClassLoader loader, Class&amp;lt;?&amp;gt; superclass, Class&amp;lt;?&amp;gt;... interfaces) { byte[] bytes = ProxyGeneratorEx.generateProxyClass(superclass.getSimpleName() &#43; &amp;#34;$&amp;#34;, superclass, interfaces); return defineClass0(loader, &amp;#34;$Dog&amp;#34;, bytes, 0, bytes.length); } /** * TODO: no class cache support and no class name generation * * @param loader * @param superclass * @param interfaces * @param h * @return */ public static Object newProxyInstance(ClassLoader loader, Class&amp;lt;?&amp;gt; superclass, Class&amp;lt;?&amp;gt;[] interfaces, InvocationHandler h) { Class&amp;lt;?&amp;gt; proxyClass = getProxyClass(loader, superclass, interfaces); try { Constructor constructor = proxyClass.getConstructor(InvocationHandler.class); constructor.setAccessible(true); return constructor.newInstance(h); } catch (NoSuchMethodException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InstantiationException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } return null; } private static Class&amp;lt;?&amp;gt; defineClass0(ClassLoader loader, String name, byte[] b, int off, int len) { Class proxyClass = Proxy.class; try { Method defineClass0Method = proxyClass.getDeclaredMethod(&amp;#34;defineClass0&amp;#34;, ClassLoader.class, String.class, byte[].class, int.class, int.class); defineClass0Method.setAccessible(true); return (Class&amp;lt;?&amp;gt;) defineClass0Method.invoke(null, loader, name, b, off, len); } catch (NoSuchMethodException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } return null; } } Now let&amp;rsquo;s get a try with our dynamic proxy.
// Dog.java package dynamicproxy.supportclass; public class Dog { public void bark(){} }// DogInvocationHandler.java package dynamicproxy.supportclass; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; public class DogInvocationHandler implements InvocationHandler { public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { if(&amp;#34;bark&amp;#34;.equals(method.getName())) { System.out.println(&amp;#34;dog barked&amp;#34;); } return null; } }// Main.java package dynamicproxy.supportclass; public class Main { public static void main(String[] args) { System.getProperties().put(&amp;#34;sun.misc.ProxyGeneratorEx.saveGeneratedFiles&amp;#34;,&amp;#34;true&amp;#34;); // Class aClass = ProxyEx.getProxyClass(A.class.getClassLoader(), A.class, new Class[]{});  Dog dog = (Dog) ProxyEx.newProxyInstance(Dog.class.getClassLoader(), Dog.class, new Class[0], new DogInvocationHandler()); dog.bark(); } } Here you should see the console will print &amp;ldquo;dog barked&amp;rdquo;.
</content>
    </entry>
    
     <entry>
        <title>DbVisualizer Tips</title>
        <url>http://yangchao.me/post/dbvisualizer-tips/</url>
        <categories>
          
        </categories>
        <tags>
          
        </tags>
        <content type="html">  DbVisualizer Tips  How do we execute stored procedure? use @call stored_procedure_name;
 Parameterize SQL with variables Write your SQL as select * from table1 where a = ${param}$ Execute it and the &amp;ldquo;Enter data for variables&amp;rdquo; window will pop up.
 Parameterize SQL with markers Write your SQL as select * from table1 where a = :marker Execute it and the &amp;ldquo;Enter data for markers&amp;rdquo; window will pop up.
 How do we render the query result as chart? In the result panel, there is a button &amp;ldquo;show as chat&amp;rdquo;, click it and there is also a setting window from where you can configure the way the data is shown.
 DbVis can get the query Explain Plan.
  </content>
    </entry>
    
     <entry>
        <title>Understand when to rollback</title>
        <url>http://yangchao.me/post/understand-when-to-rollback/</url>
        <categories>
          
        </categories>
        <tags>
          
        </tags>
        <content type="html">  Prepare At first, I create a table:
CREATE TABLE &amp;#34;SYSTEM&amp;#34;.&amp;#34;TEST&amp;#34; (	&amp;#34;ID&amp;#34; NUMBER(*,0), &amp;#34;NAME&amp;#34; VARCHAR2(200 BYTE), CONSTRAINT &amp;#34;TEST_PK&amp;#34; PRIMARY KEY (&amp;#34;ID&amp;#34;) ); Then, create a stored procedure:
CREATE PROCEDURE sp_insert (x NUMBER) IS BEGIN -- Do some inserts here.  INSERT INTO test VALUES (x, &amp;#39;insert by stored procedure&amp;#39;); -- Sometimes there might be an error.  IF x = 2 THEN RAISE_APPLICATION_ERROR(-20000, &amp;#39;Wooops...&amp;#39;); END IF; EXCEPTION WHEN OTHERS THEN --Rollback all the changes and then raise the error again.  ROLLBACK; RAISE; END sp_insert;  To understand how to handle the rollback, I wrote a test to demonstrate the rule.
Before each test, we insert a record with the id of 2.
public class TransactionTest { // JDBC driver name and database URL  static final String DB_URL = &amp;#34;jdbc:oracle:thin:@10.10.10.100:1521:ENG11R2&amp;#34;; // Database credentials  static final String USER = &amp;#34;system&amp;#34;; static final String PASS = &amp;#34;oracle&amp;#34;; @Before public void setUp() throws SQLException { Connection conn = DriverManager.getConnection(DB_URL,USER,PASS); conn.setAutoCommit(false); PreparedStatement statement = conn.prepareStatement(&amp;#34;truncate table test&amp;#34;); statement.execute(); String sql = &amp;#34;insert into test values (2, &amp;#39;insert in advance&amp;#39;)&amp;#34;; statement = conn.prepareStatement(sql); statement.execute(); conn.commit(); } @After public void tearDown() throws SQLException { Connection conn = DriverManager.getConnection(DB_URL,USER,PASS); PreparedStatement statement = conn.prepareStatement(&amp;#34;select * from test&amp;#34;); ResultSet rs = statement.executeQuery(); while(rs.next()) { System.out.printf(&amp;#34;%d | %s %n&amp;#34;, rs.getInt(1), rs.getString(2)); } conn.close(); } @Test public void clientExitDueToException() throws SQLException { System.out.printf(&amp;#34;-----------Now start run clientExitDueToException test -----------%n&amp;#34;); Connection conn = DriverManager.getConnection(DB_URL,USER,PASS); conn.setAutoCommit(false); String sql = &amp;#34;insert into test values (?, &amp;#39;insert by clientExitDueToException&amp;#39;)&amp;#34;; PreparedStatement statement = conn.prepareStatement(sql); statement.setInt(1, 1); statement.execute(); statement.setInt(1, 2); // expected throw exception here  statement.execute(); statement.setInt(1, 3); statement.execute(); conn.commit(); } @Test public void clientIgnoreError() throws SQLException { System.out.printf(&amp;#34;-----------Now start run clientIgnoreError test -----------%n&amp;#34;); Connection conn = DriverManager.getConnection(DB_URL,USER,PASS); conn.setAutoCommit(false); String sql = &amp;#34;insert into test values (?, &amp;#39;insert by clientIgnoreError&amp;#39;)&amp;#34;; PreparedStatement statement = conn.prepareStatement(sql); statement.setInt(1, 1); statement.execute(); try { statement.setInt(1, 2); statement.execute(); } catch (SQLException ex) { // silently ignore unique key violation to prevent rollback,  // but statement-level rollback still happen implicitly  } statement.setInt(1, 3); statement.execute(); conn.commit(); } @Test public void clientNoErrorButProcedureRollback() throws SQLException { System.out.printf(&amp;#34;-----------Now start run clientNoErrorButProcedureRollback test -----------%n&amp;#34;); Connection conn = DriverManager.getConnection(DB_URL,USER,PASS); conn.setAutoCommit(false); PreparedStatement statement = conn.prepareStatement(&amp;#34;insert into test (id, name) values (?, &amp;#39;clientNoErrorButProcedureRollback&amp;#39;)&amp;#34;); statement.setInt(1, 1); statement.execute(); // rollback within stored procedure  try { PreparedStatement sp = conn.prepareCall(&amp;#34;{ call sp_insert(2) }&amp;#34;); // 2  sp.execute(); } catch (Exception ex) { // ignore the exception within the stored procedure  } statement.setInt(1, 3); statement.execute(); conn.commit(); } } The results of the code:
-----------Now start run clientExitDueToException test ----------- 2 | insert in advance java.sql.SQLIntegrityConstraintViolationException: ORA-00001: unique constraint (SYSTEM.TEST_PK) violated at oracle.jdbc.driver.T4CTTIoer.processError(T4CTTIoer.java:450) at oracle.jdbc.driver.T4CTTIoer.processError(T4CTTIoer.java:399) at oracle.jdbc.driver.T4C8Oall.processError(T4C8Oall.java:1059) at oracle.jdbc.driver.T4CTTIfun.receive(T4CTTIfun.java:522) at oracle.jdbc.driver.T4CTTIfun.doRPC(T4CTTIfun.java:257) at oracle.jdbc.driver.T4C8Oall.doOALL(T4C8Oall.java:587) at oracle.jdbc.driver.T4CPreparedStatement.doOall8(T4CPreparedStatement.java:225) at oracle.jdbc.driver.T4CPreparedStatement.doOall8(T4CPreparedStatement.java:53) at oracle.jdbc.driver.T4CPreparedStatement.executeForRows(T4CPreparedStatement.java:943) at oracle.jdbc.driver.OracleStatement.doExecuteWithTimeout(OracleStatement.java:1150) at oracle.jdbc.driver.OraclePreparedStatement.executeInternal(OraclePreparedStatement.java:4798) at oracle.jdbc.driver.OraclePreparedStatement.execute(OraclePreparedStatement.java:4901) at oracle.jdbc.driver.OraclePreparedStatementWrapper.execute(OraclePreparedStatementWrapper.java:1385) at TransactionTest.clientExitDueToException(TransactionTest.java:56) -----------Now start run clientIgnoreError test ----------- 2 | insert in advance 1 | insert by clientIgnoreError 3 | insert by clientIgnoreError -----------Now start run clientNoErrorButProcedureRollback test ----------- 2 | insert in advance 3 | clientNoErrorButProcedureRollback  Case 1 The java code didn&amp;rsquo;t catch the SQLException, so the jvm will exit before the commit line.
For this case, the equivalent script the database received is like this:
BEGIN INSERT INTO TEST VALUES(1, &amp;#39;insert by clientExitDueToException&amp;#39;); INSERT INTO TEST VALUES(2, &amp;#39;insert by clientExitDueToException&amp;#39;); -- the above statement will be rollbacked implicitly due to unique key violation Because the database think the client exited, it rollback the transaction.
Case 2 The java code caught the exception and silently supressed it, the code can run to the commit line. So the transaction is committed normally.
For this case, the equivalent script the database received is like this:
BEGIN INSERT INTO TEST VALUES(1, &amp;#39;insert by clientIgnoreError&amp;#39;); INSERT INTO TEST VALUES(2, &amp;#39;insert by clientIgnoreError&amp;#39;); -- the above statement will be rollbacked implicitly due to unique key violation INSERT INTO TEST VALUES(3, &amp;#39;insert by clientIgnoreError&amp;#39;; COMMIT; Although the transaction committed, the second statement will be rollbacked. This demonstrated the support of statement-level rollback.
Case 3 The java code caught the exception and silently supressed it, the code can run to the commit line. So the transaction is committed normally.
But in the stored procedure, it rollbacked the transaction. So it caused the records before the error statement to rollback.
For this case, the equivalent script the database received is like this:
BEGIN INSERT INTO TEST VALUES(1, &amp;#39;insert by clientNoErrorButProcedureRollback&amp;#39;); -- the above statement will be rollbacked due to the rollback statement within the procedure INSERT INTO TEST VALUES(2, &amp;#39;insert by clientNoErrorButProcedureRollback&amp;#39;); -- the above statement will be rollbacked implicitly due to unique key violation ROLLBACK; INSERT INTO TEST VALUES(3, &amp;#39;insert by clientNoErrorButProcedureRollback&amp;#39; COMMIT;</content>
    </entry>
    
     <entry>
        <title>Oracle Statement-Level ROLLBACK</title>
        <url>http://yangchao.me/post/oracle-statement-level-rollback/</url>
        <categories>
          
        </categories>
        <tags>
          
        </tags>
        <content type="html">  Oracle Statement-Level ROLLBACK (undo of a transaction)
Purpose Use the ROLLBACK statement to undo work done in the current transaction or to manually undo the work done by an in-doubt distributed transaction.
Articles Related Oracle Database - Deadlock Oracle Database - Distributed Transactions Oracle Database - Locks Oracle Database - Row Locks (TX) Oracle Database - TableSpace Oracle Database - Transactions Oracle Database - UNDO (Rollback Segment) PL/SQL - Autonomous Transactions (Pragma)
Type Implicit An implicit ROLLBACK occurs when the session (or program) abnormally terminates.
Explicit An explicit commit occurs when the ROLLBACK statement is executed.
Syntax Rollback to savepoint ROLLBACK [WORK] TO SAVEPOINT; If the savepoint is unknown, Oracle will display a warning but the transaction can continue.
Rollback. Rollback the whole transaction ignoring the savepoints. ROLLBACK
Statement-Level Rollback Oracle Database supports statement-level atomicity, which means that a SQL statement is an atomic unit of work and either completely succeeds or completely fails.
A successful statement is different from a committed transaction. A single SQL statement executes successfully if the database parses and runs it without error as an atomic unit, as when all rows are changed in a multirow update.
If a SQL statement causes an error during execution, then it is not successful and so all effects of the statement are rolled back. This operation is a statement-level rollback. This operation has the following characteristics:
A SQL statement that does not succeed causes the loss only of work it would have performed itself.
The unsuccessful statement does not cause the loss of any work that preceded it in the current transaction. For example, if the execution of the second UPDATE statement in Figure 10-1 causes an error and is rolled back, then the work performed by the first UPDATE statement is not rolled back. The first UPDATE statement can be committed or rolled back explicitly by the user.
The effect of the rollback is as if the statement had never been run. Any side effects of an atomic statement, for example, triggers invoked upon execution of the statement, are considered part of the atomic statement. Either all work generated as part of the atomic statement succeeds or none does.
An example of an error causing a statement-level rollback is an attempt to insert a duplicate primary key. Single SQL statements involved in a deadlock, which is competition for the same data, can also cause a statement-level rollback. However, errors discovered during SQL statement parsing, such as a syntax error, have not yet been run and so do not cause a statement-level rollback.
Example gerardnico@orcl&amp;gt;CREATE TABLE big_table AS SELECT * FROM all_objects WHERE 1=0; TABLE created. gerardnico@orcl&amp;gt;SELECT COUNT(*) FROM big_table; COUNT(*) ----------  0 gerardnico@orcl&amp;gt;INSERT INTO big_table SELECT * FROM all_objects 66651 rows created. gerardnico@orcl&amp;gt;SELECT COUNT(*) FROM big_table; COUNT(*) ----------  66651 gerardnico@orcl&amp;gt;ROLLBACK; ROLLBACK complete. gerardnico@orcl&amp;gt;SELECT COUNT(*) FROM big_table; COUNT(*) ----------  0  Reference Rollback
</content>
    </entry>
    
     <entry>
        <title>Java Security 2nd - notes 1</title>
        <url>http://yangchao.me/post/java-security-2nd-notes-1/</url>
        <categories>
          
        </categories>
        <tags>
          
        </tags>
        <content type="html">  security manager vs. access controller Historically, before the access controller existed, the security manager relied on its internal logic to determine the security policy that should be in effect, and changing the security policy required changing the security manager itself. Starting with Java 2, the security manager defers these decisions to the access controller. Since the security policy enforced by the access controller can be specified by using policy files, this allows a much more flexible mechanism for determining policies.
Java applications (at least by default) have no security manager while Java applets (again, by default) have a very strict security manager.
Specifying the −Djava.security.manager JVM option to install a security manager. But by default the security manager is installed programatically by the appletviewer and the Java Plug-in.
How do APIs use SecurityManager to check the allowance of an operation?
Take the FileInputStream class as an example:
public FileInputStream(String name) throws FileNotFoundException { SecurityManager security = System.getSecurityManager( ); if (security != null) { security.checkRead(name); } try { open(name); // open() is a private method of this class  } catch (IOException e) { throw new FileNotFoundException(name); } } System has two static methods to get and set security manager.
 public static SecurityManager getSecurityManager() public static void setSecurityManager(SecurityManager sm)  A single security manager per virtual machine.
The Access Controller //TODO
</content>
    </entry>
    
     <entry>
        <title>How to implement a Stack with Queue</title>
        <url>http://yangchao.me/post/implement-stack-with-queue/</url>
        <categories>
          
        </categories>
        <tags>
          
        </tags>
        <content type="html"> How do you implement a Stack using Queue?
As is known to all, the difference between Stack and Queue is the order to add and remove elements. So it&amp;rsquo;s possible to implement a Stack using Queue by controlling the operation logic.
 push 3 elements to the queue   |	| |	3	| &amp;lt;- top |	2	| |	1	|   pop a element  for the elements other than the top, repush into the queue
 |	| |	1	| |	3	| &amp;lt;- top |	2	| |	| |	2	| |	1	| |	3	| &amp;lt;- top  until the top, just remove and reset the top
 |	| |	2	| &amp;lt;- top |	1	|  So here is the code:
import org.junit.Test; import java.util.LinkedList; import java.util.Queue; public class QueuedStack&amp;lt;E&amp;gt; { private Queue&amp;lt;Wrapper&amp;lt;E&amp;gt;&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;(); private Wrapper&amp;lt;E&amp;gt; top = null; private static class Wrapper&amp;lt;E&amp;gt; { private E value; public Wrapper(E value) { this.value = value; } } public void push(E value) { Wrapper&amp;lt;E&amp;gt; elem = new Wrapper&amp;lt;E&amp;gt;(value); queue.offer(elem); top = elem; System.out.printf(&amp;#34;⇢ %s %n&amp;#34;, value); } public E pop() { if(queue.isEmpty()) return null; Wrapper&amp;lt;E&amp;gt; nextTop = null; while(true) { Wrapper&amp;lt;E&amp;gt; elem = queue.poll(); if (elem == top) { System.out.printf(&amp;#34;⇠ %s %n&amp;#34;, elem.value); top = nextTop; return elem.value; } queue.offer(elem); nextTop = elem; } } @Test public void test() { QueuedStack&amp;lt;String&amp;gt; stack = new QueuedStack&amp;lt;&amp;gt;(); stack.push(&amp;#34;1&amp;#34;); stack.push(&amp;#34;2&amp;#34;); stack.pop(); stack.push(&amp;#34;3&amp;#34;); stack.push(&amp;#34;4&amp;#34;); stack.pop(); stack.push(&amp;#34;5&amp;#34;); stack.push(&amp;#34;1&amp;#34;); stack.pop(); stack.pop(); stack.pop(); stack.pop(); } // Output 	// ⇢ 1 	// ⇢ 2 	// ⇠ 2 	// ⇢ 3 	// ⇢ 4 	// ⇠ 4 	// ⇢ 5 	// ⇢ 1 	// ⇠ 1 	// ⇠ 5 	// ⇠ 3 	// ⇠ 1 } Why do I need to wrap the value? Because I use the reference to trace the top pointer, if using the value rawly, it will be not unique when some type uses Flyweight pattern to pool some values, like String does.
</content>
    </entry>
    
     <entry>
        <title>Book notes: Oracle Database Transactions and Locking revealed</title>
        <url>http://yangchao.me/post/book-notes-oracle-database-transactions-and-locking-revealed/</url>
        <categories>
          
        </categories>
        <tags>
          
        </tags>
        <content type="html">  Chapter 1 Getting Started The focus of this book: locking, concurrency control, multiversioning, transactions, redo/undo.
These concepts are all interrelated.
Locking The database uses locks mechanism that allows for concurrency.
Each database implements locking differently:
 some have page-level locking, others row-level some implementations escalate locks from row level to page level, some do not some use read locks, others don&amp;rsquo;t some implement serializable transactions via locking, others via read-consistent views of data (no locks)  Oracle&amp;rsquo;s locking policy:
 Oracle locks data at the row level on modification. There is no lock escalation to a block or table level. Oracle never locks data just to read it. There are no locks placed on rows of data simply by reads. reads are not blocked by writes or reads. writes are not blocked by reads. A write is blocked only when another write has already locked the row it was going after.  Concurrency Control Concurrency control ensures that no two transactions modify the same piece of data at the same time.
Multiversioning Multiversioning is related to concurrency control, and it forms the foundation for Oracle&amp;rsquo;s concurrency control mechanism.
Oracle operates a multiversion, read-consistent concurrency model.
This mechanism provides:
 Read-consistent query: query produces consitent result with respect to a time point. Nonblocking query: query is never blocked by data writes.  If you understand how multiversioning and read consitency work together, you will always understand the answers you get from the database.
 Oracle doesn&amp;rsquo;t &amp;ldquo;pre-answer&amp;rdquo; the query. It doesn&amp;rsquo;t copy the data anywhere when you open a cursor. The cursor opens instantly and it answers the query as it goes along. The cursor just reads data from the table as you fetch from it.
 The following example demonstrates how multiversioning is implemented.
In sesssion 1, We need to query a table with 1 billion rows. Obviously, you need time to query the data. This query opens the curson at time t1, then retrieves row 20,000 at time t2, until gets the last row at time t5.
So just at the start point t1 of the query, Oracle doesn&amp;rsquo;t know what&amp;rsquo;s row 100,000,000 like.
And session 2 deletes the row 100,000 and commited at time t3 before t4.
From our cursor&amp;rsquo;s perspective, the result is immutable even if it gets the full data until the time t5.
But Oracle doesn&amp;rsquo;t copy all of the preceding data to other location when we opened the cursor; it was actually the DELETE command that preserved our data for us by placing it into a data area called an undo or rollback segment.
So at the time t4, the actual row 100,000 didn&amp;rsquo;t exist, but the read-consistent query can be implemented by getting the data from the undo segment.
Transactions A transaction comprises a unit of database work.
Transactions are a core feature of database technology, which is part of what distinguishes a database from a file system.
Transactions take the database from one consistent state to the next consistent state.
Redo and Undo Key to Oracle&amp;rsquo;s durability (recovery) mechanism is redo, and core to multiversioning (read consistency) is undo.
Chapter 2 Locking and Issues </content>
    </entry>
    
     <entry>
        <title>Regex in Java</title>
        <url>http://yangchao.me/post/regex-in-java/</url>
        <categories>
          
        </categories>
        <tags>
          
        </tags>
        <content type="html">  Some concepts metacharacters &amp;lt;([{\^-=$!|]})?*&#43;.&amp;gt; these characters have special meaning which can affect the way a pattern is matached.
character classes a set of characters enclosed within square brackets.
   Construct Description     [abc] a, b, or c (simple class)   [^abc] Any character except a, b, or c (negation)   [a-zA-Z] a through z, or A through Z, inclusive (range)   [a-d[m-p]] a through d, or m through p: a-dm-p   [a-z&amp;amp;&amp;amp;[def]] d, e, or f (intersection)   [a-z&amp;amp;&amp;amp;[^bc]] a through z, except for b and c: ad-z   [a-z&amp;amp;&amp;amp;[^m-p]] a through z, and not m through p: a-lq-z    predefined character classes convenient shorthands for commonly used regular expressions
   Construct Description     . Any character (may or may not match line terminators)   \d A digit: [0-9]   \D A non-digit: [^0-9]   \s A whitespace character: [ \t\n\x0B\f\r]   \S A non-whitespace character: [^\s]   \w A word character: [a-zA-Z_0-9]   \W A non-word character: [^\w]    bounary matchers    Boundary Construct Description     ^ The beginning of a line   \b A word boundary   \B A non-word boundary   \A The beginning of the input   \G The end of the previous match   \Z The end of the input but for the final terminator, if any   \z The end of the input    qualifier the number of occurrences to match against
   qualifier meaning     X? once or not at all   X* zero or more times   X&#43; one or more times   X{n} exactly n times   X{n,} at least n times   X{n,m} at least n but not more than m times    Qualifier can be applied on character, character class, capturing group.
capturing groups treat multiple characters as a single unit
Capturing groups are numbered by counting their opening parentheses from left to right.
There is also a special group, group 0, which always represents the entire expression. This group is not included in the total reported by groupCount.
 s(\d\w),f(dfd(\Sgd)er)3=pr --1--- ------2----- --3--  Group 1: (\d\w) Group 2: (dfd(\Sgd)er) Group 3: (\Sgd)
backreferences In your regular expression, you can reference the previous capturing group by a backslash () followed by a digit indicating the number of the group to be recalled.
(\d\d)\1(abc)dfd\2-ellre
Here, \1 is refered as the matched content of (\d\d) and \2 is refered as the matched content of (abc). Note, backreference doesn&amp;rsquo;t mean the replacement of the sub pattern of the group.
Pattern Pattern pattern = Pattern.compile(&amp;#34;(\\d\\d).(abc)&amp;#34;; Matcher Matcher matcher = pattern.matcher(&amp;#34;string-to-match&amp;#34;) find() vs. matches() vs. lookingAt()  matches() matches the full string starting from 0. lookingAt() like matches() starting from 0, but not requre to match the full string. find() tries to find the next occurrence within the substring that matches the regex. That means, the result of calling find() multiple times might not be the same.  Pattern pattern = Pattern.compile(&amp;#34;\\d\\d&amp;#34;); Matcher matcher = pattern.matcher(&amp;#34;2345&amp;#34;); matcher.matches(); //false matcher.lookingAt(); // true matcher.find(); // true  If you care about the full string matching, use matches(), otherwise use lookingAt(). find() is better to use to match multiple occurrences and call multiple times.
 query state Once matched, we can always query the state by method group(), start(), and end().
Because find() can call multiple times to get all the matched substrings, we can get more detailed group state by group(i), start(i), and end(i).
``` java typical usage of find() while(matcher.find()) out.prinf(&amp;ldquo;Found the text \&amp;ldquo;%s\&amp;rdquo; from %d to %d&amp;rdquo;, matcher.group(), matcher.start(), matcher.end() );
// further group details // although group 0 is excluded from groupCount(), we can safely get it // group() is equivlent with group(0) here for(int i=0; i &amp;lt;= matcher.groupCount(); &#43;&#43;i) { out.printf(&amp;quot;Group %d: %s from %d to %d&amp;quot;, matcher.group(i), matcher.start(i), matcher.end(i) ); }  }
 ## replacement `replaceAll(..)` and `replaceFirst(..)` is very useful to replace the whole matches. And in the replacement, you can use `$0, $1, $2, ..` to represent respective group matches. But the powerful way is using `appendReplacement(..)` and `applendTail()`. The following example, I need to replace the domain part of all emails in multiple lines. ```java String emails = &amp;quot;richd.yang@googlemail.com\n&amp;quot; &#43; &amp;quot;richdyang@yahoo.com&amp;quot;; String EMAIL_PATTERN = &amp;quot;^([a-zA-Z0-9._]&#43;)@((\\w&#43;)\\.(\\w&#43;))$&amp;quot;; StringBuffer sbf = new StringBuffer(); Matcher m = Pattern.compile(EMAIL_PATTERN, Pattern.MULTILINE).matcher(emails); while(m.find()) { String domain = m.group(3); if(&amp;quot;googlemail&amp;quot;.equals(domain)) { m.appendReplacement(sbf, &amp;quot;$1@gmail.$4&amp;quot;); } } m.appendTail(sbf); System.out.printf(&amp;quot;%s&amp;quot;, sbf);  Examples ``` java SimpleEmailMatcher String EMAILPATTERN = &amp;ldquo;([a-zA-Z0-9.]&#43;)@((\w&#43;\.)&#43;\w&#43;)&amp;ldquo;; Matcher m = Pattern.compile(EMAIL_PATTERN).matcher(&amp;ldquo;richd.yang@gmail.com&amp;rdquo;); while(m.find()) { System.out.printf(&amp;ldquo;Found \&amp;ldquo;%s\&amp;rdquo; (%d - %d) %n&amp;rdquo;, m.group(), m.start(), m.end()); for(int i=0; i &amp;lt;= m.groupCount(); &#43;&#43;i) { System.out.printf(&amp;ldquo;Group %d: %s (%d - %d) %n&amp;rdquo;, i, m.group(i), m.start(i), m.end(i)); } }
 &amp;gt; Found &amp;quot;richd.yang@gmail.com&amp;quot; (0 - 20) &amp;gt; Group 0: richd.yang@gmail.com (0 - 20) &amp;gt; Group 1: richd.yang (0 - 10) &amp;gt; Group 2: gmail.com (11 - 20) &amp;gt; Group 3: gmail. (11 - 17) Now we can get the Email domain from group 2. ``` java SimpleIPMatcher String IPADDRESS_PATTERN = &amp;quot;^([0-9]|[1-9]\\d|2[0-4]\\d|25[0-5])\\.&amp;quot; &#43; &amp;quot;([0-9]|[1-9]\\d|2[0-4]\\d|25[0-5])\\.&amp;quot; &#43; &amp;quot;([0-9]|[1-9]\\d|2[0-4]\\d|25[0-5])\\.&amp;quot; &#43; &amp;quot;([0-9]|[1-9]\\d|2[0-4]\\d|25[0-5])$&amp;quot;; Matcher m = Pattern.compile(IPADDRESS_PATTERN).matcher(&amp;quot;10.233.29.5&amp;quot;); while(m.find()) { System.out.printf(&amp;quot;Found \&amp;quot;%s\&amp;quot; (%d - %d) %n&amp;quot;, m.group(), m.start(), m.end()); for(int i=0; i &amp;lt;= m.groupCount(); &#43;&#43;i) { System.out.printf(&amp;quot;Group %d: %s (%d - %d) %n&amp;quot;, i, m.group(i), m.start(i), m.end(i)); } }   Found &amp;ldquo;10.233.29.5&amp;rdquo; (0 - 11) Group 0: 10.233.29.5 (0 - 11) Group 1: 10 (0 - 2) Group 2: 233 (3 - 6) Group 3: 29 (7 - 9) Group 4: 5 (10 - 11)
 reference: how to validate ip address
Further references  Oracle Java Tutorial for Regular Expressions
 Mastering Regular Expressions
 Java Regex Tester online
  </content>
    </entry>
    
     <entry>
        <title>Book reading plan for 2016</title>
        <url>http://yangchao.me/post/book-reading-plan-for-2016/</url>
        <categories>
          
        </categories>
        <tags>
          
        </tags>
        <content type="html">  New year has come and I need a book reading plan now.
Database in-depth knowledge for a programmer (February)   read the document of Postgres and see how it implements transactions and locking   Security knowledge for a Java web developer (March)  The Art of encryption and decryption about Java 白帽子讲Web安全  Java I/O (April)  Java IO, NIO and NIO.2(Apress,2015) Pro Java NIO.2 Java IO.2nd.Edition.May.2006  Unicode (Aprial)  Unicode explained [](https://codepoints.net) [](http://www.fileformat.info/info/unicode/index.htm)  JVM Network and Operating System </content>
    </entry>
    
     <entry>
        <title>A problem with HTTP 206 Partial</title>
        <url>http://yangchao.me/post/a-preoblem-with-http-206-partial/</url>
        <categories>
          
        </categories>
        <tags>
          <tag>Trouble Shooting</tag>
        </tags>
        <content type="html"> Recent days, I encountered a problem about video loading and quicktime Basic Auth.
In our customer&amp;rsquo;s system, when they used older version Safari (say, 8.0.5) and opened a page for video playing, an authorization window popped up for username and password.
I captured the HTTP massage by using Charles proxy on my Mac OSX. I found in Safari 8.0.5, it always sent 2 requests, one from Safari itself and another from Quicktime plugin which was obviously observed from the User-Agent header.
I guessed the Safari supported HTML5 &amp;lt;video&amp;gt; tag in its WebKit core and also used Quicktime plugin as a fallback option.
I tried the video playing in another QA server but failed to replicate the case. The Safari sent only one request then. But why?
Further analyzing the HTTP traffic, I found the responses from the two servers were different. The customer&amp;rsquo;s server responded with 200 OK and a full length video, while the QA server responded with 206 Partial Content and the specified range of content, subsequently a serial of partial requests being sent.
It seemed Safari always requested partial content when it found the content-type was video or something like that. And the request headers included a Range to indicate what range of content was expected to return.
If the expectation cannot be fulfilled, Safari stopped to process the response, so the video would keep loading and fail at last. This is just my conclusion and explanation.
In the process of trouble shooting, I learnt to what is HTTPS and the knowledge about cryptography.
Basically, in Java, we need to know some security APIs:
 message digest: MD2, MD5, checksum, HMAC private key cryptography: DES, AES public key cryptography: RSA digital signature: private key encrypted message digest digital certificate: CA, digital signature, public key Java specified: key store related APIs  I got the complete knowledge by reading the excellent book The art of Encryption and Decryption about Java and java security tutorial in IBM developerworks.
</content>
    </entry>
    
     <entry>
        <title>Synology NAS &#43; NetGear router</title>
        <url>http://yangchao.me/post/synology-nas-netgear-router/</url>
        <categories>
          
        </categories>
        <tags>
          
        </tags>
        <content type="html"> For a long time, I&amp;rsquo;d like to build a home cloud for file storage, video streaming, ebook library and 科学上网 style.
Today, at the first day of this new year, I managed to accomplish my plan.
Firstly, I need a 1000&#43;M router supporting at least 2 channel (2.4G and 5G) and another urgent functionality &amp;ndash; shadowsocks client on router and VPN client.
After researching multiple brands of routers, at last I locked my target on Cisco, Linksys and NetGear. Yes, they are all foreign brands. This does not necessarily mean that I don&amp;rsquo;t like the products made by domestic venders. But I just felt really a pity that in router area, I have not trusted domestic venders any more. You may not imagine how many ‘corpses’ of routers there&amp;rsquo;re at my home. I have bought these router: Mercury, TP-LINK, ASUS WL600gp, NetCore NW762 (special version for Thunder download), MiWIFI, Xiaomi.. the list can go on.
As the most basic functionality of a router, it must ensure the stability of wireless signals. Some extra application functionalities, like external storage via USB, offline downloading, web server etc, should not influence the stability of the whole router performance.
A good way to implement these extra functionalities is to buy a realistic NAS. Yes, though usually costly, a home-class NAS. Only one functionality I&amp;rsquo;d like to implement is &amp;lsquo;scientific net-surfing&amp;rsquo;. As a developer and a person posing as a global citizen, I need to frequently access Google, Gmail, GitHub, Twitter, Facebook, Youtube.. I hope when I come home every day, I can surf the internet freely if I don&amp;rsquo;t do something illegal.
So at last, I chose Synology DS216play as my NAS server and private clout provider. It can provide liable file storage, media center for iPhone/iPad/Mac/TV, photo backup automatically, Mac time machine, remote and offline downloading. Since Cicso and Linksys routers are beyond my budget, I turned to NetGear R6300v2. It attracted me because it is a 1000&#43;M router with 2.4G/5G. I didn&amp;rsquo;t use the built-in firmware, instead I changed to Merlin firmware for the Shadowsocks support. In this way, the router supported transparent &amp;lsquo;fanqiang&amp;rsquo;.
Perfect! Enjoy it.
</content>
    </entry>
    
     <entry>
        <title>Mac OSX tips</title>
        <url>http://yangchao.me/post/mac-osx-tips/</url>
        <categories>
          
        </categories>
        <tags>
          
        </tags>
        <content type="html">  Change user full name in Mac OSX Yosemite From the Apple menu, select System Preferences. In &amp;ldquo;System Preferences&amp;rdquo;, from the View menu, select Users &amp;amp; Groups. If the padlock icon in the bottom left corner of the preferences window is closed, click it. Authenticate with an administrative account. Right-click your account name, and in the contextual menu that opens, select Advanced Options&amp;hellip;. In the Advanced Options sheet, next to &amp;ldquo;Full name:&amp;ldquo;, enter your name as you wish it to appear when logging into your account. Click OK.
Set turn off display screen withoud sleep System Preference -&amp;gt; Mission Control
There is a &amp;lsquo;Hot Corners..&amp;rsquo; on the bottom. Click this button.
I define &amp;ldquo;Put Display to Sleep&amp;rdquo; when I move the mouse pointer to the right bottom corner. Of course, you can define yours
</content>
    </entry>
    
     <entry>
        <title>SSH Key-based Authentication</title>
        <url>http://yangchao.me/post/ssh-key-based-authentication/</url>
        <categories>
          
        </categories>
        <tags>
          
        </tags>
        <content type="html"> bash run on your macbook ssh-kengen -t rsa 
Thus it will generate a private-public key pair in ~/.ssh directory. Copy the public key ~/.ssh/id_rsa.pub to servers: VPS or github or bitbucket.
In your VPS server, copy the content of id_rsa.pub to ~/.ssh/authorized_keys.
That&amp;rsquo;s OK. Now you can ssh to your server without password.
</content>
    </entry>
    
     <entry>
        <title>Gradle use notes</title>
        <url>http://yangchao.me/post/gradle-use-notes/</url>
        <categories>
          
        </categories>
        <tags>
          
        </tags>
        <content type="html">  Gradle is so powerful!
This is the comment after I read the tutorial of Gradle.
Gradle configuration There&amp;rsquo;re mainly 3 configuration files: - build.gradle: this is where you write your gradle script. Gradle script is written using Groovy. - gradle.properties: you set some variables that can be used in your script - gradle.setting: like project.name settings
Gradle terms  project: an abstraction of a build. you can use multiple projects. task: this is like the target in Ant.  Simple use example group &amp;#39;gradle&amp;#39; version &amp;#39;1.0-SNAPSHOT&amp;#39; apply plugin: &amp;#39;java&amp;#39; sourceCompatibility = 1.5 repositories { mavenCentral() } dependencies { testCompile group: &amp;#39;junit&amp;#39;, name: &amp;#39;junit&amp;#39;, version: &amp;#39;4.11&amp;#39; } task hello { group = &amp;#34;mypersonal&amp;#34; description = &amp;#34;this is a helloworld task&amp;#34; } hello &amp;lt;&amp;lt; { print name } Explanations: * group and version represent the group and version of the build distribution. * apply plugin: &#39;java&#39; means you use java plugin. * repositories and dependencies sections are for dependency management. Here we use the Maven&amp;rsquo;s repository. * task method defines my own task named hello, and I set its properties: group and description. The following line we use &amp;lt;&amp;lt; operator to add the closure to the end of action list. It&amp;rsquo;s equivalent to doLast. Of course, there&amp;rsquo;s also a method named doFirst. You can add new closure as an action to the list.
That&amp;rsquo;s it. Easy, isn&amp;rsquo;t it?
Plugin Gradle use plugin mechanism to extend its build model. If you don&amp;rsquo;t use plugins, you cannot do somethings which really make sense.
Some commonly-used plugins are: - java: java related build. Generate a JAR at last. - war: obviously this is for packaging a webapp.
Actually, these plugins provide all sorts of tasks which are related to some goals.
If you don&amp;rsquo;t use any plugin at all, you can still use some common tasks:
Build Setup tasks ----------------- init - Initializes a new Gradle build. [incubating] wrapper - Generates Gradle wrapper files. [incubating] Help tasks ---------- components - Displays the components produced by root project &amp;#39;&amp;#39;. [incubating] dependencies - Displays all dependencies declared in root project &amp;#39;&amp;#39;. dependencyInsight - Displays the insight into a specific dependency in root project &amp;#39;Richard&amp;#39;. help - Displays a help message. model - Displays the configuration model of root project &amp;#39;&amp;#39;. [incubating] projects - Displays the sub-projects of root project &amp;#39;&amp;#39;. properties - Displays the properties of root project &amp;#39;&amp;#39;. tasks - Displays the tasks runnable from root project &amp;#39;&amp;#39;.</content>
    </entry>
    
     <entry>
        <title>Perforce P4V use notes</title>
        <url>http://yangchao.me/post/perforce-p4v-use-notes/</url>
        <categories>
          
        </categories>
        <tags>
          
        </tags>
        <content type="html">  Perforce at a glance I&amp;rsquo;ve never gotten touch with Perforce, even heard about its name. Strange! Now because some versions of my company&amp;rsquo;s classic product are hosted on Perforce, so I need to know it from the beginning.
Basically, Perfoce is an commercial Version Control Systerm, like IBM Clearcase. It supports industry-level version control in the form of client-server architecuture. So the central depository exists for sure. It provides all sorts of robust features modern VCS all provides. But from the comments of my colleagues, I know it supports very heavy-weight branching.
P.S: P4 is the acronym of Perforce by pronunciation, just like Peer-to-Peer as P2P or Log-for-Java as Log4j.
Perforce concepts Whenever we get to know some new products or tools, we need to know its own slang. That&amp;rsquo;s comprised of tons of well-defined words.
 depository: A tree of depositories are the remote views on the server workspace: It&amp;rsquo;s the directory where the local copy of the files locate check out: Some resources should be modified exclusively, so you can use check out to prevent these resource from being modified by others. branch: a branch of version that can be viewed and manipulated seperately. merge: the same as that in other VCSs  Client tool: P4V 
</content>
    </entry>
    
     <entry>
        <title>Goodbye Wordpress, hello Hexo! </title>
        <url>http://yangchao.me/post/goodbye-wordpress-hello-hexo/</url>
        <categories>
          
        </categories>
        <tags>
          
        </tags>
        <content type="html">  I&amp;rsquo;ve opened this blog site since 2013 when I wanted to write something for recording my study notes and improved my English writing.
At that time, I chose wordpress mainly because I&amp;rsquo;m familiar with it and I had the experience to build a blog site using it. Once I started building a blog, the installation was pretty straightforward &amp;ndash; just extracting the tar.gz and throwing the file into /var/www/blog (/var/www/html is for the static files hosting on Debian). Then I need to configure the nginx by use of fcgi to forward the dynamic contents to PHP.
So later, I started finding a theme to make my blog beautiful and some plugins to make my writing smoothly, like the code highlighter, the TOC (aka. Table of Content) plugin, category tree plugin etc.
After I completed 100&#43; posts, I suddenly realised it seemed to go far away the essence of writing, as I spent too much time on doing these technical things - although my writing were mostly related to technical stuff.
Today I have the needs to transfer my vultr VPS from Australia to Japan. That&amp;rsquo;s because it&amp;rsquo;s really slow when I connect to the VPN and shadowsocks hosted on my server.
The following is the steps after I create a new vultr instance located in the data center of Japan:
setup the pptpd for VPN $ apt-get update $ apt-get install pptpd uncomment the section in the tail of /etc/pptpd.conf ``` txt /etc/pptpd.conf localip 192.168.0.1 remoteip 192.168.0.234-238,192.168.0.245
 enable ipv4 forword in the `/etc/sysctl.conf` ``` text /etc/sysctl.conf net.ipv4.ip_forward = 1  then make it effective
$ sysctl -p The last step is adding a rule to the iptables and restart pptpd
$ iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE &amp;amp;&amp;amp; iptables-save $ service pptpd restart That&amp;rsquo;s it. I refer to the digital oceal official guide here: How to setup your own vpn with pptp
AnyConnect VPN Updated on 13/12/2015
Although PPTP can satisfiy my needs, I think it&amp;rsquo;s not stable and rebust. Recent days, I always use Cisco AnyConnect VPN client to connect to my office internal network, so I decide to set up an AnyConnect compatible VPN server on my VPS.
I didn&amp;rsquo;t spend too much time to research how to do that. I just used an automatic installation script which can be refered to this Github repository.
setup shadowsocks Shadowsocks is a must-have if you live in China and need to do something by circumvention.
$ wget -O- http://shadowsocks.org/debian/1D27208A.gpg | apt-key add - $ echo &amp;#34;deb http://shadowsocks.org/debian wheezy main&amp;#34; &amp;gt;&amp;gt; /etc/apt/sources.list $ apt-get update $ apt-get install shadowsocks-libev Then you need to modify the /etc/shadowsocks-libev/config.json ``` json /etc/shadowsocks-libev/config.json { &amp;ldquo;server&amp;rdquo;:&amp;ldquo;my_server_ip&amp;rdquo;, &amp;ldquo;server_port&amp;rdquo;:8388, &amp;ldquo;local_port&amp;rdquo;:1080, &amp;ldquo;password&amp;rdquo;:&amp;ldquo;my password&amp;rdquo;, &amp;ldquo;timeout&amp;rdquo;:600, &amp;ldquo;method&amp;rdquo;:&amp;ldquo;table&amp;rdquo; }
 I tend to use `aes-128-fcb` method. Then reload the configuration: ```bash $ service shadowsocks-libev reload  Everything will go well!
nginx and dropbox for my blog hosting $ apt-get install nginx vim $ cd ~ &amp;amp;&amp;amp; wget -O - &amp;#34;https://www.dropbox.com/download?plat=lnx.x86_64&amp;#34; | tar xzf - $ ~/.dropbox-dist/dropboxd $ wget https://www.dropbox.com/download?dl=packages/dropbox.py -o dropbox.py $ chmod &#43;x dropbox.py $ ./dropbox.py start $ cd ~/Dropbox # must enter this directory and apply the wildcard. otherwise it didn&amp;#39;t take effect $ ~/dropbox.py exclude add * $ ~/dropbox.py exclude remove blog $ cd ~/Dropbox/blog $ ~/dropbox.py exclude add * $ ~/dropbox.py exclude remove public Now you can see I just synchronize the directory where the static files of my blog site locate.
The next thing I need to do is modifying the /etc/nginx/sites-available/default and changing the servername and root directory.
But I also encountered a thing I failed to fix - nginx will return a 500 server error. I reviewed the nginx log and found that&amp;rsquo;s the issues of permission.
So I simply changed the run user of nginx from www-data to root in /etc/nginx/nginx.conf. If I have spare time, I would fix the issue again.
blogging and publishing Since I use the static blogging tool - Hexo in my local MacBook and write the article using Markdown, I need to some apps to help me manage my publishing.
After using all sorts of markdown apps on Mac OSX, like Typera, Mou, Byword, Ulysses, TextNut, I found they always had some flaws for me - including unsupported markdown syntax, automatically modifying my file like adding some a new blank line arbitrarily, owning its own library management facility. But until I met MWeb, it&amp;rsquo;s suitable to me and satify my personal needs very well.
</content>
    </entry>
    
     <entry>
        <title>JDBC Driver register</title>
        <url>http://yangchao.me/post/jdbc-driver-register/</url>
        <categories>
          <category>Uncategorized</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html"> JDBC use the way of registry to manage its drivers by the method of DriverManager.registerDriver(...)
This method is static one, usually there&amp;rsquo;re several ways to invoke it: 1. in your code, write Class.forName(&amp;quot;com.xx.jdbc.Driver&amp;quot;);, this is a way to load the specified Driver class explicitly. You can get the effect because the jdbc driver venders usually get the registerDriver(..) method invoked just in the static block of the Driver implementation class. 2. you can tell the JVM to load which driver by setting the jdbc.drivers system property. 3. Another way is supported by the ServiceLocator mode. This needs the jdbc driver vender to package their jdbc driver jar following the service provider convention.
If you see the source code of JDBC API, you will find that the behaviours of way 2) and 3) are defined by the DriverManager.loadInitialDrivers() static method. So you needn&amp;rsquo;t do anything in your code to register Driver.
For example: * DB2 JDBC driver db2jcc4.jar is packaged following the service provider convention, so you needn&amp;rsquo;t invoke Class.forName(..) in your code. * MySQL JDBC driver mysql-connector-java.jar uses the same way.
</content>
    </entry>
    
     <entry>
        <title>mybatis cache</title>
        <url>http://yangchao.me/post/mybatis-cache/</url>
        <categories>
          <category>Uncategorized</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html"> mybatis的cache是基于statement的, 有人也称之为query cache，以有别于基于id的cache。你需要指定哪些statements来useCache, 哪些statements触发flushCache.
一旦触发了flushCache, cache将invalidate并清空，下次的查询都将从数据库查询，并放入cache
限制： * 同一个应用，一旦使用cache，需遵循： 1. 查询：先查询cache，命中返回; 未命中，查询数据库后放入cache 2. 修改：修改数据库，flush cache * 一旦修改了cache区域中数据，一定要flush，否则会出现cache与数据库不一致 * 使用cache的应用，外部程序(工具)直接修改数据库一定要慎重，因为极有可能导致数据不一致
下面是一个例子：
``` xml mybatis-config.xml &amp;lt;?xml version=”1.0” encoding=”UTF-8” ?&amp;gt; &amp;lt;!DOCTYPE configuration PUBLIC “-//mybatis.org//DTD Config 3.0//EN” “http://mybatis.org/dtd/mybatis-3-config.dtd&amp;quot;&amp;gt;         
 ``` xml SqlMapper.xml &amp;lt;?xml version=”1.0” encoding=”UTF-8” ?&amp;gt; &amp;lt;!DOCTYPE mapper PUBLIC “-//mybatis.org//DTD Mapper 3.0//EN” “http://mybatis.org/dtd/mybatis-3-mapper.dtd&amp;quot;&amp;gt; &amp;lt;mapper namespace=”person”&amp;gt; &amp;lt;cache eviction=&amp;quot;FIFO&amp;quot; flushInterval=&amp;quot;60000&amp;quot; size=&amp;quot;512&amp;quot; readOnly=&amp;quot;true&amp;quot;/&amp;gt; &amp;lt;select id=&amp;quot;selectPerson&amp;quot; resultType=&amp;quot;java.util.HashMap&amp;quot; flushCache=&amp;quot;false&amp;quot; useCache=&amp;quot;true&amp;quot;&amp;gt; select * from person &amp;lt;/select&amp;gt; &amp;lt;insert id=&amp;quot;insertPerson&amp;quot;&amp;gt; insert into person values (&#39;ccccc&#39;, 23, &#39;shenzhen&#39;) &amp;lt;/insert&amp;gt; &amp;lt;insert id=&amp;quot;insertStaff&amp;quot;&amp;gt; insert into staff values (&#39;richard&#39;) &amp;lt;/insert&amp;gt; &amp;lt;/mapper&amp;gt;  ``` java Main.java import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStream; import java.io.InputStreamReader; import java.util.List; import java.util.Map;
public class Main {
private static SqlSessionFactory sqlSessionFactory; private static BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); public static void main(String[] args) throws IOException { String resource = &amp;quot;mybatis-config.xml&amp;quot;; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); String command = null; while ((command = br.readLine()) != null) { SqlSession sqlSession = sqlSessionFactory.openSession(); if(command.equals(&amp;quot;q&amp;quot;)) { System.out.println(&amp;quot;sql query:&amp;quot;); List&amp;lt;Map&amp;gt; list = sqlSession.selectList(&amp;quot;person.selectPerson&amp;quot;); System.out.println(list); } else if(command.equals(&amp;quot;i&amp;quot;)) { System.out.println(&amp;quot;sql insert:&amp;quot;); sqlSession.insert(&amp;quot;person.insertPerson&amp;quot;); } else if(command.equals(&amp;quot;is&amp;quot;)) { System.out.println(&amp;quot;sql insert:&amp;quot;); sqlSession.insert(&amp;quot;person.insertStaff&amp;quot;); } sqlSession.commit(); sqlSession.close(); } }  }
 如何测试： 1. 控制台输入&amp;quot;q&amp;quot;触发查询，可以看到首次查询，会使用sql从数据库查询 2. 这时，我们控制台或数据库客户端(如mysql客户端)再向数据库中插入一些数据 3. 再次控制台输入&amp;quot;q&amp;quot;再次触发查询，日志显示，这次cache命中，直接从cache中读数据，程序外部（客户端）插入的数据并没有得到。很容易解释，因为这些外部的插入，mybatis并不知道。 4. 控制台输入&amp;quot;i&amp;quot;触发插入数据，然后再输入&amp;quot;q&amp;quot;触发查询，这次可以看到，会使用sql从数据库查询。可见insert触发了flushCache 5. 控制台输入&amp;quot;q&amp;quot;触发查询，发现cache命中, 不执行SQL 6. 控制台输入&amp;quot;is&amp;quot;触发插入另一个表的数据，然后再输入&amp;quot;q&amp;quot;触发查询，可以看到这时同样使用sql从数据库查询。可见虽然是不同的表的插入，也将flush整个cache, 因为他们共用位于同一个SqlMapper的namespace中的cache 7. 控制台输入&amp;quot;q&amp;quot;触发查询，发现cache命中, 不执行SQL ```undefined q sql query: 2015-11-06 21:39:26,103 [DEBUG] (org.apache.ibatis.logging.commons.JakartaCommonsLoggingImpl.debug(JakartaCommonsLoggingImpl.java:54)) - Cache Hit Ratio [person]: 0.0 2015-11-06 21:39:26,417 [DEBUG] (org.apache.ibatis.logging.commons.JakartaCommonsLoggingImpl.debug(JakartaCommonsLoggingImpl.java:54)) - ==&amp;gt; Preparing: select * from person 2015-11-06 21:39:26,447 [DEBUG] (org.apache.ibatis.logging.commons.JakartaCommonsLoggingImpl.debug(JakartaCommonsLoggingImpl.java:54)) - ==&amp;gt; Parameters: 2015-11-06 21:39:26,463 [DEBUG] (org.apache.ibatis.logging.commons.JakartaCommonsLoggingImpl.debug(JakartaCommonsLoggingImpl.java:54)) - &amp;lt;== Total: 0 [] i sql insert: 2015-11-06 21:39:42,303 [DEBUG] (org.apache.ibatis.logging.commons.JakartaCommonsLoggingImpl.debug(JakartaCommonsLoggingImpl.java:54)) - ==&amp;gt; Preparing: insert into person values (‘ccccc’, 23, ‘shenzhen’) 2015-11-06 21:39:42,304 [DEBUG] (org.apache.ibatis.logging.commons.JakartaCommonsLoggingImpl.debug(JakartaCommonsLoggingImpl.java:54)) - ==&amp;gt; Parameters: 2015-11-06 21:39:42,305 [DEBUG] (org.apache.ibatis.logging.commons.JakartaCommonsLoggingImpl.debug(JakartaCommonsLoggingImpl.java:54)) - &amp;lt;== Updates: 1 q sql query: 2015-11-06 21:39:44,711 [DEBUG] (org.apache.ibatis.logging.commons.JakartaCommonsLoggingImpl.debug(JakartaCommonsLoggingImpl.java:54)) - Cache Hit Ratio [person]: 0.0 2015-11-06 21:39:44,712 [DEBUG] (org.apache.ibatis.logging.commons.JakartaCommonsLoggingImpl.debug(JakartaCommonsLoggingImpl.java:54)) - ==&amp;gt; Preparing: select * from person 2015-11-06 21:39:44,712 [DEBUG] (org.apache.ibatis.logging.commons.JakartaCommonsLoggingImpl.debug(JakartaCommonsLoggingImpl.java:54)) - ==&amp;gt; Parameters: 2015-11-06 21:39:44,718 [DEBUG] (org.apache.ibatis.logging.commons.JakartaCommonsLoggingImpl.debug(JakartaCommonsLoggingImpl.java:54)) - &amp;lt;== Total: 1 [{city=shenzhen, name=ccccc, age=23}] q sql query: 2015-11-06 21:39:50,878 [DEBUG] (org.apache.ibatis.logging.commons.JakartaCommonsLoggingImpl.debug(JakartaCommonsLoggingImpl.java:54)) - Cache Hit Ratio [person]: 0.3333333333333333 [{city=shenzhen, name=ccccc, age=23}] is sql insert: 2015-11-06 21:40:00,431 [DEBUG] (org.apache.ibatis.logging.commons.JakartaCommonsLoggingImpl.debug(JakartaCommonsLoggingImpl.java:54)) - ==&amp;gt; Preparing: insert into staff values (‘richard’) 2015-11-06 21:40:00,432 [DEBUG] (org.apache.ibatis.logging.commons.JakartaCommonsLoggingImpl.debug(JakartaCommonsLoggingImpl.java:54)) - ==&amp;gt; Parameters: 2015-11-06 21:40:00,439 [DEBUG] (org.apache.ibatis.logging.commons.JakartaCommonsLoggingImpl.debug(JakartaCommonsLoggingImpl.java:54)) - &amp;lt;== Updates: 1 q sql query: 2015-11-06 21:40:03,310 [DEBUG] (org.apache.ibatis.logging.commons.JakartaCommonsLoggingImpl.debug(JakartaCommonsLoggingImpl.java:54)) - Cache Hit Ratio [person]: 0.25 2015-11-06 21:40:03,315 [DEBUG] (org.apache.ibatis.logging.commons.JakartaCommonsLoggingImpl.debug(JakartaCommonsLoggingImpl.java:54)) - ==&amp;gt; Preparing: select * from person 2015-11-06 21:40:03,316 [DEBUG] (org.apache.ibatis.logging.commons.JakartaCommonsLoggingImpl.debug(JakartaCommonsLoggingImpl.java:54)) - ==&amp;gt; Parameters: 2015-11-06 21:40:03,317 [DEBUG] (org.apache.ibatis.logging.commons.JakartaCommonsLoggingImpl.debug(JakartaCommonsLoggingImpl.java:54)) - &amp;lt;== Total: 1 [{city=shenzhen, name=ccccc, age=23}] q sql query: 2015-11-06 21:40:04,337 [DEBUG] (org.apache.ibatis.logging.commons.JakartaCommonsLoggingImpl.debug(JakartaCommonsLoggingImpl.java:54)) - Cache Hit Ratio [person]: 0.4 [{city=shenzhen, name=ccccc, age=23}]  </content>
    </entry>
    
     <entry>
        <title>BytecodeViewer for Mac</title>
        <url>http://yangchao.me/post/bytecodeviewer-for-mac/</url>
        <categories>
          <category>Uncategorized</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html"> BytecodeViewer only has the Windows executable release.
I use the Automator to get an app for Mac OSX.
Now I provide a download link here:
https://github.com/richdyang/bytecode-viewer/releases/tag/v2.9.8
</content>
    </entry>
    
     <entry>
        <title>Inner classes synthetic</title>
        <url>http://yangchao.me/post/inner-classes-synthetic/</url>
        <categories>
          <category>Uncategorized</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html"> import java.util.ArrayList; import java.util.List; public class Enclosing { private List instanceList = new ArrayList&amp;lt;&amp;gt;(); { instanceList.add(1);} public static void main(String[] args) { Enclosing outer = new Enclosing(); outer.instanceList.add(2); outer.foo(); InnerClass inner = outer.new InnerClass(); outer.instanceList.add(3); inner.bar(); } public void foo() { final List localList = new ArrayList&amp;lt;&amp;gt;(); localList.add(1); class LocalClass { public void bar() { System.out.println(localList); System.out.println(instanceList); } } localList.add(2); new LocalClass().bar(); } private class InnerClass { public void bar() { System.out.println(instanceList); } } } 一旦编译，会生成3个class文件：
 Enclosing.class Enclosing$1.class Enclosing$1LocalClass.class Enclosing$InnerClass.class   为什么会生成一个空的Enclosing$1.class？
下面我们来看看编译器替我们做了哪些事情：
首先看Enclosing$InnerClass.class
class corejava/Enclosing$InnerClass { synthetic final corejava.Enclosing this$0; private Enclosing$InnerClass(corejava.Enclosing arg0) { // &amp;lt;init&amp;gt; //(Lcorejava/Enclosing;)V  &amp;lt;localVar:index=0 , name=this , desc=Lcorejava/Enclosing$InnerClass;, sig=null, start=L1, end=L2&amp;gt; L1 { aload0 // reference to self  aload1 putfield corejava/Enclosing$InnerClass.this$0:corejava.Enclosing aload0 // reference to self  invokespecial java/lang/Object &amp;lt;init&amp;gt;(()V); return } L2 { } } public bar() { //()V  &amp;lt;localVar:index=0 , name=this , desc=Lcorejava/Enclosing$InnerClass;, sig=null, start=L1, end=L2&amp;gt; L1 { getstatic java/lang/System.out:java.io.PrintStream aload0 // reference to self  getfield corejava/Enclosing$InnerClass.this$0:corejava.Enclosing invokestatic corejava/Enclosing access$100((Lcorejava/Enclosing;)Ljava/util/List;); invokevirtual java/io/PrintStream println((Ljava/lang/Object;)V); } L3 { return } L2 { } } Enclosing$InnerClass(corejava.Enclosing arg0, corejava.Enclosing$1 arg1) { // &amp;lt;init&amp;gt; //(Lcorejava/Enclosing;Lcorejava/Enclosing$1;)V  &amp;lt;localVar:index=0 , name=this , desc=Lcorejava/Enclosing$InnerClass;, sig=null, start=L1, end=L2&amp;gt; &amp;lt;localVar:index=1 , name=x0 , desc=Lcorejava/Enclosing;, sig=null, start=L1, end=L2&amp;gt; &amp;lt;localVar:index=2 , name=x1 , desc=Lcorejava/Enclosing$1;, sig=null, start=L1, end=L2&amp;gt; L1 { aload0 // reference to self  aload1 // reference to arg0  invokespecial corejava/Enclosing$InnerClass &amp;lt;init&amp;gt;((Lcorejava/Enclosing;)V); return } L2 { } } synthetic class corejava/Enclosing$1 { } } 很显然，编译器替我们合成了一个构造函数，传入的参数正是外部的实例对象。 再看看Enclosing$1LocalClass.class:
class corejava/Enclosing$1LocalClass { synthetic final java.util.List val$localList; synthetic final corejava.Enclosing this$0; Enclosing$1LocalClass(corejava.Enclosing arg0, java.util.List arg1) { // &amp;lt;init&amp;gt; //(Lcorejava/Enclosing;Ljava/util/List;)V  &amp;lt;sig:()V&amp;gt; &amp;lt;localVar:index=0 , name=this , desc=Lcorejava/Enclosing$1LocalClass;, sig=null, start=L1, end=L2&amp;gt; &amp;lt;localVar:index=1 , name=this$0 , desc=Lcorejava/Enclosing;, sig=null, start=L1, end=L2&amp;gt; L1 { aload0 // reference to self  aload1 // reference to arg0  putfield corejava/Enclosing$1LocalClass.this$0:corejava.Enclosing aload0 // reference to self  aload2 putfield corejava/Enclosing$1LocalClass.val$localList:java.util.List aload0 // reference to self  invokespecial java/lang/Object &amp;lt;init&amp;gt;(()V); return } L2 { } } public bar() { //()V  &amp;lt;localVar:index=0 , name=this , desc=Lcorejava/Enclosing$1LocalClass;, sig=null, start=L1, end=L2&amp;gt; L1 { getstatic java/lang/System.out:java.io.PrintStream aload0 // reference to self  getfield corejava/Enclosing$1LocalClass.val$localList:java.util.List invokevirtual java/io/PrintStream println((Ljava/lang/Object;)V); } L3 { getstatic java/lang/System.out:java.io.PrintStream aload0 // reference to self  getfield corejava/Enclosing$1LocalClass.this$0:corejava.Enclosing invokestatic corejava/Enclosing access$100((Lcorejava/Enclosing;)Ljava/util/List;); invokevirtual java/io/PrintStream println((Ljava/lang/Object;)V); } L4 { return } L2 { } } } 很明显，编译器也帮我们合成了构造器，并且除了传入外部实例对象，还有额外的参数是改本地类中引用到的本地变量的引用。 那我们现在来解释为什么对于本地类中引用的变量需要加final： language designers wanted value of copied local variable to be &amp;ldquo;consistent&amp;rdquo; every time such a copy is created
</content>
    </entry>
    
     <entry>
        <title>closure</title>
        <url>http://yangchao.me/post/closure/</url>
        <categories>
          <category>Uncategorized</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html"> 简单地说，闭包是指一种记录record，保存着一个函数和一个环境envoronment，此环境记录着自由变量的名字-值或存储位置
因此，区别于普通函数关键在于那个存有自由变量free variables的环境。即使函数在scope外面调用，此enviroment仍然保留。
</content>
    </entry>
    
     <entry>
        <title>JavaScript execution using single thread (zz)</title>
        <url>http://yangchao.me/post/javascript-execution-using-single-thread-zz/</url>
        <categories>
          <category>Uncategorized</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html">  面试的时候发现99%的童鞋不理解为什么JavaScript是单线程的却能让AJAX异步发送和回调请求，还有setTimeout也看起来像是多线程的？还有non-blocking IO, event loop等概念很不清楚。来深入分析一下：
首先看下面的代码：
function foo() { console.log( &amp;#39;first&amp;#39; ); setTimeout( ( function(){ console.log(&amp;#39;second&amp;#39;); } ), 5); } for (var i = 0; i &amp;lt; 1000000; i&#43;&#43;) { foo(); } 执行结果会首先全部输出first，然后全部输出second；尽管中间的执行会超过5ms。为什么？ Javascript执行是单线程的 因为JS运行在浏览器中，是单线程的，每个window一个JS线程，既然是单线程的，在某个特定的时刻只有特定的代码能够被执行，并阻塞其它的代码。而浏览器是事件驱动的（Event driven），浏览器中很多行为是异步（Asynchronized）的，会创建事件并放入执行队列中。javascript引擎是单线程处理它的任务队列，你可以理解成就是普通函数和回调函数构成的队列。当异步事件发生时，如mouse click, a timer firing, or an XMLHttpRequest completing（鼠标点击事件发生、定时器触发事件发生、XMLHttpRequest完成回调触发等），将他们放入执行队列，等待当前代码执行完成。
异步事件驱动 前面已经提到浏览器是事件驱动的（Event driven），浏览器中很多行为是异步（Asynchronized）的，例如：鼠标点击事件、窗口大小拖拉事件、定时器触发事件、XMLHttpRequest完成回调等。当一个异步事件发生的时候，它就进入事件队列。浏览器有一个内部大消息循环，Event Loop（事件循环），会轮询大的事件队列并处理事件。例如，浏览器当前正在忙于处理onclick事件，这时另外一个事件发生了（如：window onSize），这个异步事件就被放入事件队列等待处理，只有前面的处理完毕了，空闲了才会执行这个事件。setTimeout也是一样，当调用的时候，js引擎会启动定时器timer，大约xxms以后执行xxx，当定时器时间到，就把该事件放到主事件队列等待处理（浏览器不忙的时候才会真正执行）。
每个浏览器具体实现主事件队列不尽相同，这不谈了。
JavaScript引擎有事件处理队列，纯粹是为了在单线程执行限制下为了响应异步事件。
non-blocking 所有操作都不阻塞, I/O(xhr, indexDb)操作都是non-blocking. 但是也有例外：alert(..)
浏览器不是单线程的 虽然JS运行在浏览器中，是单线程的，每个window一个JS线程，但浏览器不是单线程的，例如Webkit或是Gecko引擎，都可能有如下线程：
 javascript引擎线程 界面渲染线程 浏览器事件触发线程 Http请求线程 事件队列循环线程 很多童鞋搞不清，如果js是单线程的，那么谁去轮询大的Event loop事件队列？答案是浏览器会有单独的线程去处理这个队列。  Ajax异步请求是否真的异步? 很多童鞋搞不清楚，既然说JavaScript是单线程运行的，那么XMLHttpRequest在连接后是否真的异步? 其实请求确实是异步的，这请求是由浏览器新开一个线程请求（见前面的浏览器多线程）。当请求的状态变更时，如果先前已设置回调，这异步线程就产生状态变更事件放到 JavaScript引擎的事件处理队列中等待处理。当浏览器空闲的时候出队列任务被处理，JavaScript引擎始终是单线程运行回调函数。javascript引擎确实是单线程处理它的任务队列，能理解成就是普通函数和回调函数构成的队列。
总结一下，Ajax请求确实是异步的，这请求是由浏览器新开一个线程请求，事件回调的时候是放入Event loop单线程事件队列等候处理。
setTimeout(func, 0)为什么有时候有用？ 写js多的童鞋可能发现，有时候加一个setTimeout(func, 0)非常有用，为什么？难道是模拟多线程吗？错！前面已经说过了，javascript是JS运行在浏览器中，是单线程的，每个window一个JS线程，既然是单线程的，setTimeout(func, 0)神奇在哪儿？那就是告诉js引擎，在0ms以后把func放到主事件队列中，等待当前的代码执行完毕再执行，注意：重点是改变了代码流程，把func的执行放到了等待当前的代码执行完毕再执行。这就是它的神奇之处了。它的用处有三个：
 让浏览器渲染当前的变化（很多浏览器UI render和js执行是放在一个线程中，线程阻塞会导致界面无法更新渲染） 重新评估”script is running too long”警告 改变执行顺序 例如：下面的例子，点击按钮就会显示&amp;rdquo;calculating&amp;hellip;.&amp;ldquo;，如果删除setTimeout就不会。因为reDraw事件被进入事件队列到长时间操作的最后才能被执行，所以无法刷新。  &amp;lt;button id=&amp;#39;do&amp;#39;&amp;gt; Do long calc!&amp;lt;/button&amp;gt; &amp;lt;div id=&amp;#39;status&amp;#39;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;br&amp;gt;// Write JavaScript here  $(&amp;#39;#do&amp;#39;).on(&amp;#39;click&amp;#39;, function(){ $(&amp;#39;#status&amp;#39;).text(&amp;#39;calculating....&amp;#39;); //此处会触发redraw事件的fired，但会放到队列里执行，直到long()执行完。  // without set timeout, user will never see &amp;#34;calculating....&amp;#34;  //long();//执行长时间任务，阻塞  // with set timeout, works as expected  setTimeout(long,0);//用定时器，大约50ms以后执行长时间任务，放入执行队列，但在redraw之后了，根据先进先出原则  }) function long(){ var result = 0 for (var i = 0; i&amp;lt;1000; i&#43;&#43;){ for (var j = 0; j&amp;lt;1000; j&#43;&#43;){ for (var k = 0; k&amp;lt;1000; k&#43;&#43;){ result = result &#43; i&#43;j&#43;k } } } $(&amp;#39;#status&amp;#39;).text(&amp;#39;calclation done&amp;#39;) // has to be in here for this example. or else it will ALWAYS run instantly. This is the same as passing it a callback } 非阻塞js的实现（non-blocking javascript） js在浏览器中需要被下载、解释并执行这三步。在html body标签中的script都是阻塞的。也就是说，顺序下载、解释、执行。尽管Chrome可以实现多线程并行下载外部资源，例如：script file、image、frame等（css比较复杂，在IE中不阻塞下载，但Firefox阻塞下载）。但是，由于js是单线程的，所以尽管浏览器可以并发加快js的下载，但必须依次执行。所以chrome中image图片资源是可以并发下载的，但外部js文件并发下载没有多大意义。

要实现非阻塞js（non-blocking javascript）有两个方法：1. html5 2. 动态加载js
首先一种办法是HTML5的defer和async关键字：
defer
&amp;lt;script type=&amp;#34;text/javascript&amp;#34; defer src=&amp;#34;foo.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt;  async  ```java &amp;lt;script type=&#34;text/javascript&#34; async src=&#34;foo.js&#34;&amp;gt;&amp;lt;/script&amp;gt; ```   然后第二种方法是动态加载js： ```java setTimeout(function(){ var script = document.createElement(&#34;script&#34;); script.type = &#34;text/javascript&#34;; script.src = &#34;foo.js&#34;; var head = true; //加在头还是尾 if(head) document.getElementsByTagName(&#34;head&#34;)[0].appendChild(script); else document.body.appendChild(script); }, 0); //另外一个独立的动态加载js的函数 function loadJs(jsurl, head, callback){ var script=document.createElement(&#39;script&#39;); script.setAttribute(&#34;type&#34;,&#34;text/javascript&#34;); if(callback){ if (script.readyState){ //IE script.onreadystatechange = function(){ if (script.readyState == &#34;loaded&#34; || script.readyState == &#34;complete&#34;){ script.onreadystatechange = null; callback(); } }; } else { //Others script.onload = function(){ callback(); }; } } script.setAttribute(&#34;src&#34;, jsurl); if(head) document.getElementsByTagName(&#39;head&#39;)[0].appendChild(script); else document.body.appendChild(script); } ```  </content>
    </entry>
    
     <entry>
        <title>HTTP cache</title>
        <url>http://yangchao.me/post/http-cache/</url>
        <categories>
          <category>Uncategorized</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html"> Request headers:
If-Modified-Since: {time} If-None-Match: {etag} These two headers are used to check if the cached resource is still fresh.
If expired, response status is 200 and fetch the resource
If not, response status is 304 and cache is still fresh.
Response headers:
Last-Modified: {time}ETag: {etag}Expire: {time} Cache-Control: maxAge={seconds} </content>
    </entry>
    
     <entry>
        <title>JavaEE Multi-popuse Application Frameworks</title>
        <url>http://yangchao.me/post/javaee-multi-popuse-application-frameworks/</url>
        <categories>
          <category>Project Architecture</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html"> This is an application framework to satisfy all kinds of purposes.
Firstly, it would support all sort of channels, which I mean a variety of protocols, message formats, channel-in &amp;amp; chennel-out technologies and application scenarios. Typical ones are like http, jms, tcp, web service and formats:json, soap, FIX, iso 8583, customized fix-length.
Secondly, it would abstract the channel-related processing, and make business logic development separate from these channel details. For example, we need to make our service layer transparent for the channel, and not aware of the protocols, devices, client types.
A key design consideration is we use a data bus conception. We can extract all the channel-related data into this data bus. This data bus is the data context going through all the processing of a request.
And to acquire the flexibility and the extensibility, we use an interceptor chain mechanism., which is very similar to the Servlet filters, or the Spring interceptor.
For the business logic, we designed the Process and Action concepts. Basically, a Process is a flow of processing, which can combine multiple actions and can be configured as complicated flow just like the workflow definition.
For the channel adaptor, we need to implement them one by one. For example, we implement the HTTP channel just using Spring MVC and extending it. For the TCP channel, we use the Netty library to implement the server and client.
And another important thing is the message transformation. All the data format can be defined by XML. and you can freely use all the message format for response or request. The transformation happens automatically.
The following is a high-level conception diagram:
&amp;nbsp;
</content>
    </entry>
    
     <entry>
        <title>statically loading vs. dynamically loading</title>
        <url>http://yangchao.me/post/statically-loading-vs-dynamically-loading/</url>
        <categories>
          <category>Basics</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html">  statically loading when we need to use the class definition, like new operator, invoking static method, accessing static variables etc, the JVM will load the class statically.
But just declare variable of that type, class loading actually don&amp;rsquo;t happen.
class StaticallyLoading { public static void main(String[] args) { C c = null; System.out.println(&amp;#34;run here&amp;#34;); } } After you compile this class successfully with class C definition, you run it as deleting the class C dependency at runtime.
This program can run normally.
But if you do some operations, like
 C c = new C(); C.foo() Once the C class doesn&amp;rsquo;t exist at runtime, a NoClassDefFoundException will be thrown.  dynamically loading  Class.forName(..) ClassLoader.findSystemClass(..) ClassLoader.findClass(..) ClassNoFoundException will be thrown if the class cannot be found at runtime.  </content>
    </entry>
    
     <entry>
        <title>Logging problem in Spring MVC project</title>
        <url>http://yangchao.me/post/logging-problem-in-spring-mvc-project/</url>
        <categories>
          <category>Project problems</category>
        </categories>
        <tags>
          <tag>Logging</tag>
        </tags>
        <content type="html">  Spring MVC uses JCL as its logging framework.
A strange problem is when front-end reports an error, I cannot find exception stack in the log file.
Why does Spring &amp;ldquo;swallow&amp;rdquo; the exception log? A reason is I don&amp;rsquo;t config any exception handler and the default HanderExceptionResolvers don&amp;rsquo;t log the exceptions at all.
Another reason is the logging API delegation problem.
I use SLF4J as the logging API, and use Log4j as its inherit implementation.
SLF4J supports different implementation adapter, and all kinds of other logging API bridge.
Basically, adapter is used to tell SLF4j what is the implementation for the API, and bridge is used to delegate other logging API to SLF4J if you use some components using other logging framework, like JCL, JUL or logback.
But notice, you cannot use the adapter and bridge together for the same logging framework, for example, slf4j-log4j12.jar and log4j-over-slf4j.jar cannot be in the classpath at the same time.
A sample configurations is shown as following.
&amp;lt;!-- Logging --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;slf4j-api&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.7.10&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- logging implementation --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;slf4j-log4j12&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.6.6&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- logging implementation adaptor --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;log4j&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;log4j&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.2.17&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- logging bridges --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;jcl-over-slf4j&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.7.10&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;jul-to-slf4j&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.7.10&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt;</content>
    </entry>
    
     <entry>
        <title>No mapping found for HTTP request with URI [WEB-INF/views/xxx.jsp]</title>
        <url>http://yangchao.me/post/no-mapping-found-for-http-request-with-uri-web-infviewsxxx-jsp/</url>
        <categories>
          <category>Project problems</category>
        </categories>
        <tags>
          <tag>Spring MVC</tag>
        </tags>
        <content type="html">  When I use the InternalResourceViewResolver for the JSP rendering, I found the spring complains:
No mapping found for HTTP request with URI [WEB-INF/views/xxx.jsp] I don&amp;rsquo;t know why. Normally, it certainly uses this resolver, because spring got the prefix and suffix I set. I open the debug logging, and found the log says:
-mvc-servlet forwards to WEB-INF/views/xxx.jsp -No handler method found So it goes to find a hander method, rather than renders directly. Why? Why?
At last, I found it&amp;rsquo;s the servlet-mapping problem. I map the dispatcher servlet to &amp;ldquo;/*&amp;rdquo; instead of &amp;ldquo;/&amp;rdquo;. Thus all files include *.jsp also go through the dispatcher servlet. Obviously, I never map the jsp URL to any handler method.
url-pattern: /* and / the difference is : &amp;gt; SRV.11.2 Specification of Mappings &amp;gt; &amp;gt; &amp;gt; In theWeb application deployment descriptor, the following syntax is used to define mappings: &amp;gt; &amp;gt; &amp;gt; * A string beginning with a / character and ending with a /* suffix is used for path mapping. &amp;gt; &amp;gt; * A string beginning with a *. prefix is used as an extension mapping. &amp;gt; &amp;gt; * A string containing only the / character indicates the &amp;ldquo;default&amp;rdquo; servlet of the application. In this case the servlet path is the request URI minus the context path and the path info is null. &amp;gt; &amp;gt; * All other strings are used for exact matches only. &amp;gt; &amp;gt; &amp;gt; The pattern /* will force everything through your servlet. &amp;gt; &amp;gt; The pattern / will make your servlet the default servlet for the app, meaning it will pick up as fallback every pattern that doesn&amp;rsquo;t have another exact match. So that&amp;rsquo;s it!
</content>
    </entry>
    
     <entry>
        <title>GC revisit</title>
        <url>http://yangchao.me/post/gc-revisit/</url>
        <categories>
          <category>JVM</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html">  In the another post, I give a short introduction of GC.
Now for the practical purpose, I need to focus on the common used GCs: Parallel GC, CMS and G1.
What is the tracing algorithm and mark-and-sweep method? root objects
Root objects are the starting point of marking phase. Usually, root object references are located in the thread stacks.
object graph
Every object has its fields, if a field is a object reference, then the reference will be like a pointer to another object.
From the point of whole heap, these objects will form an object graph.
Heap layout generational heap G1 heap GC process illustrations tuning options tuning the minor GC tuning the full GC &amp;nbsp;
</content>
    </entry>
    
     <entry>
        <title>Java Serialization</title>
        <url>http://yangchao.me/post/java-serialization/</url>
        <categories>
          <category>Basics</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html">  Serialization What is Serialization? Serialization is the process to transfer a Java object into a sequence of bytes, often in the form of stream.
At another time, we can unserialize from the bytes and rebuild the object in JVM.
How to do  make the class to be serialized implement Serializable interface (Serializable is a marker interface) use ObjectOutputStream to serialize object use OjbectInputStream to unserialize the bytes In order to better control the serialization process, you can implement ObjectInput and ObjectOutput on your own.  ObjectOutputStream has implemented ObjectOutput interface; ObjectInputStream has implemented ObjectInput interface
What information is serialized Simply, the sequence of bytes includes:
 instance fields (excluding the transient one) class name (just name!!) class serialVersionUID &amp;gt; So when you serialize an object in a JVM, and unserialize it in another JVM. The latter JVM just knows the class name. If you don&amp;rsquo;t provide the class file, then you cannot cast it to the correct specified class even if you know the class name. Java RMI heavily uses the Serialization technology and extends it, because remote invocation usually happens in different JVMs. So class file and related dependent classes also need to be transferred along with the object serialization stream.  What is serialVersionUID? serialVersionUID is used to version the serializable class. When the unique id of the class in serialization and unserialzation is different, java.io.InvalidClassException will be thrown.
All serializable class automatically generates this unique id implicitly. But you can specify it explicitly:
static final long serialVersionUID = 229383940L; Alternatively, the JDK comes with a serialver tool.
Example public class SerializationInOneJVM { @Test public void testWrite() throws Exception { FileOutputStream fos = new FileOutputStream(&amp;#34;a.bin&amp;#34;); ObjectOutputStream oos = new ObjectOutputStream(fos); oos.writeObject(new SerializableObject()); fos.close(); } } // SerializableObject not in the classpath of this JVM public class UnserializationInAnotherJVM { @Test public void testRead() throws Exception { FileInputStream fis = new FileInputStream(&amp;#34;a.bin&amp;#34;); ObjectInputStream ois = new ObjectInputStream(fis); Object o = ois.readObject(); System.out.println(o.getClass()); //here we cannot cast to the concrete class.  fis.close(); } } &amp;nbsp;
</content>
    </entry>
    
     <entry>
        <title>Java Collections Framework</title>
        <url>http://yangchao.me/post/java-collections-framework/</url>
        <categories>
          <category>Basics</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html">  (natural) ordered structure Red-Black Tree implementation to maintain the natural order (Comparable)
 TreeSet -&amp;gt; NavigableSet -&amp;gt; OrderedSet TreeMap -&amp;gt; NavigableMap -&amp;gt; OrderedMap  hash structure a bucket array, each bucket is a LinkedList; the index is computed by hashCode(), then traverse the LinkedList using equals() until finding the expected element.
 HashMap HashSet: backed by HashMap, just the element is the key of Entry&amp;amp;lt;K,V&amp;amp;gt; while the value is ignored. with insertion order  maintain the insertion order using an extra LinkedList
 LinkedHashSet LinkedHashMap: as above special map
 IdentityHashMap: compare the key using == instead of equals()
 WeekHashMap: key is week reference
  public void test() { Map map = new IdentityHashMap(); String a = new String(&amp;#34;aa&amp;#34;); String b = new String(&amp;#34;aa&amp;#34;); map.put(a, 1); map.put(b, 2); System.out.println(a == b); //false  System.out.println(a.equals(b)); //true  System.out.println(map.get(a)); //1  System.out.println(map.get(b)); //2  } immutable, hash key capacity, load factor and rehash Collections, Arrays static factory  Arrays.asList(..) Collections.singleton(..) / singletonList(..) / singletonMap(..) Collections.emptySet/ emptyList(..) / emptyMap(..) / emptyOrderedMap(..) Collections.checkedSet(..) / checkedList(..) / checkedMap(..) Collections.nCopies(..)  sort / search  sort(..) / sort(.., Comparator) binarySearch(..) / binarySearch(.., Comparator)  unmodifiedXX() other common operations  shuffle(..) reverse(..) rotate(.., distance) fill(..) swap(..) copy(..) replaceAll(..) indexOfSubList(..) min(..) / max(..) disjoint(..) frequency(..)  a comparator  reverseOrder(..)  concurrent collection fail-fast mechanism, ConcurrentModificationException and Iterator Java collections use fail-fast mechanism to prevent multiple threads to modify the collection when traversing it. Even there is only one thread, you modify the collection when you traverse it in the single thread, fail-fast will also be applied.
That will case ConcurrentModificationException.
Using Interator.remove(..) method will avoid this.
sychronizedXX(), JUC collections sychronizedXX() makes every method wrapped in a synchronized block. So the efficiency is a big problem.   not thread-safe collections thread-safe collections   ArrayList CopyOnWriteArrayList   HashSet CopyOnWriteArraySet   LinkedList ConcurrentLinkedQueue   HashMap ConcurrentHashMap   TreeMap ConcurrentSkipListMap   TreeSet ConcurrentSkipListSet   
 CopyOnWriteArrayList This implementation always copy the backed array and set the backed array to this new one when modifying the List.  The modification operations are thread-safe by using a ReentrantLock.
So it&amp;rsquo;s suitable for the case that writing is greatly less than reading.
Once an interator has been gotten, it will see a snapshot of the array.
public void test() { List&amp;lt;Integer&amp;gt; list = new CopyOnWriteArrayList&amp;lt;Integer&amp;gt;(Arrays.asList(0, 1, 2, 3, 4, 5, 6, 7)); for(int i : list) { if(i == 2) { list.add(8, 8); } System.out.println(i); } System.out.println(list); } 0 1 2 3 4 5 6 7 [0, 1, 2, 3, 4, 5, 6, 7, 8] &amp;nbsp;
http://www.cnblogs.com/skywang12345/p/java_threads_category.html
&amp;nbsp;
&amp;nbsp;
&amp;nbsp;
</content>
    </entry>
    
     <entry>
        <title>MySQL InnoDB Locking and Isolation Level</title>
        <url>http://yangchao.me/post/mysql-innodb-locking-and-isolation-level/</url>
        <categories>
          <category>Databases</category>
        </categories>
        <tags>
          <tag>InnoDB</tag><tag>MySQL</tag>
        </tags>
        <content type="html">  Basic knowledge Isolation Level  MySQL innodb engine support ACID appliance. (The following will be always applied to innodb) Innodb supports 4 Isolation Levels: READ UNCOMMITTED, READ COMMITTED, UNREPEATABLE READ, SERIALIZABLE
 Innodb&amp;rsquo;s Isolation level is slightly different from the standard SQL Isolation level definition:    Read Uncommitted Read Committed Repeatable Read Serializable   dirty reads yes no no no   unrepeatable reads yes yes no no   phantom reads yes yes no no    MySQL suggests to use Read Uncommitted and Serializable rarely.
Repeatable Read is the default Isolation Level, which can ensure repeatable reads and no phantom reads.
Index structure InnoDB has two types of index: clustered index, secondary indexes
Clustered index is synonymous with the primary key, which means the record is stored in the leaf node of the index B&#43; Tree.
The key of leaf is the primary key. Even if you haven&amp;rsquo;t specified any primary key, innodb will generate a hidden one for you.
Secondary indexes are the ones other than the primary index. It doesn&amp;rsquo;t store the record data, but has a pointer to the primary index.
CREATE TABLE article ( id INT UNSIGNED NOT NULL AUTO_INCREMENT, userid VARCHAR(20) NOT NULL, blogid CHAR(4), pubtime TIMESTAMP NOT NULL, comment VARCHAR(1024), PRIMARY KEY(id), KEY when_who (pubtime, userid) ) ENGINE=InnoDB DEFAULT CHARSET latin1; Locking MySQL support multiple granularity locking .
Lock modes &amp;nbsp;
 row-level: S lock and X lock (S - shared/read, X - exclusive/write) table-level: IS lock and IX lock (IS - intention shared/read, IX - intention exclusive/write)      X IX S IS     X Conflict Conflict Conflict Conflict   IX Conflict Compatible Conflict Compatible   S Conflict Conflict Compatible Compatible   IS Conflict Compatible Compatible Compatible     SELECT ... LOCK IN SHARE MODE sets an _IS_ lock and SELECT ... FOR UPDATE sets an _IX _lock.  A lock is granted to a requesting transaction if it is compatible with existing locks, but not if it conflicts with existing locks. A transaction waits until the conflicting existing lock is released.
Intention locks do not block anything except full table requests (for example, LOCK TABLES ... WRITE)
Lock types  Record lock: This is a lock on an index record. Gap lock: This is a lock on a gap between index records, or a lock on the gap before the first or after the last index record. Next-key lock: This is a combination of a record lock on the index record and a gap lock on the gap before the index record. A next-key lock is an index-record lock plus a gap lock on the gap preceding the index record. InnoDB uses clustered index and the row data are always in the leaf of the index B&#43; Tree. Thus, the row-level locks are actually index-record locks  Nonlocking - Consistent Nonlocking reads Consistent read is the default mode in which InnoDB processes SELECT statements in READ COMMITTED andREPEATABLE READ isolation levels.
In REPEATABLE READ, all consistent reads within the same transaction read the snapshot established by the first such read in that transaction.
In READ COMMITTED, each consistent read within a transaction sets and reads its own fresh snapshot. (snapshot update at every read statement)
MVCC is used to naturally implement REPEATABLE READ.
Locking in different Isolation Level    Read Uncommitted(RU) Read Committed(RC) Repeatable Read(RR) Serializable   consistent reads [`SELECT ... FROM`](http://dev.mysql.com/doc/refman/5.6/en/select.html &#34;13.2.9 SELECT Syntax&#34;) no lockearlier version might be used(dirty read) no lockeach consistent read reads its own fresh snapshot no lockall consistent reads read the snapshot established by the first read implicitly converts [`SELECT`](http://dev.mysql.com/doc/refman/5.6/en/select.html &#34;13.2.9 SELECT Syntax&#34;) statements to [`SELECT ... LOCK IN SHARE MODE`](http://dev.mysql.com/doc/refman/5.6/en/select.html &#34;13.2.9 SELECT Syntax&#34;)   locking reads [`SELECT ... FROM ... LOCK IN SHARE MODE`](http://dev.mysql.com/doc/refman/5.6/en/select.html &#34;13.2.9 SELECT Syntax&#34;) like RC locks only index records, no gap locks except for foreign-key constraint checking and duplicate-key checking unique index: locks only the index record foundother search condition: locks the index range scanned, using [gap locks](http://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_gap_lock &#34;gap lock&#34;) or [next-key locks](http://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_next_key_lock &#34;next-key lock&#34;) like RR   [`SELECT ... FROM ... FOR UPDATE`](http://dev.mysql.com/doc/refman/5.6/en/select.html &#34;13.2.9 SELECT Syntax&#34;)   [`UPDATE ... WHERE ...`](http://dev.mysql.com/doc/refman/5.6/en/update.html &#34;13.2.11 UPDATE Syntax&#34;)   [`DELETE FROM ... WHERE ...`](http://dev.mysql.com/doc/refman/5.6/en/delete.html &#34;13.2.2 DELETE Syntax&#34;)    [`INSERT`](http://dev.mysql.com/doc/refman/5.6/en/insert.html &#34;13.2.5 INSERT Syntax&#34;) index-record exclusive lock, not a next-key lockif a duplicate-key error occurs, a shared lock on the duplicate index record is set.            </content>
    </entry>
    
     <entry>
        <title>JVM dump lab</title>
        <url>http://yangchao.me/post/jvm-dump-lab/</url>
        <categories>
          <category>Performance</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html">  IBM dump files [pdf-embedder url=&amp;ldquo;/media/WSTE-02092010-DeepDiveJVMJavacoresJavaDumps-Grigorenko.pdf&amp;rdquo;]
What is java core (or javadump or thread dump)? A java core is a snapshot of the threads at work in a JVM. It also details a cross section of information from the major components in the JVM like XM,XE, LK, etc (IBM Javacore only, Sun does not – it just shows threads)
A Java dump, also known as a Java core, Java thread dump, or a thread dump is a file that contains the following sections:
 All of the threads that run on a Java Virtual Machine (JVM). All of the monitors on a JVM. Some useful information about the system that the JVM runs under.  # kill list 1) SIGHUP 2) SIGINT 3) SIGQUIT 4) SIGILL 5) SIGTRAP 6) SIGABRT 7) SIGBUS 8) SIGFPE 9) SIGKILL 10) SIGUSR1 11) SIGSEGV 12) SIGUSR2 13) SIGPIPE 14) SIGALRM 15) SIGTERM 16) SIGSTKFLT 17) SIGCHLD 18) SIGCONT 19) SIGSTOP 20) SIGTSTP 21) SIGTTIN 22) SIGTTOU 23) SIGURG 24) SIGXCPU 25) SIGXFSZ 26) SIGVTALRM 27) SIGPROF 28) SIGWINCH 29) SIGIO 30) SIGPWR 31) SIGSYS 34) SIGRTMIN 35) SIGRTMIN&#43;1 36) SIGRTMIN&#43;2 37) SIGRTMIN&#43;3 38) SIGRTMIN&#43;4 39) SIGRTMIN&#43;5 40) SIGRTMIN&#43;6 41) SIGRTMIN&#43;7 42) SIGRTMIN&#43;8 43) SIGRTMIN&#43;9 44) SIGRTMIN&#43;10 45) SIGRTMIN&#43;11 46) SIGRTMIN&#43;12 47) SIGRTMIN&#43;13 48) SIGRTMIN&#43;14 49) SIGRTMIN&#43;15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12 53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9 56) SIGRTMAX-8 57) SIGRTMAX-7 58) SIGRTMAX-6 59) SIGRTMAX-5 60) SIGRTMAX-4 61) SIGRTMAX-3 62) SIGRTMAX-2 63) SIGRTMAX-1 64) SIGRTMAX &amp;nbsp;
What is a heap dump? A heapdump is a snapshot of JVM memory – it shows the live objects on the heap along with references between objects. It is used to determine memory usage patterns and memory leak suspects.
A heap dump is a snapshot of memory at a given point in time. It contains information on the Java objects and classes in memory at the time the snapshot was taken. In the same way that thread dumps are an instant in time a single heap dump cannot provide much in the way of temporal information to answer questions like “where did an object come from?” or “what has it been doing?”
Heap dumps come in various formats:
 the Sun VM generates HPROF the IBM VM provides portable heap dump (PHD) files. At Rally we run Sun’s VM so usually work with HPROF dumps. The internals vary a little but the basic principals are still the same.
 See more at: https://www.rallydev.com/blog/engineering/outofmemoryerror-fun-heap-dump-analysis#sthash.We3ozSN9.dpuf
  How to get a heap dump?
Executing the Java VM with the appropriate parameters:
 -XX:&#43;HeapDumpOnOutOfMemoryError writes heap dump on OutOfMemoryError (recommended) -XX:&#43;HeapDumpOnCtrlBreak writes heap dump together with thread dump on CTRL&#43;BREAK by default enabled on WebSphere  #java -Xdump:what Registered dump agents ---------------------- dumpFn=doSystemDump events=gpf&#43;abort filter= label=//core.%Y%m%d.%H%M%S.%pid.%seq.dmp range=1..0 priority=999 request=serial opts= ---------------------- dumpFn=doSnapDump events=gpf&#43;abort filter= label=//Snap.%Y%m%d.%H%M%S.%pid.%seq.trc range=1..0 priority=500 request=serial opts= ---------------------- dumpFn=doSnapDump events=systhrow filter=java/lang/OutOfMemoryError label=//Snap.%Y%m%d.%H%M%S.%pid.%seq.trc range=1..4 priority=500 request=serial opts= ---------------------- dumpFn=doHeapDump events=systhrow filter=java/lang/OutOfMemoryError label=//heapdump.%Y%m%d.%H%M%S.%pid.%seq.phd range=1..4 priority=40 request=exclusive&#43;compact&#43;prepwalk opts=PHD ---------------------- dumpFn=doJavaDump events=gpf&#43;user&#43;abort filter= label=//javacore.%Y%m%d.%H%M%S.%pid.%seq.txt range=1..0 priority=10 request=exclusive opts= ---------------------- dumpFn=doJavaDump events=systhrow filter=java/lang/OutOfMemoryError label=//javacore.%Y%m%d.%H%M%S.%pid.%seq.txt range=1..4 priority=10 request=exclusive opts= ---------------------- Or you can run the jmap tool:
 Sun (Linux, Solaris; not on Windows) JMap Java 5: jmap -heap:format=b Sun (Linux, Solaris; Windows see link) JMap Java 6: jmap.exe -dump:format=b,file=HeapDump.hprof Sun (Linus, Solaris) JMap with Core Dump File: jmap -dump:format=b,file=HeapDump.hprof /path/to/bin/java core_dump_file Sun JConsole: Launch jconsole.exe and invoke operation dumpHeap() on HotSpotDiagnostic MBean SAP JVMMon: Launch jvmmon.exe and call menu for dumping the heap  What is system core dump and snap trace? Analyzer Tools ThreadAnalyzer  ThreadAnalyzer is a problem determination tool for WebSphere Application Server thread performance and deadlock detection. You can use it to obtain a Java dump from an application server and use its analysis features for problem determination. For performance problem determination, ThreadAnalyzer provides a top-of-the-stack (TOS) analysis that counts all of the methods at the top of the stack for the listed threads.
 It then sorts them by ‘weight’ (automatically computed by ThreadAnalyzer), and lists the possible performance bottlenecks in your application. ThreadAnalyzer does automatic deadlock detection while it analyzes the Java dump. Downloading ThreadAnalyzer
  To download ThreadAnalyzer go to
http://www.ibm.com/developerworks/websphere/downloads/thread_analyzer.html
IBM Thread and Monitor Dump Analyzer for Java  During the run time of a Java™ process, some Java Virtual Machiness (JVMs) may not respond predictably and oftentimes seem to hang up for a long time or until JVM shutdown occurs. It is not easy to determine the root cause of these sorts of problems.
 By triggering a javacore when a Java process does not respond, it is possible to collect diagnostic information related to the JVM and a Java application captured at a particular point during execution. For example, the information can be about the operating system, the application environment, threads, native stack, locks, and memory. The exact contents are dependent on the platform on which the application is running.
 On some platforms, and in some cases, javacore is known as “javadump.” The code that creates javacore is part of the JVM. One can control it by using environment variables and run-time switches. By default, a javacore occurs when the JVM terminates unexpectedly. A javacore can also be triggered by sending specific signals to the JVM. Although javacore or javadump is present in Sun Solaris JVMs, much of the content of the javacore is added by IBM and, therefore, is present only in IBM JVMs.
 IBM Thread and Monitor Dump Analyzer for Java analyzes javacore and diagnoses monitor locks and thread activities in order to identify the root cause of hangs, deadlocks, and resource contention or monitor bottlenecks. How does it work?
 This technology analyzes each thread information and provides diagnostic information, such as current thread information, the signal that caused the javacore, Java heap information (maximum Java heap size, initial Java heap size, garbage collector counter, allocation failure counter, free Java heap size, and allocated Java heap size), number of runnable threads, total number of threads, number of monitors locked, and deadlock information.
 In addition, IBM Thread and Monitor Dump Analyzer for Java provides the recommended size of the Java heap cluster (applicable only to IBM SDK 1.4.2 and 1.3.1 SR7 or above) based on the heuristic analysis engine.
 IBM Thread and Monitor Dump Analyzer for Java compares each javacore and provides process ID information for threads, time stamp of the first javacore, time stamp of the last javacore, number of garbage collections per minute, number of allocation failures per minute, time between the first javacore and the last javacore, number of hang suspects, and list of hang suspects.
 This technology also compares all monitor information in javacore and detects deadlock and resource contention or monitor bottlenecks, if there are any.
  HeapAnalyzer  HeapAnalyzer allows the finding of a possible Java™ heap leak area through its heuristic search engine and analysis of the Java heap dump in Java applications.
 Java heap areas define objects, arrays, and classes. When the Garbage Collector allocates areas of storage in the heap, an object continues to be live while a reference to it exists somewhere in the active state of the JVM; therefore the object is reachable. When an object ceases to be referenced from the active state, it becomes garbage and can be reclaimed for reuse.
 When this reclamation occurs, the Garbage Collector must process a possible finalizer and also ensure that any internal JVM resources that are associated with the object are returned to the pool of such resources. Java heap dumps are snap shots of Java heaps at specific times. How does it work?
  HeapAnalyzer analyzes Java heap dumps by parsing the Java heap dump, creating directional graphs, transforming them into directional trees, and executing the heuristic search engine.
The following are examples of features:
 List of Java heap leak suspects Recommendation of the size of kCluster List of gaps among allocated objects/classes/arrays Java objects/classes/arrays search engine List of objects/classes/arrays by type name List of objects/classes/arrays by object name List of objects/classes/arrays by address List of objects/classes/arrays by size List of objects/classes/arrays by size of child List of objects/classes/arrays by number of child List of objects/classes/arrays by frequency List of available heap spaces by size Tree view of Java heap dump Loading/saving processed Java heap dumps.  Memory Analyzer The Memory Dump Diagnostic for Java (MDD4J) tool has been deprecated and is no longer available.
Memory Analyzer is in the portfolio of IBM Monitoring and Diagnostic Tools for Java, which are IBM&amp;rsquo;s primary troubleshooting tools for problems with Java applications. Memory Analyzer is the recommended heap dump analysis tool.
Memory Analyzer extends Eclipse MAT version 1.4 using the Diagnostic Tool Framework for Java (DTFJ) which enables Java heap analysis using operating system level dumps and IBM Portable Heap Dumps (PHD).
</content>
    </entry>
    
     <entry>
        <title>Book notes - Practical Unit Test with JUnit and Mockito</title>
        <url>http://yangchao.me/post/book-notes-practical-unit-test-with-junit-and-mockito/</url>
        <categories>
          <category>Building, Testing &amp;amp; CI</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html">  Developers&amp;rsquo; Tests On Tests and Tools SUT (aka. System Under Test) – test target being tested
DOC (aka. Dependency of Components) – collaborators and dependencies when testing
Types of Developers&amp;rsquo; Tests  Unit Test Integration Test End-to-End Test Every type of test has different scope. Basically, unit test is in class level, integration test is in module level and end-to-end test is in application level.  Other types of tests: - System Integration Test – test with external systems/applications, services etc - User Acceptation Test – final user verification test - Load Test – verify system performance under pressure / load
  **type of test** **SUT example** **DOC example**   unit test UserService UserDAO   Invoice Product   Client Account   integration test DAO layer (ORM based) Hibernate   DAO layer (JDBC based) MySQL 5   FullTextIndexer module FileStorage module   end-to-end test Whole application LDAP repository    Should Developers Test Their Own Code? Yes!
Unit Tests what is a Unit Test? It&amp;rsquo;s to make sure the class you are working on right now works correctly.
You should test your classes** in isolation**. When writing unit tests it&amp;rsquo;s important to test a single class and nothing more. Forget about databases, Spring configuration files, and external web services.
Concentrate on the logic of your class!
Interactions in Unit Tests Types of collaboration with an SUT
Test class has direct operations with SUT, but its collaborations have indirect operations on the SUT state.
We use direct inputs and indirect inputs (SUT receiveing some message) to set the SUT in a required state and to invoke its methods.
The direct and indirect outputs (SUT sending a message) of the SUT are expressions of the SUT&amp;rsquo;s behaviours; we use them to verify whether the SUT is working properly.
  **type of interaction** **involved parties** **description**   direct input Test class &amp;amp; SUT calls the SUT methods   direct output values returned by the SUT to the test class after calling some SUT method   indirect output SUT &amp;amp; DOCs arguments passed by the SUT to a method of one of its collaborators   indirect input value returned (or an exception thrown) to the SUT by collaborators, after it called some methods of its collaborators    State Testing vs. Interaction Testing  State Testing - uses direct inputs and outputs for what the results of actions. Interaction Testing - concentrates on how messages are passed between collaborators With State Testing, the SUT is a black box. Interaction testing looks inside the SUT and verifies its internal parts.  Writing Unit Testing Unit tests with no collaborator parameterized public class Money { private final int amount; private final String currency; public Money(int amount, String currency) { this.amount = amount; this.currency = currency; } public int getAmount() { return amount; } public String getCurrency() { return currency; } public boolean equals(Object anObject) { if (anObject instanceof Money) { Money money = (Money) anObject; return money.getCurrency().equals(getCurrency()) &amp;amp;&amp;amp; getAmount() == money.getAmount(); } return false; } }import org.junit.Test; import static org.junit.Assert.*; import org.junit.runner.RunWith; import org.junit.runners.Parameterized; @RunWith(Parameterized.class) public class MoneyParameterizedTest { @Parameterized.Parameters(name = &amp;#34;{index}: money({0}, {1})&amp;#34;) public static final Object[] data() { return new Object[] { new Object[] {10, &amp;#34;USD&amp;#34;}, new Object[] {20, &amp;#34;EUR&amp;#34;} }; } @Parameterized.Parameter(value = 0) // first data value (0) is default  public int amount; @Parameterized.Parameter(value = 1) // value is the index in parameter tuple  public String currency; @Test public void constructorShouldSetAmountAndCurrency() { Money money = new Money(amount, currency); assertEquals(amount, money.getAmount()); assertEquals(currency, money.getCurrency()); } } test fixture A test fixture is a fixed state of a set of objects used as a baseline for running tests. The purpose of a test fixture is to ensure that there is a well known and fixed environment in which tests are run so that results are repeatable. Examples of fixtures:
 Preparation of input data and setup/creation of fake or mock objects Loading a database with a specific, known set of data Copying a specific known set of files creating a test fixture will create a set of objects initialized to certain states.  JUnit supports test fixture by using:  @BeforeClass public static void setUpClass() {} @AfterClass public static void tearDownClass() {} @Before public void setUp() {} @After public void tearDown() {} Phases of a unit test      phase
   explanation
    arrange
   creation of all objects (except for the SUT) that are necessary for test execution
     creation of the object whose functionality will be tested, and setting it in some initial state
     act
   execution of SUT methods to be tested
     assert
   verification of the test results
      The first phase relates to the preparation of a test fixture.
TDD (Test-Driven Development) when to write test?
 Test Last (aka. Code First) development Test First development  How TDD do?
 write a test that fails (  ) make the code work (  ) eliminate redundancy (  )  Note: refractor can be done for classes to test or the test code.
TDD should be applied to every level: unit test, integration test, end-to-end test. test double (stub, test spy, mock) Types of test doubles   test double type also known as (aka.) description   dummy object dummy needs to exist, no real collaboration needed   test stub stub used for passing some values to the SUT (&amp;ldquo;indirect inputs&amp;rdquo;)   test spy spy used to verify if the SUT calls specific method of the collaborator (&amp;ldquo;indirect outputs&amp;rdquo;)   mock object mock   fake fake      Dummies and stubs are used to prepare the environment for testing (test-fixture setting). They are not used for verification. Test spies and mocks are to verify the correctness of the communication between the SUT and DOCs. Bothe can also participate in test-fixture setting. Fake For the sake of completeness, let us describe another type of test double: a fake. Fake works almost as good as the real collaborator, but is somehow simpler and/or weaker (which makes it not suitable for production use). It is also usually &amp;ldquo;cheaper&amp;rdquo; in use (i.e. faster or simpler to set up), which makes it suited to tests (which should run as fast as possible). A typical example is an in-memory database that is used instead of a full-blown database server. It can be used for some tests, as it serves SQL requests pretty well; however, you would not want to use it in a production environment. In tests, fake plays a similar role to dummy and stub: it is a part of the environment (test fixture), not an object of verification. Fakes are used in integration tests rather than in unit tests, so we will not be discussing them any further.  package messenger; /** * Created by Richard on 24/05/15. */ public class Messenger { private TemplateEngine templateEngine; private MailServer mailServer; public Messenger(MailServer mailServer, TemplateEngine templateEngine) { this.mailServer = mailServer; this.templateEngine = templateEngine; } public void sendMessage(Client client, Template template) { String msgContent = templateEngine.prepareMessage(template, client); mailServer.send(client.getEmail(), msgContent); } } interface MailServer { void send(Object email, String msgContent); } interface Template { } interface TemplateEngine { String prepareMessage(Template template, Client client); }package messenger; import org.junit.Before; import org.junit.Test; import static org.mockito.Mockito.*; /** * Created by Richard on 24/05/15. */ public class MessengerTest { // SUT  Messenger messenger; // dummy  Client client; Template template; // stub  TemplateEngine templateEngine; // spy  MailServer mailServer; final String CLIENT_EMAIL = &amp;#34;some@email.com&amp;#34;; final String MSG_CONTENT = &amp;#34;Dear John! You are fired.&amp;#34;; @Before public void setUp() { // dummy  template = mock(Template.class); // stubs  client = mock(Client.class); when(client.getEmail()).thenReturn(CLIENT_EMAIL); templateEngine = mock(TemplateEngine.class); when(templateEngine.prepareMessage(template, client)).thenReturn(MSG_CONTENT); // spy  mailServer = mock(MailServer.class); // SUT  messenger = new Messenger(mailServer, templateEngine); } @Test public void test1() { messenger.sendMessage(client, template); // verify interaction  verify(mailServer).send(CLIENT_EMAIL, MSG_CONTENT); } }</content>
    </entry>
    
     <entry>
        <title>SCEA architect</title>
        <url>http://yangchao.me/post/scea-architect/</url>
        <categories>
          <category>Uncategorized</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html">  Understanding Architecture focus on structure to support the business and service-level requirements
You can define the structure of a system as the mechanisms that the system employs to solve the common problems of the system, such as persistence, distribution, communication, transaction management, and security
 difficult decisions must be made about trade-offs in the system &amp;nbsp;  </content>
    </entry>
    
     <entry>
        <title>Get started with AngularJS</title>
        <url>http://yangchao.me/post/get-started-with-angularjs/</url>
        <categories>
          <category>Javascript</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html">  AngularJS concepts Core concepts:
 2-way data binding directive expression &amp;amp; filter view / template controller  2-way data binding directives  manipulate DOM: DOM manipulation should only happen in directive implementations manipulate data Elements: &amp;lt;ng-xx&amp;gt; &amp;lt;/ng-xx&amp;gt;  Attributes: &amp;lt;span ng-xx=&amp;ldquo;exp&amp;rdquo;&amp;gt;&amp;lt;/span&amp;gt;
Comments: &amp;lt;!&amp;ndash; directive: ng-xx exp &amp;ndash;&amp;gt;
Classes: &amp;lt;span class=&amp;rdquo;ng-xx: exp&amp;ldquo;&amp;gt;&amp;lt;/span&amp;gt;
Scope Scope is a glue between controller, template and model. It keeps models and views separate, but in sync.
Controller Controller is for UI logic
Injector The injector uses recipes to create two types of objects, services and specialized objects.
 Services are objects whose API is defined by the developer writing the service. Specialized objects conform to a specific Angular framework API. These objects extend the framework as plugins and therefore must implement interfaces specified by Angular. These interfaces are Controller, Directive, Filter and Animation.  Recipes There are five recipe types that define how to create objects: Value, Constant, Factory, Service and Provider.
Value, Constant, Factory and Service are the synaptic sugar of Provider.
 Value recipe  myApp.value(&amp;#39;clientId&amp;#39;, &amp;#39;a12345654321x&amp;#39;); &amp;nbsp;
 Constant recipe  myApp.constant(&amp;#39;planetName&amp;#39;, &amp;#39;Greasy Giant&amp;#39;);  Factory recipe  myApp.factory(&amp;#39;clientId&amp;#39;, function clientIdFactory() { return &amp;#39;a12345654321x&amp;#39;; });  Service recipe  function UnicornLauncher(apiToken) { this.launchedCount = 0; this.launch = function() { // Make a request to the remote API and include the apiToken  ... this.launchedCount&#43;&#43;; } } //myApp.factory(&amp;#39;unicornLauncher&amp;#39;, [&amp;#34;apiToken&amp;#34;, function(apiToken) { // return new UnicornLauncher(apiToken); //}]);  myApp.service(&amp;#39;unicornLauncher&amp;#39;, [&amp;#34;apiToken&amp;#34;, UnicornLauncher]);  provider recipe  myApp.provider(&amp;#39;unicornLauncher&amp;#39;, function UnicornLauncherProvider() { var useTinfoilShielding = false; this.useTinfoilShielding = function(value) { useTinfoilShielding = !!value; }; this.$get = [&amp;#34;apiToken&amp;#34;, function unicornLauncherFactory(apiToken) { // let&amp;#39;s assume that the UnicornLauncher constructor was also changed to  // accept and use the useTinfoilShielding argument  return new UnicornLauncher(apiToken, useTinfoilShielding); }]; }); myApp.config([&amp;#34;unicornLauncherProvider&amp;#34;, function(unicornLauncherProvider) { unicornLauncherProvider.useTinfoilShielding(true); }]);   Features / Recipe type Factory Service Value Constant Provider     can have dependencies yes yes no no yes   uses type friendly injection no yes yes* yes* no   object available in config phase no no no yes yes**   can create functions yes yes yes yes yes   can create primitives yes no yes yes yes    Specialized object The instructions for the injector to create these special objects (with the exception of the Controller objects) use the Factory recipe behind the scenes.
Since the directives are registered via the Factory recipe, we can use the same syntax as with factories.
myApp.directive(&amp;#39;myPlanet&amp;#39;, [&amp;#39;planetName&amp;#39;, function myPlanetDirectiveFactory(planetName) { // directive definition object  return {restrict: &amp;#39;E&amp;#39;,scope: {},link: function($scope, $element) { $element.text(&amp;#39;Planet: &amp;#39; &#43; planetName); } } }]); Using Factory recipes, you can also define Angular&amp;rsquo;s filters and animations, but the controllers are a bit special.
myApp.controller(&amp;#39;DemoController&amp;#39;, [&amp;#39;clientId&amp;#39;, function DemoController(clientId) { this.clientId = clientId; }]); Unlike services, controllers are not singletons.
&amp;nbsp;
</content>
    </entry>
    
     <entry>
        <title>JavaScript scopes and context</title>
        <url>http://yangchao.me/post/javascript-scope-and-context/</url>
        <categories>
          <category>Javascript</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html">  scope vs. context Both two terms are related to function.
Every function invocation has both a scope and a context associated with it. Functions can be adopted for various contexts and scope can be encapsulated and preserved.
Fundamentally, scope is function-based while context is object-based.
 Scope pertains to the variable access of a function when it is invoked and is unique to each invocation. Context is always the value of the this keyword which is a reference to the object that “owns” the currently executing code.   scope A variable can be defined in either local or global scope, which establishes the variables’ accessibility from different scopes during runtime.
Javascript has no block scope.
All scopes in JavaScript are created with function Scope only, they aren&amp;rsquo;t created by for or while loops or expression statements like if or switch.
global scope This is the top level scope. Any variable declared outside of a function body will live throughout runtime and can be accessed and altered in any scope.
local scope New functions = new local scope - that&amp;rsquo;s the rule.
// Scope A - global var myFunction = function () { // Scope B - local  var myOtherFunction = function () { // Scope C - local  }; }; scope chain Each function defined has its own nested scope, and any function defined within another function has a local scope which is linked to the outer function.
function first(){ second(); function second(){ third(); function third(){ fourth(); function fourth(){ // do something  } } } } first(); &amp;quot;this&amp;quot; context Context is most often determined by how a function is invoked. When a function is called as a method of an object, this is set to the object the method is called on.
invoke no-bound function
 bind this to window (by default) by invoking unbound function  function Dog() { console.log(this); var that = this; var bar = function () { console.log(this); console.log(this == that); }; bar(); this.bar = bar; this.bar(); } var dog = new Dog();  bind this by new  function Cat() { this.drink = function() { console.log(this); } } Cat(); // this -&amp;gt; window  var cat = new Cat(); cat.drink(); // this -&amp;gt; cat  bind this by specifying function to object property  var obj = { foo: function(){ alert(this === obj); } }; obj.foo(); // true  Changing scope with .call(), .apply() and .bind()  function foo(name, age) { this.name = name; this.age = age; } var john = { dept: &amp;#39;dev&amp;#39; }; foo.apply(john, [&amp;#39;John&amp;#39;, 32]); //foo.call(obj, &amp;#39;Richard&amp;#39;, 32); console.log(john); // -&amp;gt; Object {dept: &amp;#34;dev&amp;#34;, name: &amp;#34;John&amp;#34;, age: 32}  var tom = { dept: &amp;#39;test&amp;#39; }; var bar = foo.bind(tom, &amp;#39;Tom&amp;#39;, 28); // just bind, not call console.log(tom); // Object {dept: &amp;#34;test&amp;#34;} // do something else // ... bar(); console.log(tom); // Object {dept: &amp;#34;test&amp;#34;, name: &amp;#34;Tom&amp;#34;, age: 28} Execution Context This terminology is defined by ECMA specification. Don&amp;rsquo;t confuse it with the &amp;ldquo;this&amp;rdquo; context.
JavaScript is a single threaded language, meaning only one task can be executed at a time. When the JavaScript interpreter initially executes code, it first enters into a global execution context by default. Each invocation of a function from this point on will result in the creation of a new execution context.
Each time a new execution context is created it is appended to the top of the execution stack.
An execution context can be divided into a creation and execution phase. In the creation phase, the interpreter will first create a variable object (also called an activation object) that is composed of all the variables, function declarations, and arguments defined inside the execution context. From there the scope chain is initialized next, and the value of this is determined last. Then in the execution phase, code is interpreted and executed.
closure Accessing variables outside of the immediate lexical scope creates a closure.
It says, a closure is formed when a nested function is defined inside of another function, allowing access to the outer functions variables.
A simple illustration:
function aa() { var bb = &amp;#39;hello &amp;#39;; var cc = function() { return bb &#43; &amp;#34;world&amp;#34;; } } cc as a function accesses its immediate outer scope. That creates a closure.
Returning the nested function allows you to maintain access to the local variables, arguments, and inner function declarations of its outer function. This encapsulation allows us to hide and preserve the execution context from outside scopes while exposing a public interface and thus is subject to further manipulation.
A more practical example:
var sayHello = function (name) { var text = &amp;#39;Hello, &amp;#39; &#43; name; return function () { console.log(text); }; }; sayHello(&amp;#34;Richard&amp;#34;)(); One of the most popular types of closures is what is widely known as the module pattern; it allows you to emulate public, private, and privileged members:
var Module = (function(){ var privateProperty = &amp;#39;foo&amp;#39;; function privateMethod(args){ // do something  } return { publicProperty: &amp;#39;&amp;#39;, publicMethod: function(args){ // do something  }, privilegedMethod: function(args){ return privateMethod(args); } }; })(); References:
 http://ryanmorr.com/understanding-scope-and-context-in-javascript/ http://toddmotto.com/everything-you-wanted-to-know-about-javascript-scope/  </content>
    </entry>
    
     <entry>
        <title>JavaScript prototype: __proto__ vs. prototype</title>
        <url>http://yangchao.me/post/javascript-prototype-proto-vs-prototype/</url>
        <categories>
          <category>Javascript</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html">  Javascript is a prototype-based language. It resolve property using prototype chains.
Prototype chains (aka prototype inheritance) The proto property proto is the internal property of an object, it points to the prototype object of the object and is used for property look-up. Every object has a proto perperty and its relevant prototype object. But it maybe null, which means the object has no prototype object.
function as constructor In JavaScript you create an instance of a function like this:
function Foo() { this.kind = ‘foo’ } var foo = new Foo(); foo.kind //=&amp;gt; ‘foo’ Behind this scenes it is like doing something like this:
function Foo() { var this = {}; // this is not valid, just for illustration  this.__proto__ = Foo.prototype; this.kind = ‘foo’ return this; } But keep in mind that the implicit ‘this’ is only assigned to a new object when using ‘new’. If you forget ‘new’ keyword then ‘this’ will be the global object.
the ‘function prototype’ Every function in JavaScript has a special property called ‘prototype’. To avoid confusion, we call it &amp;ldquo;function prototype&amp;rdquo;.
Basically, this object is provided at run-time by Javascript engine. This object has a property called &amp;ldquo;constructor&amp;rdquo; which points to the function itself.
It is used to** build __proto__** when you create an object with new keyword.
Javascript object model Now we illustrate the complete relations for prototype:
</content>
    </entry>
    
     <entry>
        <title>web vulnerability issues: XSS, CSRF, SQL Injection</title>
        <url>http://yangchao.me/post/web-vulnerability-issues-xss-csrf-sql-injection/</url>
        <categories>
          <category>Security</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html">  XSS (Cross Site Scripting) XSS enables attackers to inject client-side script into Web pages viewed by other users.
Simple solution: escape all users&amp;rsquo; input data, include HTML, Javascript
CSRF (Cross Site Request Forgery) CSRF is an attack which forces an end user to execute unwanted actions on a web application in which he/she is currently authenticated.
Simple solution:
 insert hidden field for csrf_token, and verify every form post. insert CSRF token in the response header, and need users to send back it with the post data. always verify the referer header   SQL Injection </content>
    </entry>
    
     <entry>
        <title>WebSphere SSO how-to</title>
        <url>http://yangchao.me/post/websphere-sso-how-to/</url>
        <categories>
          <category>SSO</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html">  SSO定义 单点登录的英文名称为Single Sign-On，简写为SSO。在用户有权限访问的多个系统间，只要用户在其中一个系统做过认证(Authentication)后，就不用再次做认证即可以访问其他系统。
IBM对SSO有一个形象的解释：“单点登录、全网漫游”。
实现原理 目前主流SSO的实现方案中实现机制不尽相同，大体分为Cookie机制和Session机制两大类。
基于Session的机制 WebLogic通过Session共享认证信息。Session是一种服务器端机制，当客户端访问服务器时，服务器为客户端创建一个唯一的SessionID，以使在整个交互过程中始终保持状态，而交互的信息则可由应用自行指定，因此用Session方式实现SSO，不能在多个浏览器之间实现单点登录，但却可以跨域。
基于Cookie的机制 WebSphere通过Cookie记录认证信息。Cookie是一种客户端机制，它存储的内容主要包括: 名字、值、过期时间、路径和域，路径与域合在一起就构成了Cookie的作用范围，因此用Cookie方式可实现SSO，但域名必须相同。目前大部分SSO产品采用的是Cookie机制，WAS、CAS也是如此。
注意，这种Cookie机制要求实现单点登录的应用，其域名必须是相同的。例如：a.bankcomm.com, b.bankcomm.com就可以经过配置后实现SSO。
WAS SSO机制介绍 WAS SSO机制原理 WAS使用Cookie实现单点登录的原理图如图4所示。
图 4 使用Cookie实现单点登录的原理图
 某个应用程序首先要发起第1次认证。第一次访问应用程序时会显示登录页面。 用户在登录页面中，输入用户名和密码。 然后应用服务器会对用户名和密码进行认证。认证本身并不是应用服务器的功能，因此，通常会引入某种认证机制。认证机制可以有很多种，例如自己写一个认证程序，或者使用一些标准的认证方法，例如LDAP或者数据库等等。在大多数情况下，会使用LDAP进行认证。这是因为LDAP在处理用户登录方面，有很多独特的优势。 认证通过之后，页面重定向，回到Web应用。Web应用此时就完成了成功的登录。 然后应用服务器会在客户端创建一个Cookie，Cookie里面保存了LTPA令牌。Cookie是在用户的客户端，而不是服务端创建一个Cookie。这个Cookie是一个加密的Cookie，其中保存了用户登录的信息。 如果用户此时希望进入其他Web应用程序，此时WAS不再要求用户输入用户名和密码，而是首先自动寻找Cookie，根据Cookie中保存的信息，进行登录。登录之后，WAS重定向回到用户的应用程序。 这样，就不再需要用户继续输入用户名和密码，从而实现了单点登录。  这种单点登录体系中，并没有通过http进行密码的传递（但是有用户名的传递），因此是十分安全的。
LDAP简介 LDAP是英文“Lightweight Directory Access Protocol”的简称，中文翻译为轻量级目录访问协议。它是一种因特网上的访问协议，主要用于从服务器上检索信息。
LDAP服务器用来保存信息，中文有时候也称为目录服务。数据库使用“表”来储存数据，可以把一个数据库想象为日常生活中的“表格”。而LDAP用“树”来存储数据，可以把它想象为日常生活中的“电话号码簿页”，或者干脆把LDAP想象为大家常用的文件系统，就是由文件夹和文件组成的那种树形结构。
由于LDAP的结构方式不同，因此LDAP有一个很特殊的特性，就是查询数据的速度特别快，但是写数据的速度较慢。LDAP的另一个特性就是比较适合于按照层次组织信息，例如企业的组织结构等。
由于LDAP的查询速度比数据库快，因此经常用于诸如地址簿、用户帐号存储、组织结构信息、域名解析系统等需要大量查询的领域。
首先，我们可以很清楚地看到，LDAP是按照树形目录进行组织的。
假设公司的域名是macromedia.com，则LDAP首先使用域名作为整个树的根，并且用dc=com，dc=macromedia这样的标记来进行标注。dc的意思指“Domain Component”。LDAP中以后会大量使用这些令人费解的缩写。
假设某天macromedia.com这个公司和apple.com这个公司合并，按照LDAP的树形结构，只不过多了一个分叉，而不会导致整棵树需要重新组织，这就是LDAP的好处之一。
dc节点的后面，就是ou节点。ou是Organizational Unit的缩写，可以把ou想象为文件夹，它是用来容纳其他节点的。ou可以对应部门、组或者任何要包含其他节点的东西。
ou下面的节点，可以是另一个ou，也可以是cn节点。cn是“Common Name”的缩写，它是树叶节点，可以把它对比为文件系统中的文件。cn节点通常用来存储用户的信息，例如某个用户的地址等。
这样，各个节点按照树形组织起来，就变成了图5的样子。
图 5 LDAP结构示意图
LTPA简介 LTPA(Lightweight Third Party Authentication)技术是IBM的标准。当某用户访问某WebSphere URL时,系统会提示他输入用户名和口令进行登录。这时用户可以输入他的唯一标识符,通过验证后,Web服务器将把该用户的Web 浏览器中显示的Web 站点内容发送回来。在后台,WebSphere入口网站服务器将会建立包含已鉴别使用者认证的单点登录Cookie,并且会一直发送该cookie，而浏览器通常的默认设置是允许接收cookie的,因此用户的浏览器将保存这个cookie。 LTPA cookie是临时的,只在浏览器内存中存留,用户如果关闭浏览器,cookie就会被永久删除。LTPA cookie的特点如下：
(1)LTPA cookie是一种典型的浏览器cookie,它保存的信息表示该用户已经进行了登录。所有的浏览器cookies都有名称等标准属性。LTPA cookie特有的名称是LtpaToken。当配置 SSO时,在配置实用工具中,通常将LTPA cookie称为SSO LTPA“令牌”。LTPA cookie有一个被编码值,隐藏起cookie中包含的重要信息并且通过Internet传输。
(2)LTPA cookie 具有典型的浏览器cookie的相关域的信息，LTPA的实现依赖于具有域信息的浏览器cookies，因此，通常SSO环境必须部署到单一DNS域中,即每台服务器都在同一DNS域中。
(3)在用户已经登录并且该用户的浏览器接收到 LTPA cookie以后,在HTTP通信中不再需要进行特定的配置,浏览器运行的标准方法就是浏览器将自动发送该cookie。浏览器不断地向任何正确的DNS域中的URL目标发送HTTP请求，通过这种途径不断地向外发送LPTA cookie。当SSO服务接收到HTTP请求并且发现请求中包含了LTPA cookie时,服务器将验证cookie，随即可知道该cookie属于哪一位已经登录的用户，服务器就可以允许这个用户对这台服务器进行适当的访问。浏览器的任务就是确定在什么时候应该随同HTTP通信一起发出LTPA cookie。当用户浏览到一个不在同一DNS域中的URL时, 因为该cookie不适用于这个新的DNS域,浏览器则不会发送 LTPA cookie,新的DNS目标的接收服务器就不知道用户是谁,这时会提示用户输入他的用户名和口令。
(4)LTPA cookie是安全的,因为服务器在创建它时，使用一组加密密钥进行了安全加密。加密密钥用于对cookie进行编码,编码后的cookie传送到用户浏览器,而浏览器只对有加密密钥的cookie进行解码和验证cookie的完整性,并随时检测cookie是否被篡改过。在SSO环境中的所有服务器必须共享同一个加密密钥。当SSO服务器接收到HTTP请求并发现其中包含LTPA cookie时,就使用它共享的加密密钥副本验证cookie,这时有效的cookie信息就使服务器能够识别出登录的用户。
SSO服务器使用的安全加密确保了没有任何伪造cookie的机会。没有加密密钥,其他非法 的cookie不会通过验证,伪造的cookie将被忽略。因此，SSO服务器不会被入侵。
在WebSphere Portal环境中,LTPA加密密钥通常在配置SSO时由WebSphere 创建。管理员可以将密钥导出到文件中,然后转移该文件到其他的SSO服务器（例如Domino）,在那里导入密钥。系统的管理维护人员应该非常小心地处理密钥文件,把所有的副本保护好。
LTPA生成机制 LTPA由以下部分组成：
 LTPA token 版本（4字节） 创建时间（8字节） 过期时间（8字节） 用户名（可变长度） LTPA 密钥（20字节） 接下来分别说明各部分的具体内容： LTPA token 版本，例如0×0001 创建时间和过期时间为以十六进制方式表示的 Unix time，例如 2009-04-09 13:52:42 (GMT &#43;8) = 1239256362 = 49DD8D2A。过期时间为 创建时间 &#43; SSO 配置文档的过期时间（LTPA_TokenExpiration域） 用户名为 Names 中用户文档的 FullName 域值 Domino LTPA 密钥通过 Base64编码后，保存在 SSO 配置文档的 LTPA_Secret 域中。   图 6 LTPA结构示意图
在这里当然不能将密钥直接发送给浏览器，所以将上述部分合并起来（如上图），计算 SHA-1 校验和。
图 7 LTPA 密钥Base64编码图
然后用 SHA-1 校验和替换掉 LTPA 密钥，最后再将内容通过 Base64 编码，形成最终的LTPA Token发送给浏览器（如上图）。这样如果 cookie 中的任何内容被修改，校验和就不对了，达到了防篡改的效果。
LTPA验证机制 WAS根据事先导入的密钥KEY文件，解密LTPA Token内容，验证LTPA是否有效，并判断该LTPA是否超时。
如果LTPA验证通过，将获取LTPA中的用户信息，并再次与LDAP服务器进行验证该用户的有效性。
自定义认证实现方式 实现原理 自定义认证可以通过WAS中使用“独立定制注册表”方式实现认证。
通过在WAS控制台中指定实现了 com.ibm.websphere.security 包中的 UserRegistry 接口的定制注册表（需要开发自定义实现类），但要求用户自定义实现类必须实现com.ibm.websphere.security.UserRegistry的接口。
基于这个原理，我们可以自己编写一个java类，在接口实现中连接LDAP进行认证（可根据需要访问LDAP业务密码等信息），然后WAS再按照原先方式生成LTPA。
配置方式 配置使用“独立定制注册表” 配置“独立定制注册表”使用的“定制注册表类名”等信息 与WAS自带LDAP方式比较 &amp;nbsp;
配置方式 各业务系统端环境配置 修改web.xml 设置应用端的web.xml，使得业务平台可以通过SSO访问资源，下例中红色部分就配置了允许访问的资源。
&amp;lt;security-constraint&amp;gt; &amp;lt;web-resource-collection&amp;gt; &amp;lt;web-resource-name&amp;gt;sso_GUIP&amp;lt;/web-resource-name&amp;gt; &amp;lt;url-pattern&amp;gt;/abf_comm/default4portal.jsp&amp;lt;/url-pattern&amp;gt; &amp;lt;url-pattern&amp;gt;/abf_comm/main.jsp&amp;lt;/url-pattern&amp;gt; &amp;lt;url-pattern&amp;gt;/abf_comm/default.jsp&amp;lt;/url-pattern&amp;gt; &amp;lt;url-pattern&amp;gt;/common/fromITC.jsp&amp;lt;/url-pattern&amp;gt; &amp;lt;url-pattern&amp;gt;/itc_agent/agentsync/export.jsp&amp;lt;/url-pattern&amp;gt; &amp;lt;/web-resource-collection&amp;gt; &amp;lt;auth-constraint&amp;gt; &amp;lt;role-name&amp;gt;AllAuthUser&amp;lt;/role-name&amp;gt; &amp;lt;/auth-constraint&amp;gt; &amp;lt;user-data-constraint&amp;gt; &amp;lt;transport-guarantee&amp;gt;NONE&amp;lt;/transport-guarantee&amp;gt; &amp;lt;/user-data-constraint&amp;gt; &amp;lt;/security-constraint&amp;gt; 业务平台端环境配置 修改web.xml 需要在web.xml安全认证配置部分中增加用户登录的URL，红色部分需要根据应用修改，修改为允许访问的资源
&amp;lt;security-constraint&amp;gt; &amp;lt;web-resource-collection&amp;gt; &amp;lt;web-resource-name&amp;gt;sso_EUIF&amp;lt;/web-resource-name&amp;gt; &amp;lt;url-pattern&amp;gt;/abf_comm/default4portal.jsp&amp;lt;/url-pattern&amp;gt; &amp;lt;/web-resource-collection&amp;gt; &amp;lt;auth-constraint&amp;gt; &amp;lt;role-name&amp;gt;AllAuthUser&amp;lt;/role-name&amp;gt; &amp;lt;/auth-constraint&amp;gt; &amp;lt;user-data-constraint&amp;gt; &amp;lt;transport-guarantee&amp;gt;NONE&amp;lt;/transport-guarantee&amp;gt; &amp;lt;/user-data-constraint&amp;gt; &amp;lt;/security-constraint&amp;gt; &amp;lt;login-config&amp;gt; &amp;lt;auth-method&amp;gt;FORM&amp;lt;/auth-method&amp;gt; &amp;lt;form-login-config&amp;gt; &amp;lt;form-login-page&amp;gt;/abf_comm/login4portal.jsp&amp;lt;/form-login-page&amp;gt; &amp;lt;form-error-page&amp;gt;/abf_comm/loginfailed4portal.jsp&amp;lt;/form-error-page&amp;gt; &amp;lt;/form-login-config&amp;gt; &amp;lt;/login-config&amp;gt; &amp;lt;security-role&amp;gt; &amp;lt;role-name&amp;gt;AllAuthUser&amp;lt;/role-name&amp;gt; &amp;lt;/security-role&amp;gt; 修改welcome页面配置，这页面是登陆成功后系统指向的页面。
&amp;lt;welcome-file-list&amp;gt; &amp;lt;welcome-file&amp;gt;/abf_comm/default4portal.jsp&amp;lt;/welcome-file&amp;gt; &amp;lt;/welcome-file-list&amp;gt; 重启应用服务器
正确设置上述配置后，需要重新启动应用服务器。
WAS环境配置（将根据WAS7版本进行更新） 设置WAS的LTPA协议 进入WAS控制台，URL是http://IP:consoleport/admin,输入安装时设置的用户名密码。
&amp;nbsp;
设置安全角色到用户/组映射 点击进入“安全管理、应用程序和基础结构”，设置安全性 设置LDAP连接 设置域名 需要导入密钥文件，密钥文件可以从其他的was的控制台导出。 保存配置 注意：任何修改都需要保存到主配置才能生效。
设置WAS的Session的cookie值 不同应用系统配置唯一Cookie值，防止多应用集成session丢失 重启应用服务器 进入应用服务器所在目录，重新启动服务器。
以WAS为例，需要输入如下命令：
#cd /epost/was61/IBM/WebSphere/AppServer/profiles/[profileName]/bin
停止server
./stopServer.sh server1 -username wpsadmin -password password
启动server
./startServer.sh server1
使用方式 要求及条件  所有系统的底层平台都是采用WebSphere 系统本身的认证交给WebSphere底层平台来做 所有系统采用同一个LDAP或数据一致的LDAP来做认证 所有服务器必须在同一个网络域中 用全域名方式访问 所有服务器必须保证时间一致  场景描述 1) 用户成功登录新一代UI；
2) 在用户的浏览器cookie值中保存WAS生成SSO加密信息(LTPA令牌)；
3) 用户通过新一代UI系统访问其它系统资源；
4) 由于浏览器cookie中保存SSO加密信息，且不过期，所以用户不需要登录，而由各个系统验证LTPA令牌达到访问业务系统资源的目的。
安全性分析 优势  WAS提供的SSO解决方案中只传递用户名，不传递密码，保证了密码安全。 LTPA经过加密处理，不会被暴露在外部；即使token被截取，如果没有密钥和口令，也无法获取到其中的内容。 最新版的WAS Ltpa使用先进的加密算法：Random salt； 强 AES 密码； 对数据签名； 对数据加密  存在的风险 WAS SSO机制安全性依赖于密钥（KEY）文件、密钥口令以及有权限读取LDAP信息的帐号和密码。如果这三项全部被人获得，其即可仿造一个在WAS信任域中的系统，并仿造用户信息。
需要做好密钥文件及口令的保管工作，并做好LDAP访问权限的管理，可预防此类风险的发生。
另外，此风险在实际操作过程中难度较大，不容易出现。
附录一：常见SSO方案介绍 使用统一单点登录机制 前提是所有系统所使用的底层平台必须是同一家公司的，而且系统本身的认证(Authentication)会交给底层平台来做。
WAS的SSO方案就属于这样类型，WAS和Domino等都是IBM的产品，都基于统一的SSO机制，所以它们可以直接支持统一单点登录机制。
图 1 使用统一单点登录机制方案图
使用第三方系统来做单点登录 例如IBM Tivoli Access Manager或者Netegrity iteminder。
图 2 使用第三方系统来做单点登录方案图
利用用户名/密码映射(maping)的方式 如果有系统提供映射方式的单点登录功能，例如WebSphere Portal Server。
图 3 利用用户名/密码映射(mappiing)的方式方案图
其他方式 各个系统约定SSO规则，如：各系统判断cookie里面是否存在用户信息以及加密串，从而实现SSO登录。
附录二：单点登录产品介绍 商业SSO软件 1) 专门的SSO商业软件
主要有：Netgrity的Siteminder，已经被CA收购。Novell 公司的iChain。RSA公司的ClearTrust等。
2) 门户产品供应商自己的SSO产品，
如： IBM 的Tivoli Access Manager，WAS自带的SSO解决方案，BEA的WLES，Sun 公司的identity Server，Oracle公司的OID等。
上述商业软件一般适用于客户对SSO的需求很高，并且企业内部采用WAS、Domino、SAP、Sieble等系统比较多的情况下。单点登录产品通常需要在应用软件中增加代理模块，而商业SSO产品主要针对大型软件制作了代码模块。
开源SSO软件 1) Opensso
 https://opensso.dev.java.net/
 OpenSSO基于Sun Java System Access Manager，是Sun公司支持的一个开源的SSO项目。
 OpenSSO体系结构设计合理，功能比较强大。然而缺点是客户端支持不够广泛，似乎只是对基于J2EE的应用支持的比较好。
2) josso
 http://www.josso.org/
 这是另一个Java写的单点登录产品，通常认为比OpenSSO更成熟一些。
 JOSSO支持的客户端包括Java，PHP和ASP。
3) CAS
 http://www.ja-sig.org/products/cas/
 这是耶鲁大学开发的单点登录产品。
 CAS的优点很多，例如设计理念先进、体系结构合理、配置简单、客户端支持广泛、技术成熟等等。以后我们还要仔细介绍。
</content>
    </entry>
    
     <entry>
        <title>Unified Identity &amp; Access Control system</title>
        <url>http://yangchao.me/post/unified-identity-access-control-system/</url>
        <categories>
          <category>Project Architecture</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html">  The target of this system is to build a unified user registry, enterprise organization hierarchy tree, a centralized point for internal user logon and authentication, a flexible Role-Based access control model and an integrated SSO strategy for all other in-house application.
This is the big picture:
user registry and organization tree We build a central repository for employee information except their passwords(these are stored in LDAP for convenient look-up and security). These user information includes all kinds of static attributes related to an employee, like the positions, status, department&amp;hellip;a long list.
We also sort out a whole organization tree, which represent the hierarchy relations between a department and another, like upper level or subordinate. These relations are especially useful for some application like workflow which exists very commonly in some office tasks.
So we regard the user information and organization is the pre-condition for enterprise integration and process optimization. Yes, it&amp;rsquo;s the foundation and infrastructure for enterprise applications.
We maintain these information in one central place to ensure its integrity. But we share these data and synchronized them with some applications. These applications own their local copy of these information and do querying locally for performance.
identity / autentication Because we store the user name and password in LDAP. So the identification mainly depends on this service.
Keeping user name and password in LDAP is because we think the security and look-up performance concern. A dedicated server for the authentication makes things simple. And this is also the traditional way to implement identification.
RBAC(Role-Based Access Control) Another important thing for a big enterprise is the access control. If we distribute the access control into the applications themselves, even hard-code these logic instead of configuring them in a declarative way, that will be difficult to mange and there are some risks for security issues. After all, we cannot expect all our applications to make a enough emphasis on the access control problems.
So we implement a centralized access control model. We configure all kinds of application-specific function control in one shared place &amp;ndash; the management console of our system, and in the development of these applications, the developers just need to apply these rules.
Basically, it&amp;rsquo;s according to the stable RBAC principal. We define:
1. a Role has many Functions. Functions represent the operations of user, basically you can think its a URL.
2. a User can have many Roles and a Role can have many users.
3. We also define Menu for some function which is regards the entry point for some module. And the menu has a hierarchy and can form a menu tree. This is useful to organization the functions of the application.
All these relations are stored in one place and can be share to specified application. Internal we support multiple applications, different applications configure their own profile and synchronized their own part of data.
SSO We use the cookie-based WebSphere SSO solution. Because websphere application server is the standard application server in my previous company and nearly every J2EE web application uses it.
The following is the basic implementation.

&amp;nbsp;
You can see from the above figure, we use LDAP for an user registry. And any application needing SSO must do some configuration in their websphere management console to get the ability of SSO.
Obviously, this solution has some limitations:
 all the application must be under the same domain and accessed by domain name. all the backend application server must be websphere app server. use the shared user registry is a precondition. time must be synchronized so that the timeout of the logon session can be determined  </content>
    </entry>
    
     <entry>
        <title>JNDI how-to</title>
        <url>http://yangchao.me/post/jndi-how-to/</url>
        <categories>
          <category>JNDI, LDAP</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html">  JNDI - Java Naming and Directory Interface
Object storing There are several ways an object satisfies the condition to be bound to a JDNI context.
 serializable objects: Serializable referenceable objects and references: Reference, ObjectFactory, Referenceable, RefAddr objects with attributes: DirContext remote objects: Remote &amp;nbsp;  Let&amp;rsquo;s look at the real life example: how we bind DataSource and UserTransaction to a JNDI context
MySQL package com.mysql.jdbc.jdbc2.optional; public class MysqlDataSource extends ConnectionPropertiesImpl implements DataSource, Referenceable, Serializable { //....  public Reference getReference() throws NamingException { String factoryName = &amp;#34;com.mysql.jdbc.jdbc2.optional.MysqlDataSourceFactory&amp;#34;; Reference ref = new Reference(this.getClass().getName(), factoryName, (String)null); ref.add(new StringRefAddr(&amp;#34;user&amp;#34;, this.getUser())); ref.add(new StringRefAddr(&amp;#34;password&amp;#34;, this.password)); ref.add(new StringRefAddr(&amp;#34;serverName&amp;#34;, this.getServerName())); ref.add(new StringRefAddr(&amp;#34;port&amp;#34;, &amp;#34;&amp;#34; &#43; this.getPort())); ref.add(new StringRefAddr(&amp;#34;databaseName&amp;#34;, this.getDatabaseName())); ref.add(new StringRefAddr(&amp;#34;url&amp;#34;, this.getUrl())); ref.add(new StringRefAddr(&amp;#34;explicitUrl&amp;#34;, String.valueOf(this.explicitUrl))); try { this.storeToRef(ref); return ref; } catch (SQLException var4) { throw new NamingException(var4.getMessage()); } } //.... } Yes, it implements Referenceable, and defines an ObjectFactory: com.mysql.jdbc.jdbc2.optional.MysqlDataSourceFactory
H2 package org.h2.jdbcx; public class JdbcDataSource extends TraceObject implements XADataSource, DataSource, ConnectionPoolDataSource, Serializable, Referenceable { //....  public Reference getReference() { this.debugCodeCall(&amp;#34;getReference&amp;#34;); String var1 = JdbcDataSourceFactory.class.getName(); Reference var2 = new Reference(this.getClass().getName(), var1, (String)null); var2.add(new StringRefAddr(&amp;#34;url&amp;#34;, this.url)); var2.add(new StringRefAddr(&amp;#34;user&amp;#34;, this.userName)); var2.add(new StringRefAddr(&amp;#34;password&amp;#34;, this.convertToString(this.passwordChars))); var2.add(new StringRefAddr(&amp;#34;loginTimeout&amp;#34;, String.valueOf(this.loginTimeout))); var2.add(new StringRefAddr(&amp;#34;description&amp;#34;, this.description)); return var2; } //....  } It also implements Referenceable, and defines an ObjectFactory: org.h2.jdbcx.JdbcDataSourceFactory
JBoss JTA package com.arjuna.ats.internal.jta.transaction.arjunacore; public class UserTransactionImple extends BaseTransaction implements UserTransaction, ObjectFactory { //.... } You can see, UserTrancation implmentation class UserTransactionImple doesn&amp;rsquo;t implement Referenceable, but actions as ObjectFactory.
Now, let&amp;rsquo;s look at the bind code:
package com.arjuna.ats.jta.utils; public class JNDIManager { //....  public static void bindJTAUserTransactionImplementation(InitialContext initialContext) throws NamingException { String utImplementation = getUserTransactionImplementationClassname(); Reference ref = new Reference(utImplementation, utImplementation, (String)null); initialContext.rebind(getUserTransactionJNDIName(), ref); } //.... } Yes, JBoss JTA binds UserTransaction using Reference with its ObjectFactory. As said above, UserTransactionImple is both the bound target and the ObjectFactory.
Object binding So once the object can be bound, the binding operation is simple.
context.bind(&amp;#34;cn=favorite&amp;#34;, fruit); Object lookup / list / search context.lookup(..) &amp;nbsp;
&amp;nbsp;
</content>
    </entry>
    
     <entry>
        <title>ClassLoader</title>
        <url>http://yangchao.me/post/classloader/</url>
        <categories>
          <category>JVM</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html">  class loader Delegation Principal  Class loaders request their parent to load the class first before attempting to load it themselves.  Visibility Principal  Classes loaded by the parent class loaders have visibility into classes loaded by its children down the hierarchy, but the reverse is not true  Uniqueness Principal  When a class loader loads a class, the child class loaders in the hierarchy will never reload the class again. Hence uniqueness is maintained. &amp;nbsp;
 Although this, you are easy to violate this by manually loading the class. Thus, in a classloader hierarchy, there exists two Class with the same qualified name but loaded by different classloaders.
Then if you cast them, a ClassCastException will be thrown.
&amp;nbsp;
class loading ways  explicitly invoke new XXX() load its subclass, then the parent class will be also loaded dynamically load class: Class.forName(&amp;ldquo;com.ss.xx.XXX&amp;rdquo;) &amp;nbsp;  &amp;nbsp;
</content>
    </entry>
    
     <entry>
        <title>HTML 5</title>
        <url>http://yangchao.me/post/html-5/</url>
        <categories>
          <category>HTML5</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html">  new elements &amp;amp;lt;figure&amp;amp;gt; and &amp;lt;figcaption&amp;amp;gt; &amp;lt;figure id=&amp;#34;fig1&amp;#34;&amp;gt; &amp;lt;figcaption&amp;gt;Fig.1 Screen Reader Support for WAI-ARIA&amp;lt;/figcaption&amp;gt; &amp;lt;img src=&amp;#34;http://img2.cache.netease.com/cnews/2015/4/28/201504281107026599c.jpg&amp;#34; alt=&amp;#34;JAWS: Landmarks 1/1, Forms 4/5 … &amp;#34;&amp;gt; &amp;lt;/figure&amp;gt; &amp;amp;lt;mark&amp;amp;gt; This tag is very useful for the highlight of searching result.
&amp;lt;h1&amp;gt;Yes, You Can Use &amp;lt;mark&amp;gt;HTML5&amp;lt;/mark&amp;gt; Today!&amp;lt;/h1&amp;gt; &amp;amp;lt;progress&amp;amp;gt; and &amp;lt;meter&amp;amp;gt; &amp;lt;progress max=&amp;#34;100&amp;#34; value=&amp;#34;0&amp;#34;&amp;gt;&amp;lt;meter value=&amp;#34;50&amp;#34; min=&amp;#34;0&amp;#34; max=&amp;#34;400&amp;#34; low=&amp;#34;60&amp;#34; high=&amp;#34;300&amp;#34; title=&amp;#34;gigabytes&amp;#34;&amp;gt; &amp;lt;meter value=&amp;#34;150&amp;#34; min=&amp;#34;0&amp;#34; max=&amp;#34;400&amp;#34; low=&amp;#34;60&amp;#34; high=&amp;#34;300&amp;#34; title=&amp;#34;gigabytes&amp;#34;&amp;gt; &amp;lt;meter value=&amp;#34;350&amp;#34; min=&amp;#34;0&amp;#34; max=&amp;#34;400&amp;#34; low=&amp;#34;60&amp;#34; high=&amp;#34;300&amp;#34; title=&amp;#34;gigabytes&amp;#34;&amp;gt; the low and high are the thresholds. When in the range, the color is green, otherwise the color is yellow.
&amp;lt;time&amp;gt; &amp;lt;time datetime=&amp;#34;2015-10-12&amp;#34;&amp;gt;12 October of this year&amp;lt;/time&amp;gt;&amp;lt;!-- month --&amp;gt; &amp;lt;time&amp;gt;2015-11&amp;lt;/time&amp;gt; &amp;lt;!-- date --&amp;gt; &amp;lt;time&amp;gt;2015-11-12&amp;lt;/time&amp;gt; &amp;lt;!-- yearless date --&amp;gt; &amp;lt;time&amp;gt;11-12&amp;lt;/time&amp;gt; &amp;lt;!-- time --&amp;gt; &amp;lt;time&amp;gt;14:54:39&amp;lt;/time&amp;gt; &amp;lt;!-- floating date and time --&amp;gt; &amp;lt;time&amp;gt;2015-11-12T14:54:39&amp;lt;/time&amp;gt; &amp;lt;!-- time-zone offset --&amp;gt; &amp;lt;time&amp;gt;-0800&amp;lt;/time&amp;gt; &amp;lt;!-- global date and time --&amp;gt; &amp;lt;time&amp;gt;2015-11-12T06:54:39.929-0800&amp;lt;/time&amp;gt; &amp;lt;!-- week --&amp;gt; &amp;lt;time&amp;gt;2015-W46&amp;lt;/time&amp;gt; &amp;lt;!-- duration --&amp;gt; &amp;lt;time&amp;gt;4h 18m 3s&amp;lt;/time&amp;gt; &amp;lt;dl&amp;gt; &amp;lt;dt&amp;gt; &amp;lt;dd&amp;gt; This is called “description lists” or “association lists.”
&amp;lt;dl&amp;gt; &amp;lt;dt&amp;gt;Selector:&amp;lt;/dt&amp;gt; &amp;lt;dd&amp;gt;The element(s) targeted.&amp;lt;/dd&amp;gt; &amp;lt;dt&amp;gt;Property:&amp;lt;/dd&amp;gt; &amp;lt;dd&amp;gt;The feature used to add styling to the targeted element, defined before a colon.&amp;lt;/dd&amp;gt; &amp;lt;dt&amp;gt;Value:&amp;lt;/dd&amp;gt; &amp;lt;dd&amp;gt;The value given to the specified property, declared after the colon.&amp;lt;/dd&amp;gt; &amp;lt;/dl&amp;gt; &amp;lt;details&amp;gt; This tag is very useful to implement initially hidden &amp;ldquo;see more&amp;rdquo; .
&amp;lt;details&amp;gt; &amp;lt;summary&amp;gt;Some Magazines of Note&amp;lt;/summary&amp;gt; &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;&amp;lt;cite&amp;gt;Bird Watcher&amp;#39;s Digest&amp;lt;/cite&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;cite&amp;gt;Rower&amp;#39;s Weekly&amp;lt;/cite&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;cite&amp;gt;Fishing Monthly&amp;lt;/cite&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;/details&amp;gt; &amp;lt;ol reversed start=&amp;ldquo;3&amp;rdquo;&amp;gt; &amp;lt;ol reversed&amp;gt; &amp;lt;li&amp;gt;&amp;lt;cite&amp;gt;Bird Watcher&amp;#39;s Digest&amp;lt;/cite&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;cite&amp;gt;Rower&amp;#39;s Weekly&amp;lt;/cite&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;cite&amp;gt;Fishing Monthly&amp;lt;/cite&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;/ol&amp;gt; &amp;lt;ol start=&amp;#34;4&amp;#34;&amp;gt; &amp;lt;li&amp;gt;&amp;lt;cite&amp;gt;Bird Watcher&amp;#39;s Digest&amp;lt;/cite&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;cite&amp;gt;Rower&amp;#39;s Weekly&amp;lt;/cite&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;cite&amp;gt;Fishing Monthly&amp;lt;/cite&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;/ol&amp;gt; &amp;lt;ol start=&amp;#34;4&amp;#34; reversed&amp;gt; &amp;lt;li&amp;gt;&amp;lt;cite&amp;gt;Bird Watcher&amp;#39;s Digest&amp;lt;/cite&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;cite&amp;gt;Rower&amp;#39;s Weekly&amp;lt;/cite&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;cite&amp;gt;Fishing Monthly&amp;lt;/cite&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;/ol&amp;gt; Scoped Styles The scoped style is only valid for the specified element and its children.
&amp;lt;h1&amp;gt;Page Title&amp;lt;/h1&amp;gt; &amp;lt;article&amp;gt; &amp;lt;style scoped&amp;gt; h1 {color: blue; } &amp;lt;/style&amp;gt; &amp;lt;h1&amp;gt;Article Title&amp;lt;/h1&amp;gt; &amp;lt;p&amp;gt;Article content.&amp;lt;/p&amp;gt; &amp;lt;/article&amp;gt; the deley and async attribute of Scripts Using defer specifies that the browser should wait until the page’s markup is parsed before loading the script.
The new async attribute allows you to specify that a script should load asynchronously.
&amp;lt;script type=&amp;#34;text/javascript&amp;#34; src=&amp;#34;xxx.js&amp;#34; async&amp;gt;&amp;lt;/script&amp;gt; responsive image &amp;lt;picture src=&amp;#34;&amp;#34; srcset=&amp;#34;&amp;#34; sizes=&amp;#34;&amp;#34; &amp;gt; &amp;lt;img src=&amp;#34;&amp;#34; srcset=&amp;#34;&amp;#34; size=&amp;#34;&amp;#34; &amp;gt; others  &amp;lt;dialog&amp;gt; &amp;lt;a href=&amp;ldquo;1.pdf&amp;rdquo; dowload&amp;gt;download this document&amp;lt;/a&amp;gt; &amp;lt;iframe sandbox seemless&amp;gt;&amp;lt;/iframe&amp;gt; &amp;lt;menu&amp;gt; &amp;lt;menulist&amp;gt; &amp;lt;address&amp;gt;  HTML5 form &amp;lt;input required&amp;gt; &amp;lt;input placeholder=&amp;ldquo;&amp;rdquo;&amp;gt; &amp;lt;input pattern=&amp;ldquo;&amp;rdquo;&amp;gt; &amp;lt;input disabled&amp;gt; &amp;lt;input readonly&amp;gt; &amp;lt;datalist&amp;gt; &amp;lt;input type=&amp;#34;color&amp;#34; list=&amp;#34;colors&amp;#34; id=&amp;#34;favcolor&amp;#34; name=&amp;#34;favcolor&amp;#34;/&amp;gt; &amp;lt;datalist id=&amp;#34;colors&amp;#34;&amp;gt; &amp;lt;option value=&amp;#34;#0000FF&amp;#34; label=&amp;#34;blue&amp;#34;/&amp;gt; &amp;lt;option value=&amp;#34;#008000&amp;#34; label=&amp;#34;green&amp;#34;/&amp;gt; &amp;lt;option value=&amp;#34;#ff0000&amp;#34; label=&amp;#34;red&amp;#34;/&amp;gt; &amp;lt;option value=&amp;#34;#663399&amp;#34; label=&amp;#34;RebeccaPurple&amp;#34;/&amp;gt; &amp;lt;/datalist&amp;gt; &amp;nbsp;
autofocus Attribute new input type  search email url tel date time number range color  &amp;lt;form novalidate&amp;amp;gt; </content>
    </entry>
    
     <entry>
        <title>Git basics</title>
        <url>http://yangchao.me/post/git-basics/</url>
        <categories>
          <category>Version Control</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html">   http://think-like-a-git.net/ http://marklodato.github.io/visual-git-guide/index-en.html https://www.atlassian.com/git/tutorials/  local repository checkout checkout &amp;lt;branch&amp;gt;  switch branch
 git checkout dev checkout &amp;lt;commit&amp;gt; [files]  &amp;lt;commit&amp;gt; is HEAD by default. The current branch doesn&amp;rsquo;t change, without moving the HEAD pointer location.
copy the &amp;lt;commit&amp;gt; tree to index tree and working tree.
 git checkout HEAD git checkout HEAD^ git checkout HEAD~3 1.txt git checkout a47c3 reset reset &amp;lt;commit&amp;gt; [files]  move the HEAD, and copying &amp;lt;commit&amp;gt; tree to index or working tree.
three mode:
&amp;ndash;soft: no copy. move HEAD
&amp;ndash;mixed: copy to index only. move HEAD = reverse git add
&amp;ndash;hard: copy to index and working tree. move HEAD &amp;nbsp;
 git reset HEAD^3 git reset HEAD 1.txt = reset -- 1.txt git reset HEAD^ 1.txt diff git diff working &amp;lt;=&amp;gt; index
git diff &amp;ndash;cache index &amp;lt;=&amp;gt; HEAD
git diff HEAD working &amp;lt;=&amp;gt; HEAD
git diff HEAD^^ working &amp;lt;=&amp;gt; HEAD^^
git diff da985 b325c da985 &amp;lt;=&amp;gt; b325c
git diff &amp;lt;branch&amp;gt; working &amp;lt;=&amp;gt; &amp;lt;branch&amp;gt; HEAD
merge fast-forward merge 3-way merge cherry-pick and rebase remote repository remote remote remote -v remote add &amp;lt;remote_repo_name&amp;gt; &amp;lt;url&amp;gt; git remote add origin git@github.com:richdyang/1.git push push -u &amp;lt;remote_repo_name&amp;gt; &amp;lt;branch&amp;gt; push pull git pull &amp;nbsp;
&amp;nbsp;
</content>
    </entry>
    
     <entry>
        <title>Spring framework - context services</title>
        <url>http://yangchao.me/post/spring-framework-context-services/</url>
        <categories>
          <category>Spring</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html">  Bean Lifecycle Mangement &amp;nbsp;
package context.lifecycle; import org.springframework.beans.BeansException; import org.springframework.beans.factory.BeanClassLoaderAware; import org.springframework.beans.factory.BeanNameAware; import org.springframework.beans.factory.DisposableBean; import org.springframework.beans.factory.InitializingBean; import org.springframework.context.ApplicationContext; import org.springframework.context.ApplicationContextAware; import javax.annotation.PostConstruct; import javax.annotation.PreDestroy; public class LifecycleExposureBean implements BeanNameAware, BeanClassLoaderAware, ApplicationContextAware, InitializingBean, DisposableBean { private String injectedProperty; public void setInjectedProperty(String injectedProperty) { System.out.println(&amp;#34;Injection: injectedProperty = [&amp;#34; &#43; injectedProperty &#43; &amp;#34;]&amp;#34;); this.injectedProperty = injectedProperty; } //----------------context aware-------------------------  public void setBeanName(String beanName) { System.out.println(&amp;#34;BeanNameAware: beanName = [&amp;#34; &#43; beanName &#43; &amp;#34;]&amp;#34;); } public void setBeanClassLoader(ClassLoader classLoader) { System.out.println(&amp;#34;BeanClassLoaderAware: classLoader = [&amp;#34; &#43; classLoader &#43; &amp;#34;]&amp;#34;); } public void setApplicationContext(ApplicationContext applicationContext) throws BeansException { System.out.println(&amp;#34;ApplicationAware: applicationContext = [&amp;#34; &#43; applicationContext &#43; &amp;#34;]&amp;#34;); } //----------------initialization hook-------------------------  @PostConstruct public void postContructCallBack() { System.out.println(&amp;#34;@PostContruc: Post contruct invocation&amp;#34;); } public void afterPropertiesSet() throws Exception { System.out.println(&amp;#34;IntializingBean: afterPropertiesSet() called&amp;#34;); } public void initMethod() { System.out.println(&amp;#34;init-method: called&amp;#34;); } //----------------destroy hook-------------------------  @PreDestroy public void preDestroy() { System.out.println(&amp;#34;@PreDestory: called&amp;#34;); } public void destroy() throws Exception { System.out.println(&amp;#34;DisposableBean: destroy() called&amp;#34;); } public void destroyMethod() { System.out.println(&amp;#34;destroy-method: called&amp;#34;); } public static void main(String[] args) { GenericXmlApplicationContext context = new GenericXmlApplicationContext(&amp;#34;classpath:spring-lifecycle.xml&amp;#34;); context.destroy(); } }&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;beans xmlns=&amp;#34;http://www.springframework.org/schema/beans&amp;#34;xmlns:p=&amp;#34;http://www.springframework.org/schema/p&amp;#34;xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34;xsi:schemaLocation=&amp;#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&amp;#34;&amp;gt; &amp;lt;bean class=&amp;#34;context.lifecycle.LifecycleExposureBean&amp;#34; init-method=&amp;#34;initMethod&amp;#34; destroy-method=&amp;#34;destroyMethod&amp;#34;&amp;gt; &amp;lt;property name=&amp;#34;injectedProperty&amp;#34; value=&amp;#34;This is the value of injected property&amp;#34; /&amp;gt; &amp;lt;/bean&amp;gt; &amp;lt;/beans&amp;gt;  Injection: injectedProperty = [This is the value of injected property]
BeanNameAware: beanName = [context.lifecycle.LifecycleExposureBean#0]
BeanClassLoaderAware: classLoader = [sun.misc.Launcher$AppClassLoader@330bedb4]
ApplicationAware: applicationContext = [org.springframework.context.support.GenericXmlApplicationContext@18769467: startup date [Sat Apr 25 19:38:10 CST 2015]; root of context hierarchy]
IntializingBean: afterPropertiesSet() called
init-method: called
DisposableBean: destroy() called
destroy-method: called
 FactoryBean When a bean depends on some beans which cannot be simply intialized by using new
 implement FactoryBean&amp;amp;lt;T&amp;amp;gt; specify &amp;lt;span class=&amp;quot;FontName1&amp;quot;&amp;gt;factory-bean&amp;lt;/span&amp;gt; and &amp;lt;span class=&amp;quot;FontName1&amp;quot;&amp;gt;factory-method&amp;lt;/span&amp;gt;  PropertyEditor In String, PropertyEditior is mainly used as a kind of converter from String to POJO JavaBean.
You implement your custom PropertyEditor for the specified JavaBean class, and then configure it using org.springframework.beans.factory.config.CustomEditorConfigurer
public class CustomBean { private String firstName; private String lastName; public CustomBean(String firstName, String lastName) { this.firstName = firstName; this.lastName = lastName; } public String toString() { return &amp;#34;First name: &amp;#34; &#43; firstName &#43; &amp;#34;, last name: &amp;#34; &#43; lastName; } } public class CustomBeanEditor extends PropertyEditorSupport { public void setAsText(String text) { String[] segs = text.split(&amp;#34; &amp;#34;); CustomBean customBean = new CustomBean(segs[0], segs[1]); setValue(customBean); } }&amp;lt;bean id=&amp;#34;customEditorConfigurer&amp;#34; class=&amp;#34;org.springframework.beans.factory.config.CustomEditorConfigurer&amp;#34;&amp;gt; &amp;lt;property name=&amp;#34;customEditors&amp;#34;&amp;gt; &amp;lt;map&amp;gt; &amp;lt;entry key=&amp;#34;context.propertyeditor.CustomBean&amp;#34; value=&amp;#34;context.propertyeditor.CustomBeanEditor&amp;#34; /&amp;gt; &amp;lt;/map&amp;gt; &amp;lt;/property&amp;gt; &amp;lt;/bean&amp;gt; ApplicationContext capabilities Basically, AppliationContext has more extra capabilities than BeanFactory.
You can regard ApplicationContext as a MessageSource, an ApplicationEventPublisher, a ResourceLoader.
MessageSource &amp;lt;bean id=&amp;#34;messageSource&amp;#34; class=&amp;#34;org.springframework.context.support.ResourceBundleMessageSource&amp;#34;&amp;gt; &amp;lt;property name=&amp;#34;basenames&amp;#34;&amp;gt; &amp;lt;list&amp;gt; &amp;lt;value&amp;gt;message&amp;lt;/value&amp;gt; &amp;lt;/list&amp;gt; &amp;lt;/property&amp;gt; &amp;lt;/bean&amp;gt;GenericXmlApplicationContext context = new GenericXmlApplicationContext(&amp;#34;classpath:spring-messagesource.xml&amp;#34;); String name = &amp;#34;Richard&amp;#34;; String greeting = context.getMessage(&amp;#34;greeting&amp;#34;, new String[]{name}, Locale.US); String greetingCN = context.getMessage(&amp;#34;greeting&amp;#34;, new String[]{name}, Locale.CHINA); System.out.println(&amp;#34;greeting = [&amp;#34; &#43; greeting &#43; &amp;#34;]&amp;#34;); System.out.println(&amp;#34;greetingCN = [&amp;#34; &#43; greetingCN &#43; &amp;#34;]&amp;#34;); Then I have two message file: message_en_US.properties and message_zh_CN
greeting=你好, {0}！greeting=How is it going, {0}? Output: &amp;gt; greeting = [How is it going, Richard?] &amp;gt; &amp;gt; greetingCN = [你好, Richard！]
Application Events ApplicationEvent &amp;ndash; derive from java.util.EventObject
ApplicationListener&amp;amp;lt;T&amp;amp;gt; interface
ApplicationEventPublisher.publishEvent()
ApplicationContext implements ApplicationEventPublisher interface
resource accessing org.springframework.core.io.Resource
ResourceLoader
ApplicationContext implements ResourceLoader
Environment and PropertySource Abstraction Environment &amp;ndash;&amp;gt; PropertySource
ConfigurableEnvironment env =&amp;amp;nbsp;ctx.getEnvironment(); MutablePropertySources propertySources =&amp;amp;nbsp;env.getPropertySources(); Map appMap =&amp;amp;nbsp;new HashMap(); appMap.put(&amp;#34;application.home&amp;#34;, &amp;#34;application_home&amp;#34;); propertySources.addLast(new MapPropertySource(&amp;#34;application_properties&amp;#34;, appMap)); For the PropertySource abstraction, Spring will access the properties in the following default order:
 System properties for the running JVM (-Dxxxx) Environment variables (like JAVA_HOME, Path) Application-defined properties Most of time, we use PropertyPlaceHolder  &amp;lt;beans xmlns=&amp;#34;http://www.springframework.org/schema/beans&amp;#34;xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34;xmlns:context=&amp;#34;http://www.springframework.org/schema/context&amp;#34;xsi:schemaLocation=&amp;#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&amp;#34;&amp;gt; &amp;lt;context:property-placeholder location=&amp;#34;classpath:application.properties&amp;#34;/&amp;gt; &amp;lt;bean id=&amp;#34;somebean&amp;#34; class=&amp;#34;com.apress.prospring4.ch4.AppProperty&amp;#34;&amp;gt; &amp;lt;property name=&amp;#34;applicationHome&amp;#34; value=&amp;#34;${application.home}&amp;#34;/&amp;gt; &amp;lt;property name=&amp;#34;userHome&amp;#34; value=&amp;#34;${user.home}&amp;#34;&amp;gt;&amp;lt;/property&amp;gt; &amp;lt;/bean&amp;gt; &amp;lt;/beans&amp;gt; You can see, once you get the properties, you can use them in configuration files using {....}
&amp;nbsp;
Profiles Basically, a profile instructs Spring to configure only theApplicationContext that was defined when the specified profile was active.
 How to associated with a profile?  &amp;lt;beans xmlns=&amp;#34;http://www.springframework.org/schema/beans&amp;#34;xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34;xsi:schemaLocation=&amp;#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&amp;#34; profile=&amp;#34;devProfile&amp;#34;&amp;gt; ... &amp;lt;/bean&amp;gt; Those beans in the file should be instantiated only when the specified profile is active. If its profile is not active, actually these beans will not be initialized.
 How to activate   JVM argument -Dspring.profiles.active=&amp;ldquo;devProfile&amp;rdquo; ctx.getEnvironment().setActiveProfiles(&amp;ldquo;devProfile&amp;rdquo;)  &amp;nbsp;
&amp;nbsp;
</content>
    </entry>
    
     <entry>
        <title>what&#39;s the difference between getName(), getSimpleName(), getCanonicalName() of Class?</title>
        <url>http://yangchao.me/post/whats-the-difference-between-getname-getsimplename-getcanonicalname-of-class/</url>
        <categories>
          <category>Q/A</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html"> //primitive System.out.println(int.class.getName()); System.out.println(int.class.getCanonicalName()); System.out.println(int.class.getSimpleName()); System.out.println(); //class System.out.println(String.class.getName()); System.out.println(String.class.getCanonicalName()); System.out.println(String.class.getSimpleName()); System.out.println(); //inner class System.out.println(HashMap.SimpleEntry.class.getName()); System.out.println(HashMap.SimpleEntry.class.getCanonicalName()); System.out.println(HashMap.SimpleEntry.class.getSimpleName()); System.out.println(); //anonymous inner class System.out.println(new Serializable(){}.getClass().getName()); System.out.println(new Serializable(){}.getClass().getCanonicalName()); System.out.println(new Serializable(){}.getClass().getSimpleNam()); &amp;nbsp;
Prints: &amp;gt; int &amp;gt; &amp;gt; int &amp;gt; &amp;gt; int &amp;gt; &amp;gt; &amp;gt; java.lang.String &amp;gt; &amp;gt; java.lang.String &amp;gt; &amp;gt; String &amp;gt; &amp;gt; &amp;gt; java.util.AbstractMap$SimpleEntry &amp;gt; &amp;gt; java.util.AbstractMap.SimpleEntry &amp;gt; &amp;gt; SimpleEntry &amp;gt; &amp;gt; &amp;gt; ClassnameTest$1 &amp;gt; &amp;gt; null There&amp;rsquo;s an empty line in the last block where getSimpleName returns an empty string.
The upshot looking at this is:
the name is the name that you&amp;rsquo;d use to dynamically load the class with, for example, a call to Class.forName with the default classloader. the canonical name is the name that would be used in an import statement and uniquely identifies the class. Might be useful during toString or logging operations. the simple name loosely identifies the class, again might be useful during toString or logging operations but is not guaranteed to be unique.
&amp;nbsp;
&amp;nbsp;
</content>
    </entry>
    
     <entry>
        <title>What&#39;s the difference between getPath(), getAbsolutePath(), and getCanonicalPath()?</title>
        <url>http://yangchao.me/post/whats-the-difference-between-getpath-getabsolutepath-and-getcanonicalpath/</url>
        <categories>
          <category>Q/A</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html"> Consider these filenames:
 C:\temp\file.txt - This is a path, an absolute path, and a canonical path. .\file.txt - This is a path. It&amp;rsquo;s neither an absolute path nor a canonical path. C:\temp\myapp\bin..\..\file.txt - This is a path and an absolute path. It&amp;rsquo;s not a canonical path. A canonical path is always an absolute path.  Converting from a path to a canonical path makes it absolute (usually tack on the current working directory so e.g. ./file.txt becomes c:/temp/file.txt). The canonical path of a file just &amp;ldquo;purifies&amp;rdquo; the path, removing and resolving stuff like ..\ and resolving symlinks (on unixes).
</content>
    </entry>
    
     <entry>
        <title>what does 0.0.0.0 mean?</title>
        <url>http://yangchao.me/post/what-does-0-0-0-0-mean/</url>
        <categories>
          <category>Q/A</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html"> 0.0.0.0, in server context, means &amp;ldquo;all IP addresses on the local machine&amp;rdquo; (in fact probably, &amp;ldquo;all IPv4 addresses on the local machine&amp;rdquo;). So, if your webserver machine has two ip addresses, 192.168.1.1 and 10.1.2.1, and you allow a webserver daemon like apache to listen on 0.0.0.0, it will be reachable at both of those IPs. But only to what can contact those IPs and the web port(s).
The only thing is that you cannot say &amp;ldquo;all addresses should have access&amp;rdquo; &amp;ndash; that&amp;rsquo;s done in your firewall(s) and/or the server software and/or other security layers like tcpwrappers.
&amp;nbsp;
Note that, in a different context (routing) 0.0.0.0 usually means the default route (the route to &amp;ldquo;the rest of&amp;rdquo; the internet, aside from routes in your local network etc.).
&amp;nbsp;
</content>
    </entry>
    
     <entry>
        <title>algorithm training from codility</title>
        <url>http://yangchao.me/post/algorithm-training-from-codility/</url>
        <categories>
          <category>Algorithm</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html">  TRAINING counting elements When every value of the element in a numeric array is in range. We can get a counter array of which the index of every element is the value and the value is the counter.
Prefix Sums Prefix sums array defines as:
So prefix sums array is very useful to compute the sum of any array slice (contiguous segments of array).
For example:
sum(a2&amp;hellip;a5) = p6 - p2
 minimum sum of slice sort the prefix sum, and find the minimum difference between neighbor elements.
 maximum sum of slice the difference between the max and min of the prefix sum.
  leader The leader of this sequence is the element whose value occurs more than n/2 times.The array can have zero or only one leader.
A property is:
After removing a pair of elements of different values, the leader remain the same.
Let&amp;rsquo;s validate it:
 if the two elements contain one leader, then the original leader occurs &amp;gt; n/2 - 1 = (n-2)/2 in the left (n-2) elements, so it&amp;rsquo;s still the leader of the rest. if the two elements contain no leader, then the original leader occurs &amp;gt; n/2 = (n-2)/2 &#43;1 &amp;gt; (n-2)/2 in the left elements, so it&amp;rsquo;s still the leader of the rest. or   So we loop the array, and every time we remove a pair of elements, if the two equals, we reserve; if not, we remove safely.
The left elements MUST be all the same. But they are just candidate. We need to validate in the original elements.
This algorithm is O(n).
public class Leader { public static int leader(int[] a) { int N = a.length; int size = 0; // stack size  int top = -1; // top value  for(int i = 0; i &amp;lt; N; &#43;&#43;i) { if(size == 0) { size &#43;= 1; top = a[i]; } else { if(top != a[i]) { size -= 1; } else { size &#43;= 1; } } } int cadidate = top; // validation  int count = 0; for(int i = 0; i &amp;lt; N; &#43;&#43;i) { if(a[i] == cadidate) { count&#43;&#43;; } } return (count &amp;gt; N/2) ? cadidate : -1; } public static void main(String[] args) { int[] a = {4, 6, 6, 6, 6, 8, 5}; System.out.println(leader(a)); } } prime and composite numbers This kind of algorithm is based on one divisor, we can find the symmetric divisor.
counting divisors for 1 to√n, divide and count it.
Primality test for 2 to √n, divide and check it.
Sieve of Eratosthenes Caterpillar method This idea is a reminiscent of movements of a caterpillar (毛虫).
 if we can, we move the right end (front) forward and increase the size of the caterpillar; otherwise, we move the left end (back) forward and decrease the size of the caterpillar.  Greedy algorithms Greedy programming is a method by which a solution is determined based on making the locally optimal choice at any given moment.
The greedy method of solving a task may or may not be the best approach
PROBLEM SET http://www.martinkysel.com/codility-solutions/
Time Complexity TapeEquilibrium Short Problem Definition:
Minimize the value |(A[0] &#43; … &#43; A[P-1]) – (A[P] &#43; … &#43; A[N-1])|.
Complexity
 expected worst-case time complexity is O(N); expected worst-case space complexity is O(N) Execution:  In the first run I compute the left part up to the point i and the overall sum last. Then I compute the minimal difference between 0..i and i&#43;1..n.
Solution:
package TapeEquilibrium; /* A non-empty zero-indexed array A consisting of N integers is given. Array A represents numbers on a tape. Any integer P, such that 0 &amp;lt; P &amp;lt; N, splits this tape into two non-empty parts: A[0], A[1], ..., A[P − 1] and A[P], A[P &#43; 1], ..., A[N − 1]. The difference between the two parts is the value of: |(A[0] &#43; A[1] &#43; ... &#43; A[P − 1]) − (A[P] &#43; A[P &#43; 1] &#43; ... &#43; A[N − 1])| In other words, it is the absolute difference between the sum of the first part and the sum of the second part. For example, consider array A such that: A[0] = 3 A[1] = 1 A[2] = 2 A[3] = 4 A[4] = 3 We can split this tape in four places: P = 1, difference = |3 − 10| = 7 P = 2, difference = |4 − 9| = 5 P = 3, difference = |6 − 7| = 1 P = 4, difference = |10 − 3| = 7 Write a function: class Solution { public int solution(int[] A); } that, given a non-empty zero-indexed array A of N integers, returns the minimal difference that can be achieved. For example, given: A[0] = 3 A[1] = 1 A[2] = 2 A[3] = 4 A[4] = 3 the function should return 1, as explained above. Assume that: N is an integer within the range [2..100,000]; each element of array A is an integer within the range [−1,000..1,000]. Complexity: expected worst-case time complexity is O(N); expected worst-case space complexity is O(N), beyond input storage (not counting the storage required for input arguments). Elements of input arrays can be modified. */ // you can also use imports, for example: // import java.util.*;  // you can use System.out.println for debugging purposes, e.g. // System.out.println(&amp;#34;this is a debug message&amp;#34;); import static org.junit.Assert.*; import org.junit.Test; import static java.lang.Math.*; import java.util.*; public class Solution { public int solution(int[] A) { // write your code in Java SE 8  int N = A.length; long sum = 0L; for(int i=0; i &amp;lt; N; &#43;&#43;i) { sum &#43;= A[i]; } long diff = Long.MAX_VALUE; long[] p = new long[N]; p[0] = 0L; for(int i=1; i &amp;lt; N; &#43;&#43;i) { p[i] = p[i-1] &#43; A[i-1]; //System.out.println(p[i]);  diff = min(diff, abs(2*p[i] - sum)); } return (int)diff; } //-------------------------------------------------  @Test public void test1() { int[] A = {3, 1, 2, 4, 3}; int result = solution(A); assertEquals(1, result); } } FrogJmp Short Problem Definition:
Count minimal number of jumps from position X to Y.
Complexity:
 expected worst-case time complexity is O(1); expected worst-case space complexity is O(1). Execution:  Do not use float division if possible!
Solution:
package FrogJmp; /* A small frog wants to get to the other side of the road. The frog is currently located at position X and wants to get to a position greater than or equal to Y. The small frog always jumps a fixed distance, D. Count the minimal number of jumps that the small frog must perform to reach its target. Write a function: class Solution { public int solution(int X, int Y, int D); } that, given three integers X, Y and D, returns the minimal number of jumps from position X to a position equal to or greater than Y. For example, given: X = 10 Y = 85 D = 30 the function should return 3, because the frog will be positioned as follows: after the first jump, at position 10 &#43; 30 = 40 after the second jump, at position 10 &#43; 30 &#43; 30 = 70 after the third jump, at position 10 &#43; 30 &#43; 30 &#43; 30 = 100 Assume that: X, Y and D are integers within the range [1..1,000,000,000]; X ≤ Y. Complexity: expected worst-case time complexity is O(1); expected worst-case space complexity is O(1). */ // you can also use imports, for example: // import java.util.*;  // you can use System.out.println for debugging purposes, e.g. // System.out.println(&amp;#34;this is a debug message&amp;#34;);  import org.junit.Test; import static org.junit.Assert.*; import java.io.BufferedReader; import java.io.InputStreamReader; import java.util.Random; public class Solution { public int solution(int X, int Y, int D) { // write your code in Java SE 8  int count = (Y-X) / D; int left = (Y-X) % D; return left == 0 ? count : count&#43;1; } //-------------------------------------------------  private Random rdm = new Random(); private BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); // [from, to)  private int random(int from, int to) { return rdm.nextInt(to - from) &#43; from; } // A[0]...A[n-1]  private int random(int[] A) { int index = random(0, A.length); return A[index]; } @Test public void test1() { int X = 0, Y = 20, D = 19; int expected = 2; int actual = solution(X, Y, D); assertEquals(expected, actual); } @Test public void test2() { int X = 0, Y = 20, D = 20; int expected = 1; int actual = solution(X, Y, D); assertEquals(expected, actual); } @Test public void test3() { int X = 0, Y = 20, D = 21; int expected = 1; int actual = solution(X, Y, D); assertEquals(expected, actual); } @Test public void test4() { int X = 10, Y = 85, D = 30; int expected = 3; int actual = solution(X, Y, D); assertEquals(expected, actual); } } PermMissingElem Short Problem Definition:
Find the missing element in a given permutation.
Complexity:
 expected worst-case time complexity is O(N); expected worst-case space complexity is O(1) Execution:  Sum all elements that should be in the list and sum all elements that actually are in the list. The sum is 0 based, so &#43;1 is required. The first solution using the &#43; operator can cause int overflow in not-python languages. Therefore the use of a binary XOR is adequate.
Solution:
package PermMissingElem; /* A zero-indexed array A consisting of N different integers is given. The array contains integers in the range [1..(N &#43; 1)], which means that exactly one element is missing. Your goal is to find that missing element. Write a function: class Solution { public int solution(int[] A); } that, given a zero-indexed array A, returns the value of the missing element. For example, given array A such that: A[0] = 2 A[1] = 3 A[2] = 1 A[3] = 5 the function should return 4, as it is the missing element. Assume that: N is an integer within the range [0..100,000]; the elements of A are all distinct; each element of array A is an integer within the range [1..(N &#43; 1)]. Complexity: expected worst-case time complexity is O(N); expected worst-case space complexity is O(1), beyond input storage (not counting the storage required for input arguments). Elements of input arrays can be modified */ // you can also use imports, for example: // import java.util.*;  // you can use System.out.println for debugging purposes, e.g. // System.out.println(&amp;#34;this is a debug message&amp;#34;);  import org.junit.Test; import static org.junit.Assert.*; import java.io.BufferedReader; import java.io.InputStreamReader; import java.util.Random; public class Solution { public int solution(int[] A) { // write your code in Java SE 8  long N = A.length; long sum = 0; for(int i = 0; i &amp;lt; N; &#43;&#43;i) { sum &#43;= A[i]; } long missing = (1&#43;(N&#43;1)) * (N&#43;1) /2 - sum; return (int) missing; } //-----------test------------------------------------------------  @Test public void test() { int N = 100001; int a = (1&#43;(N&#43;1)) * (N&#43;1) /2; System.out.println(a); } @Test public void test1() { int[] A = new int[100000]; for(int i = 0; i &amp;lt; 100000; &#43;&#43;i) { A[i] = i&#43;1; } A[0] = 100001; System.out.println(A[100000-1]); int expected = 1; int actual = solution(A); System.out.println(actual); assertEquals(expected, actual); } } Counting Elements PermCheck Short Problem Definition:
Check whether array N is a permutation.
Complexity:
 expected worst-case time complexity is O(N); expected worst-case space complexity is O(N) Execution:  Mark elements as seen in a boolean array. Elements seen twice or out of bounds of the size indicate that the list is no permutation. The check if the boolean array only contains true elements is not required. This solution only works with permutations starting from 1.
Solution:
package PermCheck; /* A non-empty zero-indexed array A consisting of N integers is given. A permutation is a sequence containing each element from 1 to N once, and only once. For example, array A such that: A[0] = 4 A[1] = 1 A[2] = 3 A[3] = 2 is a permutation, but array A such that: A[0] = 4 A[1] = 1 A[2] = 3 is not a permutation, because value 2 is missing. The goal is to check whether array A is a permutation. Write a function: class Solution { public int solution(int[] A); } that, given a zero-indexed array A, returns 1 if array A is a permutation and 0 if it is not. For example, given array A such that: A[0] = 4 A[1] = 1 A[2] = 3 A[3] = 2 the function should return 1. Given array A such that: A[0] = 4 A[1] = 1 A[2] = 3 the function should return 0. Assume that: N is an integer within the range [1..100,000]; each element of array A is an integer within the range [1..1,000,000,000]. Complexity: expected worst-case time complexity is O(N); expected worst-case space complexity is O(N), beyond input storage (not counting the storage required for input arguments). Elements of input arrays can be modified. */ // you can also use imports, for example: // import java.util.*;  // you can use System.out.println for debugging purposes, e.g. // System.out.println(&amp;#34;this is a debug message&amp;#34;);  import org.junit.Test; import static org.junit.Assert.*; import java.io.BufferedReader; import java.io.InputStreamReader; import java.util.Random; public class Solution { public int solution(int[] A) { // write your code in Java SE 8  final int N = A.length; int[] seen = new int[N &#43; 1]; for(int i = 0 ;i &amp;lt; N; &#43;&#43;i) { if(A[i] &amp;gt; N) return 0; // exceeding the range  seen[A[i]]&#43;&#43;; } for(int i = 1; i &amp;lt; N&#43;1; &#43;&#43;i) { if(seen[i] != 1) return 0; // seen many times  } return 1; } //-----------------------test------------------------------------  @Test public void test1() { int[] A = {4, 1, 3, 2}; int expected = 1; int actual = solution(A); assertEquals(expected, actual); } @Test public void test2() { int[] A = {4, 1, 3}; int expected = 0; int actual = solution(A); assertEquals(expected, actual); } } FrogRiverOne Short Problem Definition:
Find the earliest time when a frog can jump to the other side of a river.
Complexity:
 expected worst-case time complexity is O(N); expected worst-case space complexity is O(X) Execution:  Mark seen elements as such in a boolean array. I do not like the idea of returning the first second as 0. But specifications are specifications
Solution:
package FrogRiverOne; /* A small frog wants to get to the other side of a river. The frog is currently located at position 0, and wants to get to position X. Leaves fall from a tree onto the surface of the river. You are given a non-empty zero-indexed array A consisting of N integers representing the falling leaves. A[K] represents the position where one leaf falls at time K, measured in minutes. The goal is to find the earliest time when the frog can jump to the other side of the river. The frog can cross only when leaves appear at every position across the river from 1 to X. For example, you are given integer X = 5 and array A such that: A[0] = 1 A[1] = 3 A[2] = 1 A[3] = 4 A[4] = 2 A[5] = 3 A[6] = 5 A[7] = 4 In minute 6, a leaf falls into position 5\. This is the earliest time when leaves appear in every position across the river. Write a function: class Solution { public int solution(int X, int[] A); } that, given a non-empty zero-indexed array A consisting of N integers and integer X, returns the earliest time when the frog can jump to the other side of the river. If the frog is never able to jump to the other side of the river, the function should return −1. For example, given X = 5 and array A such that: A[0] = 1 A[1] = 3 A[2] = 1 A[3] = 4 A[4] = 2 A[5] = 3 A[6] = 5 A[7] = 4 the function should return 6, as explained above. Assume that: N and X are integers within the range [1..100,000]; each element of array A is an integer within the range [1..X]. Complexity: expected worst-case time complexity is O(N); expected worst-case space complexity is O(X), beyond input storage (not counting the storage required for input arguments). Elements of input arrays can be modified. */ // you can also use imports, for example: // import java.util.*;  // you can use System.out.println for debugging purposes, e.g. // System.out.println(&amp;#34;this is a debug message&amp;#34;);  import org.junit.Test; import java.util.Arrays; import static org.junit.Assert.*; public class Solution { public int solution(int X, int[] A) { // write your code in Java SE 8  final int N = A.length; boolean[] seen = new boolean[X&#43;1]; // [0] ignore  Arrays.fill(seen, false); int has_seen = 0; for(int i = 0; i &amp;lt; N; &#43;&#43;i) { if(seen[A[i]] == false) { seen[A[i]] = true; has_seen&#43;&#43;; } if(has_seen == X) return i; } return -1; } //-----------------------test------------------------------------  @Test public void test1() { int X = 5; int[] A = {1, 3, 1, 4, 2, 3, 5, 4}; int expected = 6; int actual = solution(X, A); assertEquals(expected, actual); } @Test public void test2() { int X = 5; int[] A = {1, 3, 1, 4, 1, 3, 5, 2}; int expected = 7; int actual = solution(X, A); assertEquals(expected, actual); } } MaxCounters Short Problem Definition:
Calculate the values of counters after applying all alternating operations: increase counter by 1; set value of all counters to current maximum.
Complexity:
 expected worst-case time complexity is O(N&#43;M); expected worst-case space complexity is O(N) Execution:  The idea is to perform the specified operation as stated. It is not required to iterate over the whole array if a new value is set for all the values. Just save the value and check it when an increase on that position is performed.
Solution:
package MaxCounters; /* You are given N counters, initially set to 0, and you have two possible operations on them: increase(X) − counter X is increased by 1, max counter − all counters are set to the maximum value of any counter. A non-empty zero-indexed array A of M integers is given. This array represents consecutive operations: if A[K] = X, such that 1 ≤ X ≤ N, then operation K is increase(X), if A[K] = N &#43; 1 then operation K is max counter. For example, given integer N = 5 and array A such that: A[0] = 3 A[1] = 4 A[2] = 4 A[3] = 6 A[4] = 1 A[5] = 4 A[6] = 4 the values of the counters after each consecutive operation will be: (0, 0, 1, 0, 0) (0, 0, 1, 1, 0) (0, 0, 1, 2, 0) (2, 2, 2, 2, 2) (3, 2, 2, 2, 2) (3, 2, 2, 3, 2) (3, 2, 2, 4, 2) The goal is to calculate the value of every counter after all operations. Write a function: class Solution { public int[] solution(int N, int[] A); } that, given an integer N and a non-empty zero-indexed array A consisting of M integers, returns a sequence of integers representing the values of the counters. The sequence should be returned as: a structure Results (in C), or a vector of integers (in C&#43;&#43;), or a record Results (in Pascal), or an array of integers (in any other programming language). For example, given: A[0] = 3 A[1] = 4 A[2] = 4 A[3] = 6 A[4] = 1 A[5] = 4 A[6] = 4 the function should return [3, 2, 2, 4, 2], as explained above. Assume that: N and M are integers within the range [1..100,000]; each element of array A is an integer within the range [1..N &#43; 1]. Complexity: expected worst-case time complexity is O(N&#43;M); expected worst-case space complexity is O(N), beyond input storage (not counting the storage required for input arguments). Elements of input arrays can be modified. */ // you can also use imports, for example: // import java.util.*;  // you can use System.out.println for debugging purposes, e.g. // System.out.println(&amp;#34;this is a debug message&amp;#34;);  import org.junit.Test; import static org.junit.Assert.*; public class Solution { public int[] solution(int N, int[] A) { // write your code in Java SE 8  final int M = A.length; int[] counters = new int[N]; int current_max = 0; int baseline = 0; // new starting point  for(int k = 0; k &amp;lt; M; &#43;&#43;k) { if(A[k] &amp;lt;= N) { counters[A[k]-1] = Math.max(counters[A[k]-1], baseline); counters[A[k]-1]&#43;&#43;; current_max = Math.max(counters[A[k]-1], current_max); } else { baseline = current_max; } } for(int i = 0; i &amp;lt; N; &#43;&#43;i) { counters[i] = Math.max(counters[i], baseline); } return counters; } //-----------------------test------------------------------------  @Test public void test1() { int N = 5; int[] A = {3, 4, 4, 6, 1, 4, 4}; int[] expected = {3, 2, 2, 4, 2}; int[] actual = solution(N, A); assertArrayEquals(expected, actual); } } MissingInteger Short Problem Definition:
Find the minimal positive integer not occurring in a given sequence.
Complexity:
 expected worst-case time complexity is O(N); expected worst-case space complexity is O(N) Execution:  You only need to consider the first (N) positive integers. In this specification 0 does not count as a valid candidate! Any value that is below 1 or above N can be ignored.
Solution:
package MissingInteger; /* Write a function: class Solution { public int solution(int[] A); } that, given a non-empty zero-indexed array A of N integers, returns the minimal positive integer that does not occur in A. For example, given: A[0] = 1 A[1] = 3 A[2] = 6 A[3] = 4 A[4] = 1 A[5] = 2 the function should return 5. Assume that: N is an integer within the range [1..100,000]; each element of array A is an integer within the range [−2,147,483,648..2,147,483,647]. Complexity: expected worst-case time complexity is O(N); expected worst-case space complexity is O(N), beyond input storage (not counting the storage required for input arguments). Elements of input arrays can be modified. */ // you can also use imports, for example: // import java.util.*;  // you can use System.out.println for debugging purposes, e.g. // System.out.println(&amp;#34;this is a debug message&amp;#34;);  import org.junit.Test; import static org.junit.Assert.*; public class Solution { public int solution(int[] A) { // write your code in Java SE 8  final int N = A.length; boolean[] seen = new boolean[N&#43;1]; // [0] ignored  for(int i= 0; i &amp;lt; N; &#43;&#43;i) { if(A[i] &amp;gt; 0 &amp;amp;&amp;amp; A[i] &amp;lt;= N) { seen[A[i]] = true; } } for(int i = 1; i &amp;lt; N&#43;1; &#43;&#43;i) { if(seen[i] == false) return i; } return N&#43;1; } //-----------------------test------------------------------------  @Test public void test1() { int[] A = {1, 3, 6, 4, 1, 2}; int expected = 5; int actual = solution(A); assertEquals(expected, actual); } @Test public void test2() { int[] A = {-2, 29, -9, 0}; int expected = 1; int actual = solution(A); assertEquals(expected, actual); } } Prefix Sums PassingCars Short Problem Definition:
Count the number of passing cars on the road.
Complexity:
 expected worst-case time complexity is O(N); expected worst-case space complexity is O(1) Execution:  Count all cars heading in one direction (west). Each car heading the other direction (east) passes all cars that went west so far. Note that east cars at the beginning of the list pass no cars! Also do not forget the upper limit!
Solution:
package PassingCars; /* A non-empty zero-indexed array A consisting of N integers is given. The consecutive elements of array A represent consecutive cars on a road. Array A contains only 0s and/or 1s: 0 represents a car traveling east, 1 represents a car traveling west. The goal is to count passing cars. We say that a pair of cars (P, Q), where 0 ≤ P &amp;lt; Q &amp;lt; N, is passing when P is traveling to the east and Q is traveling to the west. For example, consider array A such that: A[0] = 0 A[1] = 1 A[2] = 0 A[3] = 1 A[4] = 1 We have five pairs of passing cars: (0, 1), (0, 3), (0, 4), (2, 3), (2, 4). Write a function: class Solution { public int solution(int[] A); } that, given a non-empty zero-indexed array A of N integers, returns the number of pairs of passing cars. The function should return −1 if the number of pairs of passing cars exceeds 1,000,000,000. For example, given: A[0] = 0 A[1] = 1 A[2] = 0 A[3] = 1 A[4] = 1 the function should return 5, as explained above. Assume that: N is an integer within the range [1..100,000]; each element of array A is an integer that can have one of the following values: 0, 1. Complexity: expected worst-case time complexity is O(N); expected worst-case space complexity is O(1), beyond input storage (not counting the storage required for input arguments). Elements of input arrays can be modified. */ // you can also use imports, for example: // import java.util.*;  // you can use System.out.println for debugging purposes, e.g. // System.out.println(&amp;#34;this is a debug message&amp;#34;);  import org.junit.Test; import static org.junit.Assert.*; public class Solution { public int solution(int[] A) { // write your code in Java SE 8  final int N = A.length; int east_cars = 0; //before current, how many cars head east?  int cnt_passing = 0; for(int i = 0; i &amp;lt; N; &#43;&#43;i) { if(A[i] == 0) { east_cars&#43;&#43;; } else { cnt_passing &#43;= east_cars; if(cnt_passing &amp;gt; 1000000000) return -1; } } return cnt_passing; } //-----------------------test------------------------------------  @Test public void test1() { int[] A = {0, 1, 0, 1, 1}; int expected = 5; int actual = solution(A); assertEquals(expected, actual); } } GenomicRangeQuery Short Problem Definition:
Find the minimal nucleotide from a range of sequence DNA.
Complexity:
 expected worst-case time complexity is O(N&#43;M); expected worst-case space complexity is O(N) Execution:  Remember the last position on which was the genome (A, C, G, T) was seen. If the distance between Q and P is lower than the distance to the last seen genome, we have found the right candidate.
Solution:
MinAvgTwoSlice Short Problem Definition:
Find the minimal average of any slice containing at least two elements.
Complexity:
 expected worst-case time complexity is O(N); expected worst-case space complexity is O(N) Execution:  Every slice must be of size two or three. Slices of bigger sizes are created from such smaller slices. Therefore should any bigger slice have an optimal value, all sub-slices must be the same, for this case to hold true. Should this not be true, one of the sub-slices must be the optimal slice. The others being bigger. Therefore we check all possible slices of size 2&amp;frasl;3 and return the smallest one. The first such slice is the correct one, do not use &amp;lt;=!
Solution:
package MinAvgTwoSlice; /* A non-empty zero-indexed array A consisting of N integers is given. A pair of integers (P, Q), such that 0 ≤ P &amp;lt; Q &amp;lt; N, is called a slice of array A (notice that the slice contains at least two elements). The average of a slice (P, Q) is the sum of A[P] &#43; A[P &#43; 1] &#43; ... &#43; A[Q] divided by the length of the slice. To be precise, the average equals (A[P] &#43; A[P &#43; 1] &#43; ... &#43; A[Q]) / (Q − P &#43; 1). For example, array A such that: A[0] = 4 A[1] = 2 A[2] = 2 A[3] = 5 A[4] = 1 A[5] = 5 A[6] = 8 contains the following example slices: slice (1, 2), whose average is (2 &#43; 2) / 2 = 2; slice (3, 4), whose average is (5 &#43; 1) / 2 = 3; slice (1, 4), whose average is (2 &#43; 2 &#43; 5 &#43; 1) / 4 = 2.5. The goal is to find the starting position of a slice whose average is minimal. Write a function: class Solution { public int solution(int[] A); } that, given a non-empty zero-indexed array A consisting of N integers, returns the starting position of the slice with the minimal average. If there is more than one slice with a minimal average, you should return the smallest starting position of such a slice. For example, given array A such that: A[0] = 4 A[1] = 2 A[2] = 2 A[3] = 5 A[4] = 1 A[5] = 5 A[6] = 8 the function should return 1, as explained above. Assume that: N is an integer within the range [2..100,000]; each element of array A is an integer within the range [−10,000..10,000]. Complexity: expected worst-case time complexity is O(N); expected worst-case space complexity is O(N), beyond input storage (not counting the storage required for input arguments). Elements of input arrays can be modified. */ // you can also use imports, for example: // import java.util.*;  // you can use System.out.println for debugging purposes, e.g. // System.out.println(&amp;#34;this is a debug message&amp;#34;);  import org.junit.Test; import static org.junit.Assert.*; public class Solution { public int solution(int[] A) { // write your code in Java SE 8  final int N = A.length; int min_start_index = 0; double min_average = Integer.MAX_VALUE; for(int i = 0; i &amp;lt; N-1; &#43;&#43;i) { double avg = (A[i] &#43; A[i&#43;1]) / 2.0; if(avg &amp;lt; min_average) { min_start_index = i; min_average = avg; } if(i&#43;2 &amp;lt; N) { avg = (A[i] &#43; A[i&#43;1] &#43; A[i&#43;2]) / 3.0; if(avg &amp;lt; min_average) { min_start_index = i; min_average = avg; } } } return min_start_index; } //-----------------------test------------------------------------  @Test public void test1() { int[] A = {4, 2, 2, 5, 1, 5, 8}; int expected = 1; int actual = solution(A); assertEquals(expected, actual); } } &amp;nbsp;
CountDiv Short Problem Definition:
Compute number of integers divisible by k in range [a..b].
Complexity:
 expected worst-case time complexity is O(1); expected worst-case space complexity is O(1) Execution:  This little check required a bit of experimentation. One needs to start from the first valid value that is bigger than A and a multiply of K.
Solution:
Sorting Triangle Short Problem Definition:
Determine whether a triangle can be built from a given set of edges.
Complexity:
 expected worst-case time complexity is O(N*log(N)); expected worst-case space complexity is O(N) Execution:  By sorting the array, we have guaranteed that P&#43;R &amp;lt; Q and Q&#43;R &amp;lt; P (because R is always the biggest). Now what remains, is the proof that P&#43;Q &amp;gt; R, that can be found out by traversing the array. The chance to find such a combination is with three adjacent values as they provide the highest P and Q.
Solution:
Distinct  Short Problem Definition:
Compute number of distinct values in an array.
Complexity:
 expected worst-case time complexity is O(N * log(N)); expected worst-case space complexity is O(N) Execution:  Sorting in both C&#43;&#43; and Python takes N log N time. We know that for this particular problem sorting the array will be the dominant runtime complexity. This is the case for the second python solution. What about the other ones?
The first solution is a neat pythonic way of solving a distinct entries problem. The set is implemented as a hash table so it is possible that it will degrade to a linked list. Therefore the actual worst case would be N^2.
This is not the case with C&#43;&#43; (as code 3 shows). The std set is a Red-Black Tree and therefore has insertion complexity of log N. (overall N log N)
Solution:
MaxProductOfThree Short Problem Definition:
Maximize A[P] * A[Q] * A[R] for any triplet (P, Q, R).
Complexity:
 expected worst-case time complexity is O(N*log(N)); expected worst-case space complexity is O(1) Execution:  After sorting the largest product can be found as a combination of the last three elements. Additionally, two negative numbers add to a positive, so by multiplying the two largest negatives with the largest positive, we get another candidate. If all numbers are negative, the three largest (closest to 0) still get the largest element!
Solution:
NumberOfDiscIntersections Stacks and Queues Brackets Short Problem Definition:
Determine whether a given string of parentheses is properly nested.
Complexity:
 expected worst-case time complexity is O(N); expected worst-case space complexity is O(N) Execution:  Put every opening bracket on a stack. If a closing bracket is not the same as the top stack bracket, the string is not properly nested.
Solution:
Nesting Short Problem Definition:
Determine whether given string of parentheses is properly nested.
Complexity:
 expected worst-case time complexity is O(N); expected worst-case space complexity is O(1) Execution:  Because there is only one type of brackets, the problem is easier than Brackets. Just check if there is always a opening bracket before a closing one.
StoneWall Short Problem Definition:
Cover “Manhattan skyline” using the minimum number of rectangles.
Complexity:
 expected worst-case time complexity is O(N); expected worst-case space complexity is O(N) Execution:  The explanation to this challenge has been posted on the Codility web, you can read it here.
Solution:
Fish Short Problem Definition:
N voracious fish are moving along a river. Calculate how many fish are alive.
Complexity:
 expected worst-case time complexity is O(N); expected worst-case space complexity is O(N) Execution:  Put all downstream swimming fishes on a stack. Any upstream swimming fish has to fight(eat) all fishes on the stack. If there is no fish on the stack, the fish survives. If the stack has some downstream fishes at the end, they also survive.
Solution:
Leader Dominator Short Problem Definition:
Find an index of an array such that its value occurs at more than half of indices in the array.
Complexity:
 expected worst-case time complexity is O(N); expected worst-case space complexity is O(1) Execution:  As explained in the training material…
Solution:
EquiLeader Short Problem Definition:
Find the index S such that the leaders of the sequences A[0], A[1], …, A[S] and A[S &#43; 1], A[S &#43; 2], …, A[N – 1] are the same.
Complexity:
 expected worst-case time complexity is O(N); expected worst-case space complexity is O(N) Execution:  Get the leader as in the training material. Afterwards check every position if both sides have enough leader occurrences.
Solution:
Maximum Slice Problem MaxProfit Short Problem Definition:
Given a log of stock prices compute the maximum possible earning.
Complexity:
 expected worst-case time complexity is O(N); expected worst-case space complexity is O(1) Execution:  Keep the minimal value up to day. The profit on day i is_ profit[i] – minprofit.
Solution:
MaxSliceSum Short Problem Definition:
Find a maximum sum of a compact subsequence of array elements.
Complexity:
 expected worst-case time complexity is O(N); expected worst-case space complexity is O(N) Execution:  The only difference to the example given by Codility is the minimal slice length, which is 1.
Solution:
MaxDoubleSliceSum Short Problem Definition:
Find the maximal sum of any double slice.
Complexity:
 expected worst-case time complexity is O(N); expected worst-case space complexity is O(N) Execution:  To solve this task, you need to keep track of two slice arrays. The optimal double slice can be found at an index that has the maximal sum of those two arrays. It can not be the 0th or the last index.
Solution:
Prime and composite numbers MinPerimeterRectangle Short Problem Definition:
Find the minimal perimeter of any rectangle whose area equals N.
Complexity:
 expected worst-case time complexity is O(sqrt(N)); expected worst-case space complexity is O(1). Execution:  Trivial search for the largest prime.
CountFactors Short Problem Definition:
Count factors of given number N.
Complexity:
 expected worst-case time complexity is O(sqrt(N)); expected worst-case space complexity is O(1). Execution:  This example can be found in the lesson document.
Peaks Short Problem Definition:
A non-empty zero-indexed array A consisting of N integers is given. A peak is an array element which is larger than its neighbors.
Complexity:
 expected worst-case time complexity is O(N*log(log(N))); expected worst-case space complexity is O(N) Execution:  I first compute all peaks. Because each block must contain a peak I start from the end and try to find a integral divisor sized block. If each block contains a peak I return the size.
Solution:
Flags Sieve or Eratosthenes CountSemiprimes Short Problem Definition:
Count the semiprime numbers in the given range [a..b]
Complexity:
 expected worst-case time complexity is O(N*log(log(N))&#43;M); expected worst-case space complexity is O(N&#43;M) Execution:  First get all semiprimes from an adaptation of the Sieve of Eratosthenes. Because we will be computing the difference many times a prefix sum is adequate. Get the number of semiprimes up to the point. The index P is decreased by 1 because we want to know all primes that start from P.
Solution:
CountNonDivisible Short Problem Definition:
Calculate the number of elements of an array that are not divisors of each element.
Complexity:
 expected worst-case time complexity is O(N*log(N)); expected worst-case space complexity is O(N) Execution:  Using the Sieve of Eratosthenes, you generate divisors for all input elements of A. If a given number x is a divisor of element (x*N == element), then N also is a divisor. _(N = element//x)._ After all divisors are computed, we simply subtract those (multiplied by their counts or 0) from the total number of elements in A.
Solution:
Euclidean Algorithm ChocolatesByNumbers Short Problem Definition:
There are N chocolates in a circle. Count the number of chocolates you will eat.
&amp;nbsp;
Complexity:
 expected worst-case time complexity is O(log(N&#43;M)); expected worst-case space complexity is O(1) Execution:  N and M meet at their least common multiply. Dividing this LCM by M gets the number of steps(chocolates) that can be eaten.
Solution:
CommonPrimeDivisors Short Problem Definition:
Check whether two numbers have the same prime divisors.
Complexity:
 expected worst-case time complexity is O(Z*log(max(A)&#43;max(B))2); expected worst-case space complexity is O(1) Execution:  I will post an explaining image soon!
Solution:
Fibonacci Numbers FibFrog Short Problem Definition:
Count the minimum number of jumps required for a frog to get to the other side of a river.
Complexity:
 expected worst-case time complexity is O(N*log(N)) expected worst-case space complexity is O(N) Execution:  This problem can be solved by in a Dynamic Programming way. You need to know the optimal count of jumps that can reach a given leaf. You get those by either reaching the leaf from the first shore or by reaching it from another leaf.
The N*log(N) time complexity is given by the fact, that there are approximately log(N) Fibonacci numbers up to N and you visit each position once.
As for the sequence hack: there are 26 Fibonacci numbers smaller than 100k, so I just preallocate an array of this size.
Solution:
Ladder Short Problem Definition:
Count the number of different ways of climbing to the top of a ladder.
Complexity:
 expected worst-case time complexity is O(L) expected worst-case space complexity is O(L) Execution:  We first compute the Fibonacci sequence for the first L&#43;2 numbers. The first two numbers are used only as fillers, so we have to index the sequence as A[idx]&#43;1 instead of A[idx]-1. The second step is to replace the modulo operation by removing all but the n lowest bits. A discussion can be found on Stack Overflow.
Solution:
Binary Search MinMaxDivision Short Problem Definition: Divide array A into K blocks and minimize the largest sum of any block.
Complexity:
 expected worst-case time complexity is O(N*log(N&#43;M)); expected worst-case space complexity is O(1) Execution:  Binary search for the minimal size of a block. A valid block can be checked in a boolean fashion. Two special cases can be sped up (courtesy to CodeSays). At the time of writing (19.9.2014) do not use the variable passed to the solution function as M! It is NOT the maximum element in the test cases! The specification says, that no element is larger than M, yet there is not guarantee that M == max(A).
Solution:
NailingPlanks Short Problem Definition:
Count the minimum number of nails that allow a series of planks to be nailed..
Complexity:
 expected worst-case time complexity is O((N&#43;M)*log(M)); expected worst-case space complexity is O(M) Execution:  The solution gets 100&amp;frasl;100, but I am skeptical. The runtime is rather O(N * (log(M)&#43;M)) than O((N&#43;M)*log(M)). Maybe it can be proven that the execution of the linear scan will never have to scan all possible positions. I also violate the space complexity by creating a copy of A&#43;B.
Solution:
Caterpillar method AbsDistinct Short Problem Definition:
Compute number of distinct absolute values of sorted array elements.
Complexity:
 expected worst-case time complexity is O(N); expected worst-case space complexity is O(N) Execution:  Additional storage is allowed. Therefore a simple python solution will suffice.
Solution:
CountDistinctSlices Short Problem Definition:
Count the number of distinct slices (containing only unique numbers).
Complexity:
 expected worst-case time complexity is O(N); expected worst-case space complexity is O(M) Execution:  Using the caterpillar method I expand the caterpillar to the right as long as a duplicate element is found. The right side has to retract as long as this duplicate element has been eliminated from the next slice. An observation showed that the number of sub-slices is equal to front-back&#43;1.
Solution:
CountTriangles Short Problem Definition:
Count the number of triangles that can be built from a given set of edges.
Complexity:
 expected worst-case time complexity is O(N2); expected worst-case space complexity is O(1) Execution:  Apply the caterpillar method. We know that in a sorted array every position between Q and R will be bigger than Q and therefore P&#43;Q will be bigger than R. I therefore either increment Q if P&#43;Q is not larger than R or increment R as far as possible.
Solution:
MinAbsSumOfTwo Short Problem Definition:
Find the minimal absolute value of a sum of two elements.
Complexity:
 expected worst-case time complexity is O(N*log(N)); expected worst-case space complexity is O(1) Execution:  Using the caterpillar method on a sorted list.
Solution:
Greedy algorithms TieRopes Short Problem Definition:
Tie adjacent ropes to achieve the maximum number of ropes of length &amp;gt;= K.
Complexity:
 expected worst-case time complexity is O(N); expected worst-case space complexity is O(N) Execution:  I am a bit skeptical about the correctness of my solution. It gets 100&amp;frasl;100 through…
Solution:
MaxNonoverlappingSegments Short Problem Definition:
Find a maximal set of non((-))overlapping segments.
Complexity:
 expected worst-case time complexity is O(N) expected worst-case space complexity is O(N) Execution:  This can be solved by using greedy search. The beginning of the next segment must come strictly after its predecessor.
Solution:
Dynamic Programming NumberSolitaire Short Problem Definition:
In a given array, find the subset of maximal sum in which the distance between consecutive elements is at most 6.
Complexity:
 expected worst-case time complexity is O(N); expected worst-case space complexity is O(N) Execution:  Prototypical Dynamic Programming. Remember all sub-solutions and use them to compute the next step. I prefixed the array by 6 min_values to use the same computation for the whole algorithm (besides the first). Do not forget to set the minimal_value small enough to handle a purely negative input array.
Solution:
MinAbsSum Future Training BinaryGap Short Problem Definition:
Find longest sequence of zeros in binary representation of an integer.
Complexity:
 expected worst-case time complexity is O(log(N)); expected worst-case space complexity is O(1) Execution:  The solution is straight-forward! Use of binary shift.
Solution:
StrSymmetryPoint Short Problem Definition:
Find a symmetry point of a string, if any.
Complexity:
 expected worst-case time complexity is O(length(S)); expected worst-case space complexity is O(1) (not counting the storage required for input arguments). Execution:  This problem gave me a lot of headache. It is so trivial I that over-complicated it. I thought that you should find a symmetry point at any possible position, ignoring the residual characters. You would obviously try to maximize the length of this symmetrical sub-array. I was not able to come with any O(S) algorithm for this problem derivation. So just to remind you,** this problem is a simple palindrome check**. Additionally, you drop all evenly sized strings as their symmetry point is between the indexes.
Solution:
OddOccurencesInArray Short Problem Definition:
Find value that occurs in odd number of elements.
Complexity:
 expected worst-case time complexity is O(N); expected worst-case space complexity is O(1) Execution:  This problem can be found in many algorithm books. A xor A cancels itself and B xor 0 is B. Therefore A xor A xor B xor C xor C is B.
Solution:
TreeHeight Short Problem Definition:
Compute the height of a binary link-tree.
Complexity:
 expected worst-case time complexity is O(N); expected worst-case space complexity is O(N) Execution:  The height of a tree is the maximal height &#43;1 of its subtrees. In this specification a tree with just the root node has a height of 0.
Solution:
ArrayInversionCount Short Problem Definition:
Compute number of inversion in an array.
Complexity:
 expected worst-case time complexity is O(N*log(N)); expected worst-case space complexity is O(N) Execution:  Any sorting algorithm with a NlogN runtime will do the trick. It is important to count all (remaining) bigger elements on the left side. Do not forget to check for the maximal return value!
Solution:
Challenges  Kalium 2015 – SqlSegmentsSum Boron 2013 – Flags Psi 2012 – Wire Burnouts Chi 2012 – Cannon Balls Sigma 2012 – StoneWall Delta 2011 – MinAbsSum Beta 2010 – NumberOfDiscIntersections Alpha 2010 – PrefixSet  </content>
    </entry>
    
     <entry>
        <title>WSDL Service Contract in Detail</title>
        <url>http://yangchao.me/post/wsdl-service-contract-in-detail/</url>
        <categories>
          <category>SOAP Web Service</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html">  Concepts in WSDL definition &amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;definitions xmlns:soap=&amp;#34;http://schemas.xmlsoap.org/wsdl/soap/&amp;#34;xmlns:tns=&amp;#34;http://rand/&amp;#34;xmlns:xsd=&amp;#34;http://www.w3.org/2001/XMLSchema&amp;#34; xmlns=&amp;#34;http://schemas.xmlsoap.org/wsdl/&amp;#34; targetNamespace=&amp;#34;http://rand/&amp;#34; name=&amp;#34;RandServiceService&amp;#34;&amp;gt; &amp;lt;types&amp;gt; &amp;lt;xsd:schema&amp;gt; &amp;lt;xsd:import namespace=&amp;#34;http://rand/&amp;#34; schemaLocation=&amp;#34;http://localhost:8888/rs?xsd=1&amp;#34;&amp;gt;&amp;lt;/xsd:import&amp;gt; &amp;lt;/xsd:schema&amp;gt; &amp;lt;/types&amp;gt; &amp;lt;message name=&amp;#34;next1&amp;#34;&amp;gt; &amp;lt;part name=&amp;#34;parameters&amp;#34; element=&amp;#34;tns:next1&amp;#34;&amp;gt;&amp;lt;/part&amp;gt; &amp;lt;/message&amp;gt; &amp;lt;message name=&amp;#34;next1Response&amp;#34;&amp;gt; &amp;lt;part name=&amp;#34;parameters&amp;#34; element=&amp;#34;tns:next1Response&amp;#34;&amp;gt;&amp;lt;/part&amp;gt; &amp;lt;/message&amp;gt; &amp;lt;message name=&amp;#34;nextN&amp;#34;&amp;gt; &amp;lt;part name=&amp;#34;parameters&amp;#34; element=&amp;#34;tns:nextN&amp;#34;&amp;gt;&amp;lt;/part&amp;gt; &amp;lt;/message&amp;gt; &amp;lt;message name=&amp;#34;nextNResponse&amp;#34;&amp;gt; &amp;lt;part name=&amp;#34;parameters&amp;#34; element=&amp;#34;tns:nextNResponse&amp;#34;&amp;gt;&amp;lt;/part&amp;gt; &amp;lt;/message&amp;gt; &amp;lt;portType name=&amp;#34;RandService&amp;#34;&amp;gt; &amp;lt;operation name=&amp;#34;next1&amp;#34;&amp;gt; &amp;lt;input message=&amp;#34;tns:next1&amp;#34;&amp;gt;&amp;lt;/input&amp;gt; &amp;lt;output message=&amp;#34;tns:next1Response&amp;#34;&amp;gt;&amp;lt;/output&amp;gt; &amp;lt;/operation&amp;gt; &amp;lt;operation name=&amp;#34;nextN&amp;#34;&amp;gt; &amp;lt;input message=&amp;#34;tns:nextN&amp;#34;&amp;gt;&amp;lt;/input&amp;gt; &amp;lt;output message=&amp;#34;tns:nextNResponse&amp;#34;&amp;gt;&amp;lt;/output&amp;gt; &amp;lt;/operation&amp;gt; &amp;lt;/portType&amp;gt; &amp;lt;!-- implementation dependent definition --&amp;gt; &amp;lt;binding name=&amp;#34;RandServicePortBinding&amp;#34; type=&amp;#34;tns:RandService&amp;#34;&amp;gt; &amp;lt;soap:binding transport=&amp;#34;http://schemas.xmlsoap.org/soap/http&amp;#34; style=&amp;#34;document&amp;#34;&amp;gt;&amp;lt;/soap:binding&amp;gt; &amp;lt;operation name=&amp;#34;next1&amp;#34;&amp;gt; &amp;lt;soap:operation soapAction=&amp;#34;&amp;#34;&amp;gt;&amp;lt;/soap:operation&amp;gt; &amp;lt;input&amp;gt; &amp;lt;soap:body use=&amp;#34;literal&amp;#34;&amp;gt;&amp;lt;/soap:body&amp;gt; &amp;lt;/input&amp;gt; &amp;lt;output&amp;gt; &amp;lt;soap:body use=&amp;#34;literal&amp;#34;&amp;gt;&amp;lt;/soap:body&amp;gt; &amp;lt;/output&amp;gt; &amp;lt;/operation&amp;gt; &amp;lt;operation name=&amp;#34;nextN&amp;#34;&amp;gt; &amp;lt;soap:operation soapAction=&amp;#34;&amp;#34;&amp;gt;&amp;lt;/soap:operation&amp;gt; &amp;lt;input&amp;gt; &amp;lt;soap:body use=&amp;#34;literal&amp;#34;&amp;gt;&amp;lt;/soap:body&amp;gt; &amp;lt;/input&amp;gt; &amp;lt;output&amp;gt; &amp;lt;soap:body use=&amp;#34;literal&amp;#34;&amp;gt;&amp;lt;/soap:body&amp;gt; &amp;lt;/output&amp;gt; &amp;lt;/operation&amp;gt; &amp;lt;/binding&amp;gt; &amp;lt;service name=&amp;#34;RandServiceService&amp;#34;&amp;gt; &amp;lt;port name=&amp;#34;RandServicePort&amp;#34; binding=&amp;#34;tns:RandServicePortBinding&amp;#34;&amp;gt; &amp;lt;soap:address location=&amp;#34;http://localhost:8888/rs&amp;#34;&amp;gt;&amp;lt;/soap:address&amp;gt; &amp;lt;/port&amp;gt; &amp;lt;port name=&amp;#34;StandbyServicePort&amp;#34; binding=&amp;#34;tns:RandServicePortBinding&amp;#34;&amp;gt; &amp;lt;soap:address location=&amp;#34;http://localhost:9999/rs&amp;#34;&amp;gt;&amp;lt;/soap:address&amp;gt; &amp;lt;/port&amp;gt; &amp;lt;/service&amp;gt; &amp;lt;/definitions&amp;gt; In the following diagram, please observe the relationship:
 A web service can has only one PortType, but has multiple Bindings and Ports. Multiple Bindings refer to the ONLY one PortType. Multiple Ports can map into one Binding.   Port Type Port type is an implementation-neutral definition. You can regard it as the equivalent of a Java Class.
It contains multiple operations with MEP(message exchange pattern), which is similar as class methods. A parameter of a operation is called a part.
Binding Binding is a wire/transport protocol definition. It includes the message format and transport combination.
Port Port is a term related deployment. Basically, it connects a Binding with a Endpoint.
Target namespace A namespace must be a URI. Sometimes using URL as the namespace may make others confused, because they may use this URL to download your WSDL but often failed. Instead using URN as the namespace can effectively avoid this case.
WSDL sections types section Here we can define XML Schema types or import types definitions from separate XSD files.
message section Every message can have one or more parts. A part can be specify by type or element attribute.
portType section PortType basically defines an abstract service interface: **operations **and the Message Exchange Patterns (MEP).
Message Exchange Patterns (MEP) WSDL supports four basic patterns of operation:    use scenarios    In-Out most commonly used: request / response **   In-Only send without expecting response: one-way messaging    Out-In solicit / response *   Out-Only one-way server push: notification or (asynchronous) callback **   
In-Out ... &amp;lt;operation name=&amp;#34;query&amp;#34;&amp;gt; &amp;lt;input message=&amp;#34;tns:query&amp;#34;&amp;gt;&amp;lt;/input&amp;gt; &amp;lt;output message=&amp;#34;tns:queryResponse&amp;#34;&amp;gt;&amp;lt;/output&amp;gt; &amp;lt;/operation&amp;gt; ... Out-In ... &amp;lt;operation name=&amp;#34;questionnaire&amp;#34;&amp;gt; &amp;lt;output message=&amp;#34;tns:questionnaire&amp;#34;&amp;gt;&amp;lt;/output&amp;gt; &amp;lt;input message=&amp;#34;tns:questionnaireFeedback&amp;#34;&amp;gt;&amp;lt;/input&amp;gt; &amp;lt;/operation&amp;gt; ... In-Only ... &amp;lt;operation name=&amp;#34;ping&amp;#34;&amp;gt; &amp;lt;input message=&amp;#34;tns:ping&amp;#34;&amp;gt;&amp;lt;/input&amp;gt; &amp;lt;/operation&amp;gt; ... Out-Only ... &amp;lt;operation name=&amp;#34;notification&amp;#34;&amp;gt; &amp;lt;output message=&amp;#34;tns:notificationResponse&amp;#34;&amp;gt;&amp;lt;/output&amp;gt; &amp;lt;/operation&amp;gt; ... bindings section There can be many bindings sections.
Bindings defines a concrete Web service implementation, like transport (HTTP, STMP..), service style and SOAP version.
transport transport options: http, stmp&amp;hellip;
document-style vs. rpc-style service styles: document-style, rpc-style
 document style means that SOAP body contains a XML document which can be validated against pre-defined XML schema document. (There&amp;rsquo;s also a variation called wrapped that is still specified as document)
 rpc style really means that SOAP message body contains an XML representation of a method call and uses the names of the method and its parameters to generate XML structures that represent a method’s call stack. It adds extra elements to simulate a method call. (rpc is a misleading name, which has nothing to do with a programming model)
  literal vs. encoded operation parts &amp;ldquo;use&amp;rdquo; has two options: encoded, literal. It determines how a data value should be encoded in an XML format.
 literal means that the data is serialized according to a XML schema encoded means that the service’s type definitions come from implicit encoding rules, typically the rules in the SOAP 1.1 specification. The soapAction attribute specifies the value of the SOAPAction header for this operation as an absolute URL.  For the HTTP protocol binding of SOAP, this is value required (it has no default value). For other SOAP protocol bindings, it MUST NOT be specified.
service section Defines a port, or Web service destination, in terms of the above binding plus a URL.
The service element has port subelements, where a port is linked to a binding. 
The address subelement of a port specifies a location, whose value is commonly called the service endpoint.
Common confusions service styles: document vs. rpc   RPC Document  `&amp;lt;soapbind:binding&amp;gt;`element `style=&#34;rpc&#34;` `style=&#34;document&#34;`  `&amp;lt;wsdl:part&amp;gt;`element(s) Any number of `&amp;lt;part&amp;gt;` elements, each containing a _type_ attribute Single `&amp;lt;part&amp;gt;` element containing an _element_attribute; zero also allowed    RPC-style SOAP: ```java &amp;lt;tns:matchNoteAndNote xmlns:tns=&#34;urn:outline.demo&#34;&amp;gt; &amp;lt;in0 xsi:type=&#34;xsd:string&#34;&amp;gt;0000000000&amp;lt;/in0&amp;gt; &amp;lt;in1 xsi:type=&#34;xsd:string&#34;&amp;gt;000000000B&amp;lt;/in1&amp;gt; &amp;lt;/tns:matchNoteAndNote&amp;gt; ``` ```java &amp;lt;tns:matchNoteAndNoteResponse xmlns:tns=&#34;urn:outline.demo&#34;&amp;gt; &amp;lt;matchNoteAndNoteReturn xsi:type=&#34;xsd:string&#34;&amp;gt;yes&amp;lt;/in0&amp;gt; &amp;lt;/tns:matchNoteAndNoteResponse&amp;gt; ``` Document-style SOAP: ```java &amp;lt;out:getNoteResponse xmlns:out=&#34;urn:outline.demo&#34;&amp;gt; &amp;lt;out:note key=&#34;000000000B&#34; &amp;gt; &amp;lt;out:content&amp;gt;test&amp;lt;/out:content&amp;gt; &amp;lt;/out:note&amp;gt; &amp;lt;/out:getNoteResponse&amp;gt; ``` #### uses: literal vs. encoded   **SOAP encoded** **Literal**  `&amp;lt;soapbind:body&amp;gt;` `use`attribute `use=&#34;encoded&#34;` `use=&#34;literal&#34;`  Other `&amp;lt;soapbind:body&amp;gt;`attributes `encodingStyle=&#34;http://schemas.xmlsoap.org/soap/encoding/&#34;` Optional: `parts` attribute referring to a`&amp;lt;wsdl:part&amp;gt;` name    SoapAction //TODO
</content>
    </entry>
    
     <entry>
        <title>Garbage Collection</title>
        <url>http://yangchao.me/post/garbage-collection/</url>
        <categories>
          <category>JVM</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html">  References:
 &amp;lt;Inside the Java Virtual Machine&amp;gt; &amp;lt;Java Performance - The Definitive Guide&amp;gt;  GC overview Heap Layout Geneation spaces Nearly every JVM uses generational garbage collectors. They work by splitting the heap into different generations:
 Old generation (tenured generation) Young generation, which is further divided into sections: Eden and Survivor spaces.   minor GC GC for the young generation is called minor GC. All GC algorithms have stop-the-world pauses during collection of the young generation.
 Objects that are no longer in use are discarded, and objects that are still in use are moved elsewhere. all objects in eden are either moved to the unused survivor space(To survivor space) or discarded: all objects in From survivor space are either discarded or moved to the unused survivor space(To survivor space) or moved to the old generation (when still liveable after a few minor GC). Since all objects are moved, the young generation is automatically compacted when it is collected. After every minor GC, the From survivor space and To survivor space are swapped.   full GC GC for the old generation collection is called full GC. Concurrent collectors scan for unused objects can occur without stopping application threads, such as CMS and G1.
Garbage collectors Early GC uses reference counting strategy. But now nearly all the GCs use Tracing garbage strategies, which trace out the graph of object references starting with the root nodes.
The basic tracing algorithm is called &amp;ldquo;mark and sweep&amp;rdquo; :
 In the mark phase, the garbage collector traverses the tree of references and marks each object it encounters. In the sweep phase, unmarked objects are freed, and the resulting memory is made available to the executing program. In the JVM, the sweep phase must include finalization of objects. Two strategies for defragmentation: compacting and copying
 **compacting algorithm **slides live objects over free memory space toward one end of the heap
 copying algorithm moves all live objects to a new area, placed side by side with current area.    serial GC throughput / parallel GC CMS GC G1   designed for client machine: 32bit JVM on Windows or single processor machine (default) server machine: multi-CPU Unix machine or 64-bit JVM (default)  process large heaps (greater than about 4 GB) with minimal pauses divides the heap into a number of regions   minor GC performs with single thread stop all application threads performs with multiple threads stop all application threads performs with multiple threads stops all application threads performs with multiple threads stops all application threads   full GC performs with single threads stop all application threads performs with multiple threads stop all application threads uses one or more background threads to periodically scan through the old generation don&amp;rsquo;t stop application threads processed by background threads don’t need to stop the application threads   flag -XX:&#43;UseSerialGC -XX:&#43;UseParallelGC -XX:&#43;UseParallelOldGC -XX:&#43;UseConcMarkSweepGC -XX:&#43;UseParNewGC -XX:&#43;UseG1GC      when too fragmented -&amp;gt; serial colletor G1 can clean up objects from the old generation by copying from one region into another,it (at least partially) compacts the heap during normal processing less likely to be fragmented    In GC algorithms, there are several terms:
  Parallelism / Serialism: there is a single thread or multiple threads for the GC?
Concurrency: the GC threads are running exclusively or along with the application threads? If exclusively, that&amp;rsquo;s when the &amp;ldquo;stop-the-world&amp;rdquo; happens.
&amp;nbsp;
You can see, all GC algorithms use &amp;ldquo;stop-the-world&amp;rdquo; when doing minor GC.
Triggered when:
 a minor GC will be triggered when the new generation is full a full GC will be triggered when the old generation is full, or a concurrent GC (if applicable) will be triggered when the heap starts to fill up.  Serial collector Parallel collector Default GC for server class machine. The throughput matters!
Two variations
 Multi-threaded young generation (minor) GC with single threaded old generation (full) GC -XX:&#43;UseParallelGC default GC in Java 6 through Java 7 update 3.
 Multiple-threaded young generation (minor) GC with multi-threaded old generation (full) GC -XX:&#43;UseParallelOldGC default GC in Java 7 update 4 or over.
  Both young generation and old generation GC(both minor and full GC) are &amp;ldquo;stop-the-world&amp;rdquo; events.
Minor GC Full GC CMS collector CMS is the Concurrent Mark-and-Sweep collector.
The minor GC has no difference with Parallel collector, but the full GC cycle is _mostly_ concurrent and includes several phases: initial mark phase, concurrent mark &amp;amp; pre-cleaning phase, remark phase, concurrent sweep phase.
There are still &amp;ldquo;stop-the-world&amp;rdquo; events in the initial mark and remark phases.
Minor GC Trigger when young generation exhausted
full GC (Concurrent Cycle)  mostly concurrent old generation GC, some phases run concurrently with the application, some are &amp;ldquo;stop-the-world&amp;rdquo;, some phases are single threaded. does not compact old generation, but the &amp;ldquo;stop-the-world&amp;rdquo;, single threaded compaction will occur if: 1) concurrent cycle not keeping up 2) too fragment. Triggered at old generation space occupancy threshold &amp;ndash; default is around 70%. This can be adjusted by-XX:CMSInitiatingOccupancyFraction=n   Phases     initial-mark phase &amp;ldquo;stop-the-world&amp;rdquo; single threaded   concurrent marking phase run concurrently with the application multi-threaded   pre-cleaning phase run concurrently with the application multi-threaded   remark phase &amp;ldquo;stop-the-world&amp;rdquo; multi-threaded   concurrent sweeping phase run concurrently with the application multi-threaded      PerGen collection enable Permanent generation space can also be collected concurrently by set:
-XX:&#43;CMSClassUnloadingEnable
-XX:CMSInitiatingPermOccupancyFraction=n
-XX:&#43;CMSInitiatingPermOccupancyOnly
G1 collector G1 is Garbage First.
G1 uses a drastically different Java heap layout to the other garbage collectors in the HotSpot VM. It splits the Java heap into equal-sized chunks called regions. Even though G1 is generational, it does not have physically separate spaces for the young and old generations. Instead, each generation is a set of (maybe noncontiguous) regions.
PerGen(JDK 7) / metaspace (JDK 8)
&amp;nbsp;
</content>
    </entry>
    
     <entry>
        <title>JVM knowledge</title>
        <url>http://yangchao.me/post/jvm-knowledge/</url>
        <categories>
          <category>JVM</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html">  references:
 &amp;lt;Inside the Java Virtual Machine&amp;gt; &amp;lt;Java Virtual Machine specification 7&amp;gt;  run-time data areas pc registers Every JVM thread has its own pc(program counter) register.
The pc register is one word in size, so it can hold both a native pointer and a returnAddress.
If a thread is executing a native method, the value of the pc register is undefined.
JVM stacks Every thread has a private JVM stacks. It stores frames.
It can be of fixed size or dynamically expanded and contracted as required.
The JVM only performs two operations directly on Java Stacks: it pushes and pops frames.
heap   hiːp  The JVM has a heap. It stores all class instances and arrays.
 Heap storage for objects is reclaimed by an automatic storage management system (aka. GC or garbage collector).
It can be of fixed size or dynamically expanded as required by the computation and may be contracted if larger heap becomes unnecessary.
JVM provides options for initial size, and if the heap can be dynamically expanded or contracted, users can control over the maximum and minimum size of the heap.
method area It&amp;rsquo;s logically part of the heap. It stores per-class structures, such as the run-time constant pool, field and method data and the code for methods and constructors (including special methods like &amp;lt;init&amp;gt; and &amp;lt;clinit&amp;gt;).
&amp;nbsp;
per-class structure(class data) includes:
Type Information  The fully qualified name of the type The fully qualified name of the type&amp;rsquo;s direct superclass (unless the type is an interface or class java.lang.Object, neither of which have a superclass) Whether or not the type is a class or an interface The type&amp;rsquo;s modifiers ( some subset ofpublic,abstract,final`) An ordered list of the fully qualified names of any direct superinterfaces  run-time Constant Pool A constant pool is an ordered set of constants used by the type, including literals (string, integer, and floating point constants) and symbolic references to types, fields, and methods.
These symbolic references to all types, fields, and methods used by a type, the constant pool plays a central role in the dynamic linking of Java programs.
Field Information  The field&amp;rsquo;s name The field&amp;rsquo;s type The field&amp;rsquo;s modifiers (some subset of public, private, protected, static, final, volatile, transient)  Method Information  The method&amp;rsquo;s name The method&amp;rsquo;s return type (or void) The number and types (in order) of the method&amp;rsquo;s parameters The method&amp;rsquo;s modifiers (some subset of public, private, protected, static, final, synchronized, native, abstract) for non-abstract method:
 The method&amp;rsquo;s bytecodes
 The sizes of the operand stack and local variables sections of the method&amp;rsquo;s stack frame (these are described in a later section of this chapter)
 An exception table
  Class Variables JVM must allocate memory from the method area for each non-final class variable declared in the class.
final class variable (constant) is not here, they are in constant pool instead.
A Reference to Class ClassLoader The virtual machine must store a reference to the user-defined class loader that loaded the type. (if the type is loaded by bootstrap class loader, the reference is not required) &amp;gt; NOTICE: method area just stores the reference to ClassLoader. The ClassLoader instance itself is allocated in the heap.
A Reference to Class Class  NOTICE: method area just stores the reference to Class. The Class instance itself is allocated in the heap.
 Method Tables A method table is an array of direct references to all the instance methods that may be invoked on a class instance, including instance methodsinherited from superclasses.
A method table allows a virtual machine to quickly locate an instance method invoked on an object.
run-time data structures run-time constant pool It&amp;rsquo;s a per-class or per-interface representation of the constant_pool table in a class file.
It&amp;rsquo;s constructed when the class or the interface created by JVM.
frames A frame is used to store data and partial result, as well as to perform dynamic linking, return values for methods and dispatch exceptions.
It&amp;rsquo;s created each time a method is invoked.
Frames could be allocated on a contiguous stack, or they could be allocated on a heap, or some combination of both.
In a given thread of control, only the frame for the executing method is active. This active frame is calls current frame, and the executing method is called current method. The class in which the current method is defined is called** current class**.
Now we will go to the components of a frame:
local variables Each frame contains an array of local variables known as local variables.
The length of the local variable array can be determined at compile-time and supplied in a binary class file.
 A single variable can hold a value of type boolean, byte, char, short, int, float, reference, or returnAddress. A pair of variables can hold a value of typelong, double. On class method invocation, any parameters are passed in from local variable 0.  On instance method invocation, local variable 0 is always the reference to the instance object. (aka, this)
class Example3a { public static int runClassMethod(int i, long l, float f, double d, Object o, byte b) { return 0; } public int runInstanceMethod(char c, double d, short s, boolean b) { return 0; } } operand stack Each frame contains a LIFO stack known as operand stack. It&amp;rsquo;s mainly for operations on operands and partial/intermediate result storage.
The maximum depth of the operand stack can be determined at compile-time and supplied in a binary class file.
operations on operand stack:
 load constants or values from local variables onto the operand stack tack operands from the operand stack, operate on them, and push the result onto the operand stack.  int c = a &#43; b The above source code has the instructions:
iload_0 // push the int in local variable 0 iload_1 // push the int in local variable 1 iadd // pop two ints, add them, push result istore_2 // pop int, store into local variable 2 Frame Data The Java stack frame includes data to support constant pool resolution, normal method return, and exception dispatch, also some implementation dependent information, such as data to support debugging.
normal method invocation completion When normal completion, the frame of current method is popped and the return value (if any) is pushed onto the operand stack of the invoker&amp;rsquo;s frame.
abrupt method invocation completion Every method is associated with zero or more exception handlers.
When an exception occurs, the JVM searches for a matching exception handler in the current method.
When no such exception handler is found to handle the exception, the current method invocation completes abruptly. At this time, the operand stack and local variables of the current method invocation are discarded, and its frame is popped. Then the exception is rethrowed in the context of the invoker&amp;rsquo;s frame and so on.
If no suitable exception handler is found before the top of method invocation chain is reached, the execution of the thread is terminated.
The following is an possible implementation which allocates frames from the heap.
class file format This is about binary representation of a class.
loading, linking and initializing This is for run-time representation of a class.
&amp;nbsp;
&amp;nbsp;
</content>
    </entry>
    
     <entry>
        <title>Apache CXF and Axis 2 tutorial</title>
        <url>http://yangchao.me/post/apache-cxf-and-axis-2-tutorial/</url>
        <categories>
          <category>Web Service</category>
        </categories>
        <tags>
          <tag>TODO</tag>
        </tags>
        <content type="html">  Apache Axis2 How to build a service Axis2 supports 3 programming model
Create a service from scratch  Write a class whose methods use OMElement as arguments and/or return type create a services.xml package as a .aar file deploy  POJO for rpc-style services Generate the service skeleton from WSDL &amp;nbsp;   实现方式
 创建方式
 应用文档对象模型解析(消息绑定)
 　应用(数据绑定框架)解析　(xml to DO) 可插入的数据绑定   POJOs
 pojo结合rpc模式
 AXIOM
 　POJOsPOJO&#43;RPC
优点：自己写客户端，容易出错，不用熟悉WSDL。
缺点：用此方法进行调试不容易   AXIOM
 axiom api从底层写
 AXIOM
 _　无_优点：可以进行高效的 SOAP 消息处理
缺点：全部自己实现，不现实。   ADB
 从wsdl生成
相应框架，
然后填写相
应逻辑
 AXIOM
 　ADB开发符合软件工程的过程，先写设计，定接口　（写WSDL）然后再实现。用WSDL生成代码，不用关　心底层的调用。   XMLBeans
 AXIOM
 XMLBean(BEA)   JiBX
 AXIOM
 JiBX    &amp;nbsp;
How to deploy a service Often axis2 uses its own package named .aar, and the layout of this archive is like:
\---BookService \---META-INF | services.xml | \---lib | dependency1.jar | dependency2.jar | \---com &#43;---company | Service.class | But this is mainly for a standalone deployment scenario.
embedded in .war Most of time, we embed our service into our web application and the service implementation will reuse the application logic.
In embedded mode, we needn&amp;rsquo;t package as a .aar. Just a directory in WEB-INF/services is OK.
\---book | pom.xml | README | \---src &#43;---main | | log4j.properties | | | \---samples | \---demo | Book.java | BookService.java | &#43;---test \---webapp \---WEB-INF | web.xml \----conf | axis2.xml | \---services \---BookService \---META-INF services.xml</content>
    </entry>
    
     <entry>
        <title>IBM Integration Bus</title>
        <url>http://yangchao.me/post/ibm-integration-bus/</url>
        <categories>
          <category>ESB</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html"> </content>
    </entry>
    
     <entry>
        <title>Apache Camel</title>
        <url>http://yangchao.me/post/apache-camel/</url>
        <categories>
          <category>EIP frameworks</category>
        </categories>
        <tags>
          <tag>TODO</tag>
        </tags>
        <content type="html">  Core concepts Endpoint it refers to an address or a software entity that supports communication.
Component _it _is confusing terminology; EndpointFactory would have been more appropriate because a Component is a factory for creating Endpoint instances.
A component has a name, which is the prefix of the URI.
CamelContext the Camel runtime system. You typically have one CamelContext object in an application.
CamelTemplate It&amp;rsquo;s previously called CamelClient. It can send a Message or Exchange to an endpoint.
Message and Exchange Message - an abstraction of a single message: request, reply or exception message
Exchange - an abstraction for an exchange of messages, that is, a request message and its corresponding reply or exception message.
in message: request
out message: reply
fault message: expecption
Processor In camel library, there are many processors to implement the design patterns in EIP book.
An application-level developer might implement the Processor interface with a class that executes some business logic.
Routes, RouteBuilders and Java DSL &amp;nbsp;
&amp;nbsp;
</content>
    </entry>
    
     <entry>
        <title>To find a job is a full time job 羊生煎之羊村求职攻略(ICT向)</title>
        <url>http://yangchao.me/post/find-job-full-time-job-e7-be-8a-e7-94-9f-e7-85-8e-e4-b9-8b-e7-be-8a-e6-9d-91-e6-b1-82-e8-81-8c-e6-94-bb-e7-95-a5ict-e5-90-91/</url>
        <categories>
          <category>Uncategorized</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html">  To find a job is a full time job &amp;ndash; Dog Lead 狗说，羊村生活艰辛。 感谢某牛(bian)逼(tai)群主伟大光荣正确的羊村捕鱼舵手－鹅哥。感谢星爷赐题。 感谢某牛(bian)逼(tai)群和某群闲人和闲小动植物。 大家好，我是狗，黑尾狗。落地羊村一年出头儿，一直总想写一篇求职攻略，希望能把期间自己经历过的，小伙伴经历过的小小总结一下给新落地的朋友做参考。不过由于拖延症＋懒癌一起发作，从拿到offer开始工作到现在才开始动笔，不过晚了总比没有强。又到了一年一度的斯巴达，希望能拜个晚年。
没准有看官说了，滚犊子，ICT还要毛儿攻略，羊村都铺好了红地毯夹道欢迎你们呢。这就是您刘大哥讲话啊理太偏，您可能只见2周火速出台的C奶没见3，5个月还没有offer的劳苦小动物。总之我个人见过太多走了不少弯路的小动物，所以大家有需求的就凑合着看看，没需求的看个热闹儿或者赶紧关了千万别骂街。
Disclaimer:我如下所说的都是扯犊子，读后之后造成任何后果概不负责。 羊生煎之羊村求职攻略(ICT向) 远离华人老板 虽然我自己也是华人，并且还把这个弄到了头一个难免有黑同胞之嫌，但是华人老板有可能对有一位求职者造成毁灭性打击所以还是先把坏人做了。我自己没有经历过华人老板没啥发言权，不过道听途说了一些狗血案例大家还是谨慎为上。一般情况一个操蛋的华人老板(同理适用于三哥和其他老板)会给人造成如下的负面影响。 ** 浪费签证时间** 比如先工作多久之后才支持你申请移民云云。对于签证时间有限制的同学(刚登陆的SFV和WHV都有限制)，羊村这里一个完整的招人流程走一个月玩儿似的，所以每一个月都是十分珍贵，大好时光拖拖签证就快到期了，并且某些老板用人跟用牲口似的完全从体力上杜绝你跳槽的可能。当然也有强悍的同学被锻炼成了铁骨铮铮的汉子，但是前提是意志十分坚定。
** 自信心受损** 某些人坚信想不花钱留住一个人的最好办法是洗脑，让你坚信自己水平不行别的地儿不可能有人收留你，这个实际上是最恶心的一点。听不少小伙伴说老板经常灌输“你这水平只有我能收留你”，“你出去肯定找不到工作”，“你没本地工作经验谁给你Offer”，“奥大毕业生都找不到工作”云云，凡事儿说多了就成了真理了，本来空降兵降到羊群里就是底气不足，这么一来更泄气了，漏气的气球想补起来远比扎漏麻烦的多。 三观崩塌 凡事能走到羊村的都会怀着点儿美好生活的憧憬，老婆孩子热炕头儿，一个操蛋老板会让这一切变成噩梦。当然也有人经过磨练更坚强了，这么一想某群的新人欢迎大礼包对于锻炼意志是这么的重要还是有点小兴奋的呢。 怎么写CV 事实上任何一个中介或者雇主，在约候选人面试之前唯一了解候选人的途径就是简历，虽然电话可能简单聊一聊，但是也是看完简历才决定深入接触的。所以投了简历接不到电话问题十有八九就在简历上了。据不靠谱数据统计，一份失败简历的生命周期，在中介和雇主那里面是十分短暂的，可以论分或者秒计算。这就要求想shortlisted就得必须足够吸引人。那么怎么写一份自己看起来都脸红的简历呢？ 排版和格式 排版和格式上至少看起来像个靠谱的专业人士。去面试大伙儿都知道穿的整整齐齐的还有不少开发者都细心的想起来打条领带。简历也一样，至少第一眼看起来要养眼，这个需要一点儿排版的基础和一点点审美能力。刚上大学有门课貌似专门讲这个，没记错的话叫计算机文化基础。计算机文化基础忘了也没关系，羊村图书馆一般都有CVCL写作参考书区，里面的格式都很主流，再不行还有个career govt的website里面也有模板。写好简历记得打印出来一份，然后自己装成中介看一下自己简历，是满意还是该撕掉。一般都得改几版。另外一点，简历根据不同国家文化不同也是不同。见过很多简历只是拿了一套羊村的模版套了一下翻译过来的中文简历，读起来异常的亲切。
背景和技能 基本上每个招聘广告都会写上详细Title，当然也有鸡贼如我厂看人议价给Title的。Title不外乎初中高三等，不同的Title具体JD也有有一些差异，当然也有一些鸡贼厂用Senior JD招Intermediate。所以大家想投特定的级别的时候记得自己的CV要和那个level的essential skill match。
Junior 事实上空降初级的找工作面临的挑战会比中高级大得多，因为很多时候招初级的不如直接招奥大毕业生，羊村几所名校的B&#43;的Graduate真所谓是勤劳勇敢善良能歌善舞new bee分分钟钟tree的vividl，这一点连我们永远正确的伟大羊村舵手鹅哥都吃过亏一怒之下抓了4吨鱼，所以很不幸的消息是经验不丰富的同学，可能会直接和本地的初级竞争，这样难度会加大几个数量级。大家好运。
Intermediate 招中级的得直接能干活儿，实际上任何一个Team里的中坚力量都是Intermediate，所以要求Intermediate上手能力要强，所以CV里面skill matrix要花哨，各种技能各种技术随便砸。Intermediate的市场需求一直比较火爆，很多号称要Senior的可能常年招不到Senior有时候也会招个high intermediate顶一顶老板娘啥的。$ U6 
Senior 招高级的一般是招的是个坑爹的各种擦屁股的，血泪的教训是大家差不多能做lead就做lead屁股就有人给擦了。Senior不光要求技术过硬(技术不过硬多看几十本技术书籍的目录也能假装硬一下)，另外更着重的是推动整个Team的能力，收拾各种烂摊子的能力，管理各种stakeholder的能力，上挑老板下欺member，所以CV里面各种硬技能不能少，软技能要和硬技能一样重要，并且mentoring是个must
第一页 我个人也看过好多份简历，从国内到羊村都有。第一页能抓住人的话会翻看第二页，第一页看起来很难过的直接碎了。羊村我厂连碎纸机都没有，很诡异的是个铁链子锁的大桶号称secure碎纸，看起来觉得好不靠谱呢，好吧随时随地都跑题。第一页的空间很宝贵，对于ICT来讲一个skill matrix是比较闪狗眼的，并且也方便中介和雇主在里面划词，步步高点读机哪里不会点哪里。这样的话加上一小段个人介绍（大概是三个整句子的吹牛逼），再加上个通信地址和软技能啥的第一页基本上就没地方了。个人介绍部分有一点比较容易露馅儿，我有见过好些小动物三句话用了4个I，读起来就联想起一个磕巴，充分的暴露了很不靠谱的写作能力。&amp;ldquo;  工作经历 工作经验妥儿妥儿是简历里面块头儿最大的部分，简历要是盘儿烤鱼工作经历就是鱼其他部分顶多算香菜。随便搜搜seek上面基本上都会要求有经验，其实不要说ICT这类高技术工种，就连商业清洁都会有相关经验的要求。随便看个JD里面写着要什么什么经验就在这儿了。这里可能占1-2页不等，虽然篇幅不少但是每一块儿也是十分珍贵。一个完整的工作经历，包含厂名，职称，时间段，然后和个人职责和成就，以及可选的应用过的技能列表。
公司介绍 如果你是个国际大厂那么恭喜你不用写这个。如果你是个不知名的厂子记得别写太多，雇主要雇的是你不是你公司。所以一般一句就够，比如中国区某某方案领先提供商，或者某某大厂某业务指定合作伙伴云云体现出行业和Leading就行。关于这个Leading大家可以放心大胆的加，是个厂就可以是Leading。另外网站啥的就不用放了，一般这边打印出来点也没法点。并且有的同学放的网站点进去就是个404，或和是个排版很坑爹的全中文老大一个English点完了各种Chinglish，槽都吐不动了。
个人职责 这个主要写你干了什么活儿，怎么干的。招人来就是干活儿的所以这个部分十分重要，潜在老板可以根据这个评估你的潜在角色。羊村这边基本上都是十分喜爱全neng神，还有个坑爹叫法叫Full Stack Engineer，所以候选人的技能越多越好。这个原因也很简单，羊村普遍厂子小，即使大厂子也是很多小Team。加上羊们放荡不羁爱自由经常来一场说走就走的旅行一窜就是一个月，多招几个能随时擦屁股的大拿明显能确保厂子更加正常的运转。 这部分因为重要，所以要写的牛逼。
第一，用词要牛逼，这里面出现一个I你就败了，每一句的开头一定要用能体现主观能动性的硬词儿过去时，比如Initiated，Designed，Introduced，Analysed云云，硬词儿不够怎么办，去翻NKCS的讲义，后面有个词汇表专门列出了一堆可以用的硬词儿
第二，句子要足够长，足够工整，足够有料，职责覆盖面要光显示出自己各种可能性，临时随便可以装任何一个相关角色。句子那个可以去图书馆翻书，抄整句替换关键字，写作技能不牛逼的就尽量少试图自己写句子。至于职责覆盖面，这个比较简单，看一下常见的Team结构，Scan一下一些直接的Stakeholder，然后重点写自己主要角色的活儿，然后别忘了回忆一下其他Team成员的活儿，以及和直接Stakeholder相关的活儿筛选一下，挑几个硬实的写在上面。
第三，长句子中可以掺杂少量的短句子，这样更可以凸显长句子里面你的牛逼职责。切记建立里面Highlight最好用这种手法，不要随便就加粗斜体，那样再一次暴露了坑爹的写作技能。
主要成就 主要写你多牛逼。理论上，职责的部分可以算成你的必备素质，你是干那个的那些你做到是理所当然。而成就这玩意就像是赠品，回想一下任何一个人买东西的时候想要的几个，质量好，价格低。质量就是职责那些，价格是招个人的成本，啥，你还有赠品？牛逼的赠品？那就是你了。成就基本上和牛逼的赠品一样打动人，所以什么算是成就，怎么写成就呢？ 大家写简历最重要的一点是自己不要心虚，不要脸红，实际上任何一件事儿都可能算作你的成就。不过赠品也有好有坏，所以成就也有一些瓷实的，包括但不限于以下几点：
引入了什么牛逼的工具，手法 Git啥的，Agile啥的，配对啥的，随便啥的都可以写。其余的小众的也可以。脑洞不开的去放狗搜一下software development tools and methodology给自己提个醒儿。
解决了什么牛逼的问题 牛逼问题总是有的，你要是感觉自己没解决过牛逼的问题时候，随便找本儿书，比如翔哥撰写的《xxx从入门到精通》，翻看一下目录(千万别看内容，这种标题的书都是垃圾)，看最后几章Advanced部分都在讲什么，然后回想一下，那些Advanced的虫子抓过没，抓过就写上，没抓过就编一个。 另外，Performance tuning屡试不爽，JVM，Database都可以随便往上弄。
改善了什么流程 流程改进永远是ICT厂的吹牛逼固定话题，因为普遍来讲ICT厂的员工比较懒惰，宁可扎堆儿打咖啡也不去修个高优先级的BUG。当然也有劳模这种诡异生物的存在，但是好在每个Team劳模并不多，避免了ICT厂妹厂弟沦为Labor工。流程的存在是为了让一堆懒人干最少的活儿达到最大收益。所以做减法永远是受欢迎的，当然为了控制质量必要的做加法基本上每个厂子都在搞，搞的大家口是心非明面儿上说It works暗地里怨声载道。所以加加减减都可以往上写，另外，还有一点是成效，这时候一点儿数字就很醒目了，比如引入什么流程使Defect降低12%，去除了什么流程使Cost节省了28%云云，至于具体数儿怎么算的，问PM啊。如果你是个PM，那肯定瞎话儿张嘴就来这个估计不用我教(星爷莫怒)。
关键项目 这个实际上是可选的。因为一个人在一个厂几年，可能做了N个项目，但是这N个项目正常情况下可能有80%的部分相似而只有20%的部分不同。这个80-20是在Role上和Stakeholder的关系之间，也就是个人职责上面评估得来的。所以如果一个经验丰富的人士编年史一样的写Project，会有大量重复内容导致没人读得下去。那么什么时候需要写这个Key project呢？一种情况是，真的有个十分牛逼的项目值得你去单独提一下，这项目你做的相当璀璨闪瞎了一堆stakeholder的狗眼那么你就完全可以单独拿出来大吹特吹。另一种情况是Junior的可能经验不够丰富，没什么可写的，这时候可以单独列几个关键项目吹吹牛逼。这一段实际上是从某个求职教程里面抄来的，那个教程里面讲编年史的CV的适用对象是毕业生。所以经验人士慎用。
写作技巧 见过有些小动物在CV后面的Qualification部分写上英语雅思几分的，深感这个略坑。实际上英语不用写雅思几分，看看简历打一个电话立马知道啥水准。写作技能一般都是空降兵的短板儿，所以简历上一定要注意避免暴露自己比较坑爹的写作功底。这就需要旁征博引，图书馆里面写简历的书一群一群的，也可见了羊村写简历是件是件十分重要的事儿，尽量去书里面抄整个句子然后替换掉自己的关键字。这样会比自己翻译的地道的多。
测试和迭代 找工作是个项目。启动，规划，执行，监控和收尾任何一个环节不可或缺，启动项目订机票来羊村租房子然后落水焚香宣纸文房四宝写个Hello World！定定心神，再然后规划写简历投简历失败去洗盘子，这项目就是妥儿妥儿呲了。由于个人找工作从工时和budget上看都是小型项目，所以很多人忽视了这是件麻雀虽小五脏俱全的事儿，直接导致了没有规划直接上来拿简历就投之后也没有改善的环节最终去弄的一团糟然后无奈去炸薯条儿。当然有人说了我是Agile你PMP的不共戴天赶紧滚犊子，但是Agile也得plan一下至少plan一个sprint哦亲。其实在整个找工作这个项目过程中无时无刻不在PDCA。做好计划写简历，然后出了成品当然要小规模测试一下了，Alpha版的投的满大街beta版的直接就进垃圾桶了，最后整不好还得换手机换邮箱发一GA本。简历需要测试，每出一个版本小范围投出去看看中介或者雇主的反应就会大体知道自己简历是不是够硬了，然后在改进，再测试，最后GA release投给最想去的厂。有兴趣的可以自己git一下看看改多少版才出个GA release。
求职信 事实上很多时候求职信比简历还要重要一些，因为貌似看完一篇满目疮痍的求职信直接默默的删了简历的也大有人在。事实上如果换成我自己一封求职信看不下去的话，简历基本上也不会打起兴趣看，毕竟上班那么的煎熬，干点儿啥不好。 求职信是一封信 求职信真是个letter，写的是信的格式。话说在打印机没普及之前手写的CL和CV写的漂亮的很加分，所以没准儿之前写字儿难看的就会找人代写简历，估计现在的代谢简历的都是他们的后人。在电子邮件没有的时候是貌似是用post mail邮寄CV和CL。现在一般都是电子邮件，所以CL可以当邮件正文发送，简单明了即可。CL实际上是从CV里面精炼出来的能让招聘的人找到点的一个超浓缩版本，一般几个要素，我是谁，我写信干啥，我多牛逼，怎么联系我，谢谢。模版满大街，词汇也比较单一，所以套路一般以简单粗暴为主流。
我是谁 同CV，出一堆I的直接掉链子，随便找个模板去抄。这里面有个没啥大意义的小trick，如果您经验丰富可以明晃晃的写上比如8年经验，年数用数字十分醒目，不太丰富就写三年经验可以简单隐藏一下。然后剩下的大同小异，一般三两句话就行少磨叽。  我写信干啥 一般中介和雇主都比较在意简历的来源。因为这个涉及到招聘预算怎么花的。比如他在seek上和trademe上都list了他当然想知道哪个来源的简历多质量好。所以写信干啥的时候一般都会说我在哪儿看见了你的广告，然后我觉得我合适。trademe和seek上貌似都提供了简历直投的功能，但是那个我个人感觉不好用，不方便管理简历，也不好跟踪。所以只要是中介留电话邮箱姓名的最好直接一个CL当正文cei过去，CV做附件，即使中介或者雇主对你没啥兴趣出于礼貌也可能骗来封回信。 我多牛逼 最主要的部分是我多牛逼的部分，因为其他部分。由于模版实在是好用，所以。。。都长得差不多。我多牛逼部分可以写8-10个bullet，可以发指的和JD相对应，中介一般不懂技术，但是很擅长查字典和打麻将(话说羊的麻将都是当连连看玩儿的)。有人问了，发指的对应，会不会有点假。这一点可以保证不用担心，玩儿连连看的忽然有俩对不上的会很闹心的，尤其是xx座的。另外关于JD多说几句，其实无论是中介还是雇主，招聘广告由于版面的限制都很少发full jd。大家seek上看到的JD都是精简到不能再精简的，所以基本上就是must。至于full jd，1页到1x页的不等。大家中介聊过了之后记得要full jd然后好准备tree new bee。
怎么联系我 CL末尾直接写上手机号，一般可以写我随时方便和你讨论相关细节，你可以打xxxxxx联系我，不要写在签名档，那样会显得很随意。这个是很给力的小细节。有过一次只发了CL忘记贴CV然后中介迅速电话过来要CV十分高效。
另外CL直接暴露候选人的沟通能力。如果你写你有十分牛逼的communication skills然后配上两页不知所云的CL，结果基本上就是直接默默的关了。所以少啰嗦，只提供重要的信息。尽可能暴露出瓷实的细节。
投简历 写好了简历和求职信粮好了就可以下锅了。首选的途径当然是。。。。内推啦。但是投之前记得先定制一下简历。7 o9 f6 K5 A4 X  简历定制  投简历之前一定要根据相关的JD定制一下。比如CL和CV立面关键字一定要发指的match，位置要亮瞎狗眼，然后猜一下相关行业，行业经验也打磨一下。这时候有两种情况，一种是你对要投的厂子很熟甚至有内奸帮你内推，那简历就好写了，有问题找内奸。另一种是中介发的鼠儿尾巴那么长的JD，这种比较坑，全靠蒙，人品好可以从客户简介里面提取大量信息，人品不好提取的信息都呲了的话就删号儿重练吧。 内推 内推对厂子来讲是一举两得，不光可以节约中介费，内推一般都是朋友介绍，所以来人也是知根知底儿。内推的途径是内部员工发应聘者简历直接到招聘人员手里。羊村的大中型ICT厂基本上都有自己的招聘部门一般叫recruitment team，注意一点他们和HR team的职能是不同的，他们只负责筛简历，约面试，大刀砍羊，做合同然后拉你上贼船之后交给HR team。小厂可能人事招聘攒一起了几个全neng神。对于找工作的人的话内推也是十分简单有效因为有内奸可以暴露一些从中介手中拿不到的信息比如某些技术细节，中介只知道个关键字，随便一个关键字都能出N本书儿的。话说招聘广告里JD越短的CV越难写有木有，这时候有个内奸绝对是久旱逢甘雨。况且不想当反贼的忠臣不是好内奸，谁都想试探一下自己厂子到底能给多少羊。
中介  NKCS说羊村80%的厂子都是20人以下，这就决定了某些厂子不需要几个人也就不需要找专人做招聘，这样当当当当无处不在的中介就登场了。一般常见的中介有羊和三系，没见过华人。三系普遍约等于不靠谱，但是也不绝对。中介不分大小，有的大中介全球连锁比如黑色，也有小中介就一两个人也能变戏法似的搞来offer。所以中介这玩儿意不骑上你不知道谁是驴谁是马。中介一般都在seek和trademe上发广告，用一些含糊其辞的话描述客户，这时候就要发动network帮猜一下他的客户可能是谁，也能相对靠点儿谱。 中介筛简历就是连连看。你的简历漂亮，你的keyword闪亮，那你就牛逼，不牛逼也牛逼。
网站 网站说的就是Seek和Trademe了。他俩的作用是看招聘广告。可以订阅可以查阅任君选择。但是除非没有别的联系途径，不然尽量不要用他们的简历平台。Seek和Trademe貌似都有自己的投简历的功能，但是个人感觉效果没有直邮好，如果你有中介或者厂子招聘专员的mail的话建议直接mail联系。并且，如果他们想让你通过网站投，那就没必要写自己mailbox了。
维护一个投简历的列表 啥时候投的，投给给谁的，中介的名字，然后一些JD的关键字。写在一张纸上，然后放在醒目的地方。写纸上比放在机器里方便的多，因为中介会默认当你是native没等你给电脑开盖儿就已经介绍完Y是谁了。每次接电话的时候把纸拿起来然后迅速找到打电话的人是谁。第一次没听清的话可以让Y重复一下，保证match一下知己知彼之后的扯犊子会更加活灵活现。
**维护电话本 **来电显示的如果有打过来的电话记得记入电话本。电话本里记上名字，中介的公司，然后在下一次接电话的时候可以抢先打招呼直呼其名how are you。这样你自己沟通也会信心十足，整条狗都胸有成竹。也有一些中介坑爹的隐藏了自己的电话号码只显示是私人号码，这时候就口音识别吧。至少很多口音还是很好分的，羊村口音，三系口音，伦敦郊区腔还有Chinglish。Chinglish是开玩笑因为我个人从来没见过一个华人中介。倒是有个华人CO跟我几次电话之后开始被拐带的各种流利的Chinglish。
剩下就是等消息了。等消息的最好办法就是。。。准备面试，时刻当明天就有雇主面谈人生谈理想谈技术谈各种诡异的东西，这时候你就会发现时间真特么的不够用。要复习的太多了。那么复习啥呢，明天再说。
</content>
    </entry>
    
     <entry>
        <title>ACID and transaction</title>
        <url>http://yangchao.me/post/acid-and-transaction/</url>
        <categories>
          <category>Databases</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html">  Transaction provides data integrity in highly concurrent environments. It&amp;rsquo;s also called Unit of Work.
 For database systems, transaction is a must-have feature. But also some exceptions, like MySQL MyISAM engine. For messaging systems like JMS, transactions are not mandatory which has non-transacted acknowledgement modes. File system operations are usually non-managed, but if your business requirements demand transaction file operations, you might make use a tool such as XADisk.  ACID Inherently a transaction is characterized by four properties (commonly referred as ACID) :
 Atomicity - process Consistency - data state Isolation - across transactions Durability - storage &amp;gt; Atomicity takes individual operations and turns them into an all-or-nothing unit of work, succeeding if and only if all contained operations succeed. &amp;gt; &amp;gt; &amp;gt; Consistency is about the state change. A transaction must always leave the system in a consistent state. &amp;gt; &amp;gt; &amp;gt; Isolation brings us the benefit of hiding uncommitted state changes from the outside world (other transactions), as failing transactions shouldn’t ever corrupt the state of the system.Isolation is achieved through concurrency control using pessimistic or optimistic locking mechanisms. &amp;gt; &amp;gt; &amp;gt; Durability ensure permanently change the state of a system after successful committed transaction, or logging the state changes before commit. Of the four properties, the atomicity is a fixed property, but everything else may be traded-off for performance/scalability reasons.  three phenomena and isolation The SQL standard defines four Isolation levels:
 READ_UNCOMMITTED READ_COMMITTED REPEATABLE_READ SERIALIZABLE   Isolation Level Dirty read Non-repeatable read Phantom read   READ_UNCOMMITTED allowed allowed allowed   READ_COMMITTED prevented allowed allowed   REPEATABLE_READ prevented prevented allowed   SERIALIZABLE prevented prevented prevented    Every isolation level resolves one or multiple phenomena.  Dirty read Transaction 2 reads the uncommitted(temporary or dirty) data of transaction 1. It&amp;rsquo;s called dirty because the change may be discarded if rollback.
Non-repeatable read Transaction 2 commits after transaction 1, so the queried record in memory differs in state (changed) from that in database when commit.
Phantom read  Transaction 2 commits after transaction 1, so the queried records in memory differ in range (more or less) from that in database when commit.
You can regard phantom read is an extensive version of unrepeatable read.
&amp;nbsp;
Even if the SQL standard mandates the use of the SERIALIZABLE isolation level, most database management system use a different default level.   Database Default isolation Level   Oracle READ_COMMITTED   MySQL REPEATABLE_READ   Microsoft SQL Server READ_COMMITTED   PostgreSQL READ_COMMITTED   DB2 CURSOR STABILITY (a.k.a READ_COMMITTED)    Usually, READ_COMMITED is the right choice, since even SERIALIZABLE cannot protect you from a “lost update” where the read/write happen in different transactions (and web requests).
a classic database problem - lost update transactional scenario offline concurrency scenario In this case, we should differentiate the system transaction boundary and business transaction boundary. All the above discussed is about system transaction.
locking and MVCC Two ways for concurrency control:
 MVCC locking But as we all know, locking increases the serializable portion of the executed code, affecting parallelization.  In low level, how the database uses locks or MVCC to control concurrency is very complicated and different from one to another. The explanation is worth explaining in a big book.
Here we consider locking and MVCC in a high level.
(We consider implicit locking is database-specific and ubiquitous when interacting with database using SQL, like read lock, write lock, share lock, mutually exclusive lock, table lock, row lock, range lock, lock escalation etc&amp;hellip;.the list goes, so many buzzwords!)
Basically, we mention locking just in pessimistic locking context, where locking is explicitly requested. This is from the SQL: &amp;gt; select &amp;hellip;. for update/insert/delete And we refer to MVCC mainly for application-level optimistic locking implementation &amp;ndash; version column. Other optimistic locking implementations include:
 old/new value comparison in committing time checksum or hash computation on original data  pessimistic locking optimistic locking &amp;nbsp;
&amp;nbsp;
&amp;nbsp;
&amp;nbsp;
&amp;nbsp;
</content>
    </entry>
    
     <entry>
        <title>JPA - advanced topics</title>
        <url>http://yangchao.me/post/jpa-advanced-topics/</url>
        <categories>
          <category>JPA</category>
        </categories>
        <tags>
          <tag>TODO</tag>
        </tags>
        <content type="html">  locking cache lifecycle callbacks Event &amp;amp; Listener </content>
    </entry>
    
     <entry>
        <title>Struts 2 - a short journey</title>
        <url>http://yangchao.me/post/struts-2-a-short-journey/</url>
        <categories>
          <category>Struts</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html">  Web framework evolves Servlet Write all your processing logic and presentation logic in a servlet class. Generating HTML code from within Java code is really awesome!
JSP with scriptlet style Rather than writing HTML in Java code, now write Java code in HTML code. This approach is really like PHP and ASP do.
JSP with tags style To avoid writing Java code in HTML, introduce JSP tags as HTML-like facade for accessing underlying Java code. This approach is more designer-friendly.
Action-based framework Split the page processing into processing logic and presentation logic.
Implement MVC Model 2 pattern, or Front Controller pattern.
In this pattern, a servlet is the Front Controller, providing a centralized point for all client page requests.
Then it maps the request URL to a Unit of Work (aka. action).
The action can do:
 accessing HTTP request, form and session parameters calling business logic services mapping the response into Model - usually a POJO returning a result, which is mapped to a view for rendering  Component-based framework  event-driven a close tie between user interface component and its class Such frameworks are: JSF, Wicket, ASP.NET  AJAX and Restful style AJAX requesting to an action-based framework makes the action-based framework behave like the component-based frameworks do.
Core components of Struts Struts2 is a pull-MVC (or MVC 2) framework. The &amp;ldquo;pull&amp;rdquo; comes from the views ability to pull data from Action, rather than having a separate model object.
From the above figure, we know Action acts as the functionality of model object and processing logic executor.
Configuration When you develop your web application using Struts2, you&amp;rsquo;ll come across 3 configuration files: web.xml(web application deplopment descriptor), struts.properties, struts.xml
web.xml You need to config Dispatcher Filter &amp;ndash; which is implemented as a servlet filter to dispatching requests.
struts.properties This file is for configuration of framework itself if you want to change the default options of framework. It includes all kinds of constants.
Of course, you can define these constants in struts.xml by using &amp;lt;constant name=&amp;ldquo;&amp;rdquo; value=&amp;ldquo;&amp;rdquo; /&amp;gt;
So struts.properties is optional.
struts.xml This is about the specific configuration of your web application, such as actions, result type, result, interceptors, etc.
Now the following is a practical configuration I used in my project:
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34; ?&amp;gt; &amp;lt;!DOCTYPE struts PUBLIC &amp;#34;-//Apache Software Foundation//DTD Struts Configuration 2.0//EN&amp;#34; &amp;#34;http://struts.apache.org/dtds/struts-2.0.dtd&amp;#34;&amp;gt; &amp;lt;struts&amp;gt; &amp;lt;!-- what the URL ends by, such as ***.do --&amp;gt; &amp;lt;constant name=&amp;#34;struts.action.extension&amp;#34; value=&amp;#34;do&amp;#34; /&amp;gt; &amp;lt;!-- in development mode, more errors are provided --&amp;gt; &amp;lt;constant name=&amp;#34;struts.devMode&amp;#34; value=&amp;#34;false&amp;#34; /&amp;gt; &amp;lt;!--default encoding for web app--&amp;gt; &amp;lt;constant name=&amp;#34;struts.i18n.encoding&amp;#34; value=&amp;#34;utf-8&amp;#34; /&amp;gt; &amp;lt;constant name=&amp;#34;struts.i18n.reload&amp;#34; value=&amp;#34;false&amp;#34; /&amp;gt; &amp;lt;constant name=&amp;#34;struts.custom.i18n.resources&amp;#34; value=&amp;#34;properties/web/lang&amp;#34; /&amp;gt; &amp;lt;constant name=&amp;#34;struts.configuration.xml.reload&amp;#34; value=&amp;#34;true&amp;#34; /&amp;gt; &amp;lt;constant name=&amp;#34;struts.objectFactory&amp;#34; value=&amp;#34;org.apache.struts2.spring.StrutsSpringObjectFactory&amp;#34; /&amp;gt; &amp;lt;!-- default package --&amp;gt; &amp;lt;package name=&amp;#34;my-default&amp;#34; namespace=&amp;#34;/&amp;#34; extends=&amp;#34;json-default&amp;#34;&amp;gt; &amp;lt;!-- define new interceptors and interceptor stack --&amp;gt; &amp;lt;interceptors&amp;gt; &amp;lt;interceptor name=&amp;#34;myInterceptor&amp;#34; class=&amp;#34;com.my.web.interceptor.SecurityInterceptor&amp;#34;/&amp;gt; &amp;lt;interceptor-stack name=&amp;#34;myDefaultStack&amp;#34;&amp;gt; &amp;lt;interceptor-ref name=&amp;#34;defaultStack&amp;#34; /&amp;gt; &amp;lt;interceptor-ref name=&amp;#34;myInterceptor&amp;#34; /&amp;gt; &amp;lt;interceptor-ref name =&amp;#34;timer&amp;#34; /&amp;gt; &amp;lt;interceptor-ref name =&amp;#34;logger&amp;#34; /&amp;gt; &amp;lt;/interceptor-stack&amp;gt;	&amp;lt;/interceptors&amp;gt; &amp;lt;!-- set default interceptor --&amp;gt; &amp;lt;default-interceptor-ref name=&amp;#34;myDefaultStack&amp;#34;/&amp;gt; &amp;lt;!-- Global results：error, failure, timeout, relogin --&amp;gt; &amp;lt;global-results&amp;gt; &amp;lt;result name=&amp;#34;success&amp;#34; type=&amp;#34;json&amp;#34;&amp;gt; &amp;lt;param name=&amp;#34;ignoreHierarchy&amp;#34;&amp;gt;false&amp;lt;/param&amp;gt; &amp;lt;param name=&amp;#34;excludeNullProperties&amp;#34;&amp;gt;false&amp;lt;/param&amp;gt; &amp;lt;/result&amp;gt; &amp;lt;result name=&amp;#34;exception&amp;#34; type=&amp;#34;json&amp;#34;&amp;gt; &amp;lt;param name=&amp;#34;ignoreHierarchy&amp;#34;&amp;gt;false&amp;lt;/param&amp;gt; &amp;lt;param name=&amp;#34;excludeNullProperties&amp;#34;&amp;gt;false&amp;lt;/param&amp;gt; &amp;lt;/result&amp;gt; &amp;lt;result name=&amp;#34;login&amp;#34; type=&amp;#34;json&amp;#34;&amp;gt; &amp;lt;param name=&amp;#34;ignoreHierarchy&amp;#34;&amp;gt;false&amp;lt;/param&amp;gt; &amp;lt;param name=&amp;#34;excludeNullProperties&amp;#34;&amp;gt;false&amp;lt;/param&amp;gt; &amp;lt;/result&amp;gt; &amp;lt;/global-results&amp;gt; &amp;lt;/package&amp;gt; &amp;lt;!-- modules --&amp;gt; &amp;lt;include file=&amp;#34;Struts/struts-alert.xml&amp;#34;/&amp;gt; &amp;lt;include file=&amp;#34;Struts/struts-systemManage.xml&amp;#34;/&amp;gt; &amp;lt;include file=&amp;#34;Struts/struts-workflow.xml&amp;#34;/&amp;gt; &amp;lt;include file=&amp;#34;Struts/struts-revaluation.xml&amp;#34;/&amp;gt; &amp;lt;include file=&amp;#34;Struts/struts-indexquery.xml&amp;#34;/&amp;gt; &amp;lt;/struts&amp;gt; &amp;nbsp;
&amp;nbsp;
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;web-app version=&amp;#34;2.4&amp;#34; xmlns=&amp;#34;http://java.sun.com/xml/ns/j2ee&amp;#34;xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34;xsi:schemaLocation=&amp;#34;http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd&amp;#34;&amp;gt; &amp;lt;display-name&amp;gt;icms-web&amp;lt;/display-name&amp;gt; &amp;lt;context-param&amp;gt; &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt; &amp;lt;param-value&amp;gt;classpath*:/SpringContext/applicationContext-*.xml,classpath*:/SpringContext/*/applicationContext-*.xml,classpath*:/SpringContext/*/*/applicationContext-*.xml,classpath*:/SpringContext/*/*/*/applicationContext-*.xml &amp;lt;/param-value&amp;gt; &amp;lt;/context-param&amp;gt; &amp;lt;listener&amp;gt; &amp;lt;listener-class&amp;gt;org.springframework.web.util.Log4jConfigListener&amp;lt;/listener-class&amp;gt; &amp;lt;/listener&amp;gt; &amp;lt;listener&amp;gt; &amp;lt;listener-class&amp;gt;org.springframework.web.context.ContextLoaderListener&amp;lt;/listener-class&amp;gt; &amp;lt;/listener&amp;gt; &amp;lt;filter&amp;gt; &amp;lt;filter-name&amp;gt;struts2&amp;lt;/filter-name&amp;gt; &amp;lt;filter-class&amp;gt;org.apache.struts2.dispatcher.FilterDispatcher&amp;lt;/filter-class&amp;gt; &amp;lt;init-param&amp;gt; &amp;lt;param-name&amp;gt;config&amp;lt;/param-name&amp;gt; &amp;lt;param-value&amp;gt;struts-default.xml,struts-plugin.xml,Struts/struts.xml&amp;lt;/param-value&amp;gt; &amp;lt;/init-param&amp;gt; &amp;lt;/filter&amp;gt; &amp;lt;filter-mapping&amp;gt; &amp;lt;filter-name&amp;gt;struts2&amp;lt;/filter-name&amp;gt; &amp;lt;url-pattern&amp;gt;*.do&amp;lt;/url-pattern&amp;gt; &amp;lt;/filter-mapping&amp;gt; &amp;lt;welcome-file-list&amp;gt; &amp;lt;welcome-file&amp;gt;index.htm&amp;lt;/welcome-file&amp;gt; &amp;lt;/welcome-file-list&amp;gt; &amp;lt;session-config&amp;gt; &amp;lt;session-timeout&amp;gt;30&amp;lt;/session-timeout&amp;gt; &amp;lt;/session-config&amp;gt; &amp;lt;/web-app&amp;gt; Actions If you don&amp;rsquo;t specify the method of an action, its execute() will be invoked by default.
An action method can return a String or _Result _or no return.
&amp;lt;action name=&amp;#34;submitDiscardColAppAction&amp;#34; class=&amp;#34;com.my.ManageDiscardColAction&amp;#34; method=&amp;#34;submitDiscardColApp&amp;#34;&amp;gt; &amp;lt;/action&amp;gt; An action instance should be one per request. So when you integrate Struts2 with Spring, the bean scope of action should be sterotype.
The above example uses the global result setting. You can specify the action-specific configs of result mapping, like
&amp;lt;action name=&amp;#34;submitDiscardColAppAction&amp;#34; class=&amp;#34;com.my.ManageDiscardColAction&amp;#34; method=&amp;#34;submitDiscardColApp&amp;#34;&amp;gt; &amp;lt;result name=&amp;#34;success&amp;#34; type=&amp;#34;dispatcher&amp;#34;&amp;gt;1.jsp&amp;lt;/result&amp;gt; &amp;lt;/action&amp;gt;  NOTE: the &amp;ldquo;dispatcher&amp;rdquo; result type is default if you don&amp;rsquo;t specify the result type. Most of time, the logic service object is injected by DI framework (Struts only support setter injection), but there are many non-managed objects needing to acquire in the action, like request, session, servletContext, response, etc. In this case, we can use **Aware interface.
  SessionAware ServletRequestAware RequestAware ApplicationAware ServletResponseAware ParameterAware PrincipalAware ServletContextAware  Result type Struts provides many result type, but you can implement your custom implementation by implements _Result _interface.
 dispatcher httpheader redirect redirectAction plainText stream velocity  Interceptors Interceptors are conceptually the same as servlet filters or proxy, which provide a way to supply pro-processing and post-processing around the action.
Many features in Struts are implemented using interceptors: exception handling, lifecycle callbacks, validation, servlet-based object injection, application authentication etc.
public interface Interceptor extends Serializable { void destroy(); void init(); String intercept(ActionInvocation invocation) throws Exception; } Value Stack / OGNL Value stack and OGNL are all related to accessing data. OGNL is an expression language, aka. Object Graphic Navigational Language.
We use OGNL to access data from value stack in some cases:
 JSP tags Velocity or Freemarker template  What are there in Value stack? Tags &amp;lt;s:property&amp;gt; This tag is used to access value stack value.
 escape html or javascript  &amp;lt;s:property value=&amp;#34;propWithHtml&amp;#34; escape=&amp;#34;false&amp;#34;/&amp;gt;&amp;lt;script type=&amp;#34;text/javascript&amp;#34;&amp;gt; var jsFromTag1 = &amp;#39;&amp;lt;s:property value=&amp;#34;javascriptExample&amp;#34; escapeJavaScript=&amp;#34;true&amp;#34;/&amp;gt;&amp;#39;; document.writeln(jsFromTag1); &amp;lt;/script&amp;gt;  default value  &amp;lt;s:property value=&amp;#34;nullExample&amp;#34; default=&amp;#34;A default value.&amp;#34;/&amp;gt;  access scope object: request, session, application with prefix #  &amp;lt;s:property value=&amp;#34;#application.anAppAttribute&amp;#34;/&amp;gt; &amp;lt;s:property value=&amp;#34;#session.aSessionAttribute&amp;#34;/&amp;gt; &amp;lt;s:property value=&amp;#34;#request.aRequestAttribute&amp;#34;/&amp;gt; &amp;lt;s:property value=&amp;#34;#parameters.aRequestParameter&amp;#34;/&amp;gt; parameters is for request parameters
No page object, but instead you use #attr to search all the attributes of application, request, session and page in order.
&amp;lt;s:property value=&amp;#34;#attr.anAppAttribute&amp;#34;/&amp;gt; &amp;lt;s:property value=&amp;#34;#attr.aSessionAttribute&amp;#34;/&amp;gt; &amp;lt;s:property value=&amp;#34;#attr.aRequestAttribute&amp;#34;/&amp;gt; &amp;lt;s:property value=&amp;#34;#attr.aPageAttribute&amp;#34;/&amp;gt; &amp;amp;lt;s:debug&amp;amp;gt; show all the stack
${anActionProperty} This will search the value stack first, then fall off to use the JSP EL lookup. This is a little tricky.
&amp;lt;s:set&amp;gt; &amp;amp;lt;s:if&amp;amp;gt;, &amp;amp;lt;s:elseif&amp;amp;gt;, and&amp;amp;lt;s:else&amp;amp;gt; &amp;lt;s:if test=&amp;#34;aBooleanExpression&amp;#34;&amp;gt; Printed when test is true. &amp;lt;/s:if&amp;gt; &amp;lt;s:elseif test=&amp;#34;aDifferentBooleanExpression&amp;#34;&amp;gt; &amp;lt;sif&amp;gt; tagPrinted if previous test was false and this one is true. &amp;lt;selseif&amp;gt; tag&amp;lt;/s:elseif&amp;gt; &amp;lt;s:else&amp;gt; Printed if neither were true. &amp;lt;selse&amp;gt; tag&amp;lt;/s:else&amp;gt; &amp;lt;s:iterator&amp;gt; &amp;lt;s:iterator value=&amp;#34;listOfStrings&amp;#34;&amp;gt; &amp;lt;li&amp;gt;&amp;lt;s:property/&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;/s:iterator&amp;gt;&amp;lt;s:iterator value=&amp;#34;listOfStrings&amp;#34; var=&amp;#34;anItem&amp;#34;&amp;gt; &amp;lt;li&amp;gt;&amp;lt;s:property value=&amp;#34;anItem&amp;#34;/&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;/s:iterator&amp;gt;&amp;lt;s:iterator value=&amp;#34;mapStringString&amp;#34;&amp;gt; &amp;lt;li&amp;gt; &amp;lt;s:property value=&amp;#34;key&amp;#34;/&amp;gt; : &amp;lt;s:property value=&amp;#34;value&amp;#34;/&amp;gt; &amp;lt;/li&amp;gt; &amp;lt;/s:iterator&amp;gt;&amp;lt;s:iterator value=&amp;#34;mapStringString&amp;#34; var=&amp;#34;entry&amp;#34;&amp;gt; &amp;lt;li&amp;gt; &amp;lt;s:property value=&amp;#34;#entry.key&amp;#34;/&amp;gt; == &amp;lt;s:property value=&amp;#34;#entry.value&amp;#34;/&amp;gt; &amp;lt;/li&amp;gt; &amp;lt;/s:iterator&amp;gt;&amp;lt;s:iterator value=&amp;#34;list1&amp;#34; status=&amp;#34;stat&amp;#34;&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td&amp;gt;&amp;lt;s:property value=&amp;#34;#stat.index&amp;#34;/&amp;gt;&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;&amp;lt;s:property value=&amp;#34;#stat.count&amp;#34;/&amp;gt;&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;&amp;lt;s:property value=&amp;#34;#stat.even&amp;#34;/&amp;gt;&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;&amp;lt;s:property value=&amp;#34;#stat.odd&amp;#34;/&amp;gt;&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;&amp;lt;s:property value=&amp;#34;#stat.first&amp;#34;/&amp;gt;&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;&amp;lt;s:property value=&amp;#34;#stat.last&amp;#34;/&amp;gt;&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;&amp;lt;s:property value=&amp;#34;#stat.modulus(2)&amp;#34;/&amp;gt;&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;&amp;lt;s:property value=&amp;#34;#stat.modulus(4)&amp;#34;/&amp;gt;&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;&amp;lt;s:property value=&amp;#34;#stat.count % 4&amp;#34;/&amp;gt;&amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;/s:iterator&amp;gt; &amp;lt;s:include&amp;gt; similar to &amp;lt;jsp:include&amp;gt;
&amp;lt;s:action&amp;gt; &amp;lt;s:action name=&amp;#34;includedAction&amp;#34;/&amp;gt; &amp;lt;s:url&amp;gt; dynamically generate the url mapped to the action
Form Validation and Type conversion //TODO
&amp;nbsp;
</content>
    </entry>
    
     <entry>
        <title>Spring framework - transaction management</title>
        <url>http://yangchao.me/post/spring-framework-transaction-management/</url>
        <categories>
          <category>Spring</category><category>Transaction Management</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html">  In Java, there are multiple persistence APIs and all of them provides their own ways of transaction management.
 JDBC transaction: this is a resource-specific transaction, which is implemented by connection. JTA transaction: this is a transaction API for global transaction, it usually needs the support of application server. JPA transaction: JPA has its own transaction API by EntityManager. Hibernate transaction: Hibernate also provides its way to manage transaction by SessionFactory JDO: &amp;hellip; Now Spring transaction management abstracts and unifies all these API.  Infrastructure abstraction  TransactionStatus PlatformTransactionManager (SPI) TransactionDefinition
 Isolation Propagation Timeout Read-only Spring implements many built-in transaction manager implements:   transaction manager linked resource   DataSourceTransactionManger JDBC DataSource   JTATransactionManager     |&amp;ndash; WebSphereTransactionManager     |&amp;ndash; WebLogicTransactionManager    HibernateTransactionManager SessionFactory   JPATransactionManager EntityManager      AOP implementation TransactionInterceptor This is the secret for the declarative transaction.
public interface FooService { Foo getFoo(String fooName); Foo getFoo(String fooName, String barName); void insertFoo(Foo foo); void updateFoo(Foo foo); } public class DefaultFooService implements FooService { public Foo getFoo(String fooName) { throw new UnsupportedOperationException(); } public Foo getFoo(String fooName, String barName) { throw new UnsupportedOperationException(); } public void insertFoo(Foo foo) { throw new UnsupportedOperationException(); } public void updateFoo(Foo foo) { throw new UnsupportedOperationException(); } } class Foo { }public static void main(String[] args) { GenericXmlApplicationContext context = new GenericXmlApplicationContext(&amp;#34;classpath:spring-tx.xml&amp;#34;); FooService fooService = (FooService)context.getBean(&amp;#34;fooService&amp;#34;); TransactionInterceptor txAdvice = (TransactionInterceptor)context.getBean(&amp;#34;txAdvice&amp;#34;); fooService.insertFoo(new Foo()); } This is the log4j log which can show some implementation details:
&amp;lt;!-- the DefaultFooService is actually proxied --&amp;gt; DEBUG {org.springframework.aop.aspectj.autoproxy.AspectJAwareAdvisorAutoProxyCreator} - Creating implicit proxy for bean &amp;#39;fooService&amp;#39; with 0 common interceptors and 2 specific interceptors DEBUG {org.springframework.aop.framework.JdkDynamicAopProxy} - Creating JDK dynamic proxy: target source is SingletonTargetSource for target object [tx.DefaultFooService@14f9390f] DEBUG {org.springframework.beans.factory.support.DefaultListableBeanFactory} - Finished creating instance of bean &amp;#39;fooService&amp;#39; &amp;lt;!--=========== Before: the insertFoo(..) method is now being invoked on the proxy ================--&amp;gt; &amp;lt;!-- the transactional advice kicks in here... --&amp;gt; &amp;lt;!-- acquire connection --&amp;gt; DEBUG {org.springframework.jdbc.datasource.DataSourceTransactionManager} - Acquired Connection [jdbc:h2:file:D:/Projects/spring-sample/activejdbc/src/main/resources/test, UserName=, H2 JDBC Driver] for JDBC transaction &amp;lt;!-- disable autocommit --&amp;gt; DEBUG {org.springframework.jdbc.datasource.DataSourceTransactionManager} - Switching JDBC Connection [jdbc:h2:file:D:/Projects/spring-sample/activejdbc/src/main/resources/test, UserName=, H2 JDBC Driver] to manual commit &amp;lt;!-- !!! this is the way: bound resource to the thread --&amp;gt; TRACE {org.springframework.transaction.support.TransactionSynchronizationManager} - Bound value [org.springframework.jdbc.datasource.ConnectionHolder@2101b44a] for key [org.apache.commons.dbcp.BasicDataSource@52d645b1] to thread [main] &amp;lt;!-- initialize transaction synchronization --&amp;gt; TRACE {org.springframework.transaction.support.TransactionSynchronizationManager} - Initializing transaction synchronization TRACE {org.springframework.transaction.interceptor.TransactionInterceptor} - Getting transaction for [tx.DefaultFooService.insertFoo] =================foo() invoked============= &amp;lt;!--============ Exception: the insertFoo(..) method from DefaultFooService throws an exception...========== --&amp;gt; TRACE {org.springframework.transaction.interceptor.TransactionInterceptor} - Completing transaction for [tx.DefaultFooService.insertFoo] after exception: java.lang.UnsupportedOperationException TRACE {org.springframework.transaction.interceptor.RuleBasedTransactionAttribute} - Applying rules to determine whether transaction should rollback on java.lang.UnsupportedOperationException TRACE {org.springframework.transaction.interceptor.RuleBasedTransactionAttribute} - Winning rollback rule is: null TRACE {org.springframework.transaction.interceptor.RuleBasedTransactionAttribute} - No relevant rollback rule found: applying default rules TRACE {org.springframework.jdbc.datasource.DataSourceTransactionManager} - Triggering beforeCompletion synchronization &amp;lt;!-- rollback depending on the rollback rules --&amp;gt; DEBUG {org.springframework.jdbc.datasource.DataSourceTransactionManager} - Initiating transaction rollback DEBUG {org.springframework.jdbc.datasource.DataSourceTransactionManager} - Rolling back JDBC transaction on Connection [jdbc:h2:file:D:/Projects/spring-sample/activejdbc/src/main/resources/test, UserName=, H2 JDBC Driver] TRACE {org.springframework.jdbc.datasource.DataSourceTransactionManager} - Triggering afterCompletion synchronization &amp;lt;!-- clear transaction synchronization --&amp;gt; TRACE {org.springframework.transaction.support.TransactionSynchronizationManager} - Clearing transaction synchronization TRACE {org.springframework.transaction.support.TransactionSynchronizationManager} - Removed value [org.springframework.jdbc.datasource.ConnectionHolder@2101b44a] for key [org.apache.commons.dbcp.BasicDataSource@52d645b1] from thread [main] &amp;lt;!-- release connection --&amp;gt; DEBUG {org.springframework.jdbc.datasource.DataSourceTransactionManager} - Releasing JDBC Connection [jdbc:h2:file:D:/Projects/spring-sample/activejdbc/src/main/resources/test, UserName=, H2 JDBC Driver] after transaction DEBUG {org.springframework.jdbc.datasource.DataSourceUtils} - Returning JDBC Connection to DataSource &amp;nbsp;
</content>
    </entry>
    
     <entry>
        <title>Spring framework - AOP</title>
        <url>http://yangchao.me/post/spring-framework-aop/</url>
        <categories>
          <category>Spring</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html">  Crosscutting concerns refers to logic in an application that cannot be decomposed from the rest of the application and may result in code duplication and tight coupling.
Typical use cases:
 logging security transaction  Concepts:
 Pointcut -&amp;gt; where to do: class filtering and method matching Advice -&amp;gt; when to do: before/after/returning/throws/&amp;hellip; Aspect -&amp;gt; what to do, do what the application specified things. This is the only code application needs to define, others concepts are supported and configured by framework. Advisor -&amp;gt; associate Advice and Pointcut JoinPoint -&amp;gt; the execution point: the occurrence context including which class, which methods, proceeding method execution.. weaving -&amp;gt; when to proxy target: build time(compile-time), load-time, run-time  Spring AOP style Spring AOP depends on proxies. You must use ProxyFactoryBean to produce the proxy for target object.
Internally, Spring has two proxy implementations: JDK dynamic proxies and CGLIB proxies.
 By default, when the target object to be advised implements an interface, Spring will use a JDK dynamic proxy to create proxy instances of the target. when the advised target object doesn’t implement an interface (for example, it’s a concrete class), CGLIB will be used for proxy instance creation.  Joinpoints in Spring Spring AOP supports only one joinpoint type: method invocation.
Aspects in Spring: Adviser (Advice&#43;Pointcut) An aspect in Spring is represented by an instance of a class that implements the Advisor interface.
 PointcutAdvisor IntroductionAdvisor The main difference between Adviceand Advisoris that Advisor carries Advice with the associated Pointcut.  &amp;gt; ProxyFactory.addAdvice() delegates to addAdvisor() behind the scenes, creating an instance of DefaultPointcutAdvisor and configuring it with a pointcut that points to all methods.
Pointcut Pointcut acutally does something filtering class and matching methods.
eight Pointcut interface implementation:
 org.springframework.aop.support.NameMatchMethodPointcut org.springframework.aop.support.JdkRegexpMethodPointcut org.springframework.aop.support.annotation.AnnotationMatchingPointcut org.springframework.aop.aspectj.AspectJExpressionPointcut org.springframework.aop.support.DynamicMethodMatcherPointcut org.springframework.aop.support .StaticMethodMatcherPointcut org.springframework.aop.support.ComposablePointcut org.springframework.aop.support.ControlFlowPointcut  Advice types   Advice type    before org.springframework.aop.BeforeAdviceorg.springframework.aop.MethodBeforeAdvice   after(finally) org.springframework.aop.AfterAdvice   after returning org.springframework.aop.AfterReturningAdvice   around org.springframework.aop.Interceptororg.springframework.aop.MethodInterceptor   throws org.springframework.aop.ThrowsAdvice   introduction     ![advice-types](/media/advice-types.jpg) #### schema-based configuration #####  ```java  --   ``` `myAspect` bean is a plain bean, which don&#39;t necessarily implement any interface. #####  This is called aspect instantiation model. ```java      ``` `advice-ref` is a bean which must implement one of the `Advice` interfaces family. ### @AspectJ style Bascially, they use @Aspect, @Pointcut, @Around, @Before, ... To enable @AspectJ style: ```java  ``` ### Load-time weaving enabled by: ```java  ``` The default `LoadTimeWeaver` is the `DefaultContextLoadTimeWeaver` class, which attempts to decorate an automatically detected`LoadTimeWeaver`: the exact type of `LoadTimeWeaver` that will be _automatically detected_ is dependent upon your runtime environment (summarized in the following table). You can also specific the exact load-time weaver rather than the automatic one in xml configuration file: ```java ```   Running in [BEA’s Weblogic 10](http://www.bea.com/framework.jsp?CNT=index.htm&amp;amp;FP=/content/products/weblogic/server) `WebLogicLoadTimeWeaver`   Running in [IBM WebSphere Application Server 7](http://www-01.ibm.com/software/webservers/appserv/was/) `WebSphereLoadTimeWeaver`   Running in [GlassFish](http://glassfish.dev.java.net/) `GlassFishLoadTimeWeaver`   Running in [JBoss AS](http://www.jboss.org/jbossas/) `JBossLoadTimeWeaver`   JVM started with Spring `InstrumentationSavingAgent` _(java -javaagent:path/to/spring-instrument.jar)_e.g. J2SE applications (no LTW support, if no instrument agent specified to JVM, errors will be thrown) `InstrumentationLoadTimeWeaver`   Others all, expecting the underlying ClassLoader to follow common conventions (e.g. applicable to`TomcatInstrumentableClassLoader` and [Resin](http://www.caucho.com/)) `ReflectiveLoadTimeWeaver`    WebLogic, WebSphere, Resin, GlassFish, JBoss These environments have Load-time weaving support, no need for -javaagent:path/to/org.springframework.instrument-{version}.jar
Tomcat not support. You need do extra things to LTW
 Copy org.springframework.instrument.tomcat.jar into _$CATALINAHOME/lib Instruct Tomcat to use the custom class loader (instead of the default) by editing the web application context file:  &amp;lt;Context path=&amp;#34;/myWebApp&amp;#34; docBase=&amp;#34;/my/webApp/location&amp;#34;&amp;gt; &amp;lt;Loader loaderClass=&amp;#34;org.springframework.instrument.classloading.tomcat.TomcatInstrumentableClassLoader&amp;#34;/&amp;gt; &amp;lt;/Context&amp;gt; Generic J2SE applications Spring provides InstrumentationLoadTimeWeaver, which requires a Spring-specific (but very general) VM agent, -javaagent:path/to/org.springframework.instrument-{version}.jar
</content>
    </entry>
    
     <entry>
        <title>Spring framework - IoC / DI</title>
        <url>http://yangchao.me/post/spring-framework-ioc-di/</url>
        <categories>
          <category>Spring</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html">  IoC/DI and beans IoC is also known as dependency injection (DI).
A bean just need to define its dependencies through its constructor arguments, its factory method arguments or its properties setter. And then the container will inject these dependencies when initializing this bean.
Traditionally, the bean itself control the initialization process or location of its dependencies by directly invoking its constructor of the class or some look-up mechanism such as Service Locator pattern(e.g. JNDI or something).
So DI is a converse of the above traditional process, and that&amp;rsquo;s the reason it&amp;rsquo;s called Inverse-of-Control (IoC).
A bean is a manged object, whose creation, assembly, even whole lifecycle is controlled by the container.
Configuration metadata can be specified by XML-based configuration style or Annotation-based configuration style.
bean definition bean name &amp;lt;bean id=&amp;#34;only_one_id&amp;#34; name=&amp;#34;name1 name2 name3&amp;#34; ..&amp;gt; &amp;lt;alias name=&amp;#34;fromName&amp;#34; alias=&amp;#34;toName&amp;#34;/&amp;gt; you can name a bean by use id/name attribute. What&amp;rsquo;s more important is you can specify 0, 1, or multiple names/alias for a bean.
instantiating beans  Instantiation with a constructor  &amp;lt;bean id=&amp;#34;exampleBean&amp;#34; class=&amp;#34;examples.ExampleBean&amp;#34;/&amp;gt; &amp;lt;bean name=&amp;#34;anotherExample&amp;#34; class=&amp;#34;examples.ExampleBeanTwo$InnerClass&amp;#34;/&amp;gt;  Instantiation with a static factory method  &amp;lt;bean id=&amp;#34;clientService&amp;#34; class=&amp;#34;examples.ClientService&amp;#34; factory-method=&amp;#34;createInstance&amp;#34;/&amp;gt;  Instantiation using an instance factory method  &amp;lt;!-- the factory bean, which contains a method called createInstance() --&amp;gt; &amp;lt;bean id=&amp;#34;serviceLocator&amp;#34; class=&amp;#34;examples.DefaultServiceLocator&amp;#34;&amp;gt; &amp;lt;!-- inject any dependencies required by this locator bean --&amp;gt; &amp;lt;/bean&amp;gt; &amp;lt;!-- the bean to be created via the factory bean --&amp;gt; &amp;lt;bean id=&amp;#34;clientService&amp;#34; factory-bean=&amp;#34;serviceLocator&amp;#34; factory-method=&amp;#34;createClientServiceInstance&amp;#34;/&amp;gt; dependencies  Constructor-based dependency injection  &amp;lt;bean id=&amp;#34;foo&amp;#34; class=&amp;#34;x.y.Foo&amp;#34;&amp;gt; &amp;lt;constructor-arg ref=&amp;#34;bar&amp;#34;/&amp;gt; &amp;lt;constructor-arg ref=&amp;#34;baz&amp;#34;/&amp;gt; &amp;lt;/bean&amp;gt; &amp;lt;bean id=&amp;#34;bar&amp;#34; class=&amp;#34;x.y.Bar&amp;#34;/&amp;gt; &amp;lt;bean id=&amp;#34;baz&amp;#34; class=&amp;#34;x.y.Baz&amp;#34;/&amp;gt; &amp;lt;bean id=&amp;#34;exampleBean&amp;#34; class=&amp;#34;examples.ExampleBean&amp;#34;&amp;gt; &amp;lt;constructor-arg type=&amp;#34;int&amp;#34; value=&amp;#34;7500000&amp;#34;/&amp;gt; &amp;lt;constructor-arg type=&amp;#34;java.lang.String&amp;#34; value=&amp;#34;42&amp;#34;/&amp;gt; &amp;lt;/bean&amp;gt; &amp;lt;bean id=&amp;#34;exampleBean&amp;#34; class=&amp;#34;examples.ExampleBean&amp;#34;&amp;gt; &amp;lt;constructor-arg index=&amp;#34;0&amp;#34; value=&amp;#34;7500000&amp;#34;/&amp;gt; &amp;lt;constructor-arg index=&amp;#34;1&amp;#34; value=&amp;#34;42&amp;#34;/&amp;gt; &amp;lt;/bean&amp;gt; &amp;lt;!-- compiled with the debug flag --&amp;gt; &amp;lt;bean id=&amp;#34;exampleBean&amp;#34; class=&amp;#34;examples.ExampleBean&amp;#34;&amp;gt; &amp;lt;constructor-arg name=&amp;#34;years&amp;#34; value=&amp;#34;7500000&amp;#34;/&amp;gt; &amp;lt;constructor-arg name=&amp;#34;ultimateAnswer&amp;#34; value=&amp;#34;42&amp;#34;/&amp;gt; &amp;lt;/bean&amp;gt; XML shortcut with the c-namespace
&amp;lt;bean id=&amp;#34;bar&amp;#34; class=&amp;#34;x.y.Bar&amp;#34;/&amp;gt; &amp;lt;bean id=&amp;#34;baz&amp;#34; class=&amp;#34;x.y.Baz&amp;#34;/&amp;gt; &amp;lt;!-- traditional declaration --&amp;gt; &amp;lt;bean id=&amp;#34;foo&amp;#34; class=&amp;#34;x.y.Foo&amp;#34;&amp;gt; &amp;lt;constructor-arg ref=&amp;#34;bar&amp;#34;/&amp;gt; &amp;lt;constructor-arg ref=&amp;#34;baz&amp;#34;/&amp;gt; &amp;lt;constructor-arg value=&amp;#34;foo@bar.com&amp;#34;/&amp;gt; &amp;lt;/bean&amp;gt; &amp;lt;!-- c-namespace declaration --&amp;gt; &amp;lt;bean id=&amp;#34;foo&amp;#34; class=&amp;#34;x.y.Foo&amp;#34; c:bar-ref=&amp;#34;bar&amp;#34; c:baz-ref=&amp;#34;baz&amp;#34; c:email=&amp;#34;foo@bar.com&amp;#34;/&amp;gt;  Setter-based dependency injection  &amp;lt;bean id=&amp;#34;exampleBean&amp;#34; class=&amp;#34;examples.ExampleBean&amp;#34;&amp;gt; &amp;lt;!-- setter injection using the nested ref element --&amp;gt; &amp;lt;property name=&amp;#34;beanOne&amp;#34;&amp;gt; &amp;lt;ref bean=&amp;#34;anotherExampleBean&amp;#34;/&amp;gt; &amp;lt;/property&amp;gt; &amp;lt;!-- setter injection using the neater ref attribute --&amp;gt; &amp;lt;property name=&amp;#34;beanTwo&amp;#34; ref=&amp;#34;yetAnotherBean&amp;#34;/&amp;gt; &amp;lt;property name=&amp;#34;integerProperty&amp;#34; value=&amp;#34;1&amp;#34;/&amp;gt; &amp;lt;/bean&amp;gt; &amp;lt;bean id=&amp;#34;myDataSource&amp;#34; class=&amp;#34;org.apache.commons.dbcp.BasicDataSource&amp;#34; destroy-method=&amp;#34;close&amp;#34;&amp;gt; &amp;lt;!-- results in a setDriverClassName(String) call --&amp;gt; &amp;lt;property name=&amp;#34;driverClassName&amp;#34; value=&amp;#34;com.mysql.jdbc.Driver&amp;#34;/&amp;gt; &amp;lt;property name=&amp;#34;url&amp;#34; value=&amp;#34;jdbc:mysql://localhost:3306/mydb&amp;#34;/&amp;gt; &amp;lt;property name=&amp;#34;username&amp;#34; value=&amp;#34;root&amp;#34;/&amp;gt; &amp;lt;property name=&amp;#34;password&amp;#34; value=&amp;#34;masterkaoli&amp;#34;/&amp;gt; &amp;lt;/bean&amp;gt; &amp;lt;bean id=&amp;#34;outer&amp;#34; class=&amp;#34;...&amp;#34;&amp;gt; &amp;lt;!-- instead of using a reference to a target bean, simply define the target bean inline --&amp;gt; &amp;lt;property name=&amp;#34;target&amp;#34;&amp;gt; &amp;lt;bean class=&amp;#34;com.example.Person&amp;#34;&amp;gt; &amp;lt;!-- this is the inner bean --&amp;gt; &amp;lt;property name=&amp;#34;name&amp;#34; value=&amp;#34;Fiona Apple&amp;#34;/&amp;gt; &amp;lt;property name=&amp;#34;age&amp;#34; value=&amp;#34;25&amp;#34;/&amp;gt; &amp;lt;/bean&amp;gt; &amp;lt;/property&amp;gt; &amp;lt;/bean&amp;gt; &amp;lt;bean id=&amp;#34;moreComplexObject&amp;#34; class=&amp;#34;example.ComplexObject&amp;#34;&amp;gt; &amp;lt;!-- results in a setAdminEmails(java.util.Properties) call --&amp;gt; &amp;lt;property name=&amp;#34;adminEmails&amp;#34;&amp;gt; &amp;lt;props&amp;gt; &amp;lt;prop key=&amp;#34;administrator&amp;#34;&amp;gt;administrator@example.org&amp;lt;/prop&amp;gt; &amp;lt;prop key=&amp;#34;support&amp;#34;&amp;gt;support@example.org&amp;lt;/prop&amp;gt; &amp;lt;prop key=&amp;#34;development&amp;#34;&amp;gt;development@example.org&amp;lt;/prop&amp;gt; &amp;lt;/props&amp;gt; &amp;lt;/property&amp;gt; &amp;lt;!-- results in a setSomeList(java.util.List) call --&amp;gt; &amp;lt;property name=&amp;#34;someList&amp;#34;&amp;gt; &amp;lt;list&amp;gt; &amp;lt;value&amp;gt;a list element followed by a reference&amp;lt;/value&amp;gt; &amp;lt;ref bean=&amp;#34;myDataSource&amp;#34; /&amp;gt; &amp;lt;/list&amp;gt; &amp;lt;/property&amp;gt; &amp;lt;!-- results in a setSomeMap(java.util.Map) call --&amp;gt; &amp;lt;property name=&amp;#34;someMap&amp;#34;&amp;gt; &amp;lt;map&amp;gt; &amp;lt;entry key=&amp;#34;an entry&amp;#34; value=&amp;#34;just some string&amp;#34;/&amp;gt; &amp;lt;entry key =&amp;#34;a ref&amp;#34; value-ref=&amp;#34;myDataSource&amp;#34;/&amp;gt; &amp;lt;/map&amp;gt; &amp;lt;/property&amp;gt; &amp;lt;!-- results in a setSomeSet(java.util.Set) call --&amp;gt; &amp;lt;property name=&amp;#34;someSet&amp;#34;&amp;gt; &amp;lt;set&amp;gt; &amp;lt;value&amp;gt;just some string&amp;lt;/value&amp;gt; &amp;lt;ref bean=&amp;#34;myDataSource&amp;#34; /&amp;gt; &amp;lt;/set&amp;gt; &amp;lt;/property&amp;gt; &amp;lt;/bean&amp;gt;  &amp;rdquo;&amp;rdquo; and null
&amp;lt;bean class=&amp;#34;ExampleBean&amp;#34;&amp;gt; &amp;lt;property name=&amp;#34;email&amp;#34; value=&amp;#34;&amp;#34;/&amp;gt; &amp;lt;/bean&amp;gt; &amp;lt;bean class=&amp;#34;ExampleBean&amp;#34;&amp;gt; &amp;lt;property name=&amp;#34;email&amp;#34;&amp;gt; &amp;lt;null/&amp;gt; &amp;lt;/property&amp;gt; &amp;lt;/bean&amp;gt; XML shortcut with the p-namespace
&amp;lt;bean name=&amp;#34;john-classic&amp;#34; class=&amp;#34;com.example.Person&amp;#34;&amp;gt; &amp;lt;property name=&amp;#34;name&amp;#34; value=&amp;#34;John Doe&amp;#34;/&amp;gt; &amp;lt;property name=&amp;#34;spouse&amp;#34; ref=&amp;#34;jane&amp;#34;/&amp;gt; &amp;lt;/bean&amp;gt; &amp;lt;bean name=&amp;#34;john-modern&amp;#34; class=&amp;#34;com.example.Person&amp;#34;p:name=&amp;#34;John Doe&amp;#34;p:spouse-ref=&amp;#34;jane&amp;#34;/&amp;gt; bean scopes   Scope Description     singleton (Default) Scopes a single bean definition to a single object instance per Spring IoC container.   prototype Scopes a single bean definition to any number of object instances.   request Scopes a single bean definition to the lifecycle of a single HTTP request; that is, each HTTP request has its own instance of a bean created off the back of a single bean definition. Only valid in the context of a web-aware Spring ApplicationContext.   session Scopes a single bean definition to the lifecycle of an HTTP Session. Only valid in the context of a web-aware Spring ApplicationContext.   global session Scopes a single bean definition to the lifecycle of a global HTTP Session. Typically only valid when used in a portlet context. Only valid in the context of a web-aware Spring ApplicationContext.   application Scopes a single bean definition to the lifecycle of a ServletContext. Only valid in the context of a web-aware Spring ApplicationContext.    request / session / application scopes need special initial configuration.
annotations and bean scanning Spring annotations vs. standard annotations
    Spring javax.inject.* javax.inject restrictions / comments     @Autowired @Inject @Inject has no required attribute   @Component @Named -   @Scope(&amp;ldquo;singleton&amp;rdquo;) @Singleton The JSR-330 default scope is like Spring’s prototype. However, in order to keep it consistent with Spring’s general defaults, a JSR-330 bean declared in the Spring container is a singleton by default. In order to use a scope other than singleton, you should use Spring’s @Scope annotation.javax.inject also provides a @Scope annotation. Nevertheless, this one is only intended to be used for creating your own annotations.   @Qualifier @Named -   @Value - no equivalent   @Required - no equivalent   @Lazy - no equivalent     Spring also supports injection using the JSR-250 @Resource annotation on fields or bean property setter methods.
</content>
    </entry>
    
     <entry>
        <title>Spring framework - the big picture</title>
        <url>http://yangchao.me/post/spring-framework-the-big-picture/</url>
        <categories>
          <category>Spring</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html"> Spring is a big beast. I have to sort out its design and modules.
  GroupId ArtifactId Description     org.springframework spring-aop Proxy-based AOP support   org.springframework spring-aspects AspectJ based aspects   org.springframework spring-beans Beans support, including Groovy   org.springframework spring-context Application context runtime, including scheduling and remoting abstractions   org.springframework spring-context-support Support classes for integrating common third-party libraries into a Spring application context   org.springframework spring-core Core utilities, used by many other Spring modules   org.springframework spring-expression Spring Expression Language (SpEL)   org.springframework spring-instrument Instrumentation agent for JVM bootstrapping   org.springframework spring-instrument-tomcat Instrumentation agent for Tomcat   org.springframework spring-jdbc JDBC support package, including DataSource setup and JDBC access support   org.springframework spring-jms JMS support package, including helper classes to send and receive JMS messages   org.springframework spring-messaging Support for messaging architectures and protocols   org.springframework spring-orm Object/Relational Mapping, including JPA and Hibernate support   org.springframework spring-oxm Object/XML Mapping   org.springframework spring-test Support for unit testing and integration testing Spring components   org.springframework spring-tx Transaction infrastructure, including DAO support and JCA integration   org.springframework spring-web Web support packages, including client and web remoting   org.springframework spring-webmvc REST Web Services and model-view-controller implementation for web applications   org.springframework spring-webmvc-portlet MVC implementation to be used in a Portlet environment   org.springframework spring-websocket WebSocket and SockJS implementations, including STOMP suppor    &amp;nbsp;
</content>
    </entry>
    
     <entry>
        <title>subquery vs. join</title>
        <url>http://yangchao.me/post/subquery-vs-join/</url>
        <categories>
          <category>SQL</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html">  what is subquery SubQuery in SQL is a query inside another query
SELECT name FROM City WHERE pincode IN (SELECT pincode FROM pin WHERE zone=&amp;#39;west&amp;#39;) In this SQL, the part in the brackets is called inner query, while the part out of the brackets is called outer query.
non-correlated subquery In non correlated subquery, inner query doesn&amp;rsquo;t depend on outer query and can run as stand alone query.
NonCorrelated subquery are used along-with =, IN and NOT IN clause. When you use =, the subquery must return only 1 row.
SELECT COMPANY FROM Stock WHERE LISTED_ON_EXCHANGE = (SELECT RIC FROM Market WHERE COUNTRY=&amp;#39;Japan&amp;#39;); Here, the inner query is executed before the outer query.
correlated subquery Correlated subqueries are the one in which inner query or subquery reference outer query.
One of the most common example of correlated subquery is using keywords exits and not exits.
SELECT m.NAME FROM Market m WHERE m.RIC EXISTS (SELECT s.LISTED_ON_EXCHANGE FROM Stock s WHERE s.LISTED_ON_EXCHANGE=m.RIC); Here, the outer query is executed without WHERE clause before the inner query.
which is preferable: subquery or join Now, almost any subquery can be written in join.
id name id title -- ---- -- ---- 1 Kenny 1 Analyst 1 Rob 2 Sales 4 Molly 3 Manager 1 Greg 2 John -- non correlated subquery using IN -- Returns 3 records - Kenny, Rob, and Greg SELECT * FROM tableA WHERE tableA.id IN (SELECT tableB.id FROM tableB WHERE title = &amp;#39;Analyst&amp;#39;); -- correlated subquery using EXISTS SELECT * FROM tableA WHERE EXISTS (SELECT 1 FROM tableB WHERE title = &amp;#39;Analyst&amp;#39; AND tableA.id = tableB.id); -- JOIN (INNER is the default when only JOIN is specified) SELECT * FROM tableA JOIN tableB ON tableA.id = tableB.id WHERE tableB.title = &amp;#39;Analyst&amp;#39;; Basically, there are some differences:
 Subquery is more intuitive and relatively easy to understand. In most cases, EXISTS or JOIN will be much more efficient (and faster) than an IN statement. &amp;nbsp;  </content>
    </entry>
    
     <entry>
        <title>inner join and outer join</title>
        <url>http://yangchao.me/post/inner-join-and-outer-join/</url>
        <categories>
          <category>SQL</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html">  In this blog, we use two tables: TableA and TableB   id name id name   &amp;ndash; &amp;mdash;- &amp;ndash; &amp;mdash;&amp;ndash;   1 Pirate 1 Rutabaga   2 Monkey 2 Pirate   3 Ninja  3 Darth Vader   4 Spaghetti 4 Ninja    &amp;gt; inner or outer keyword can be omitted.
inner join Inner join produces only the set of records that match in both Table A and Table B. &amp;gt; The inner keyword can be left out from SQL statements. SELECT * FROM TableA INNER JOIN TableB ON TableA.name = TableB.name id name id name -- ---- -- ---- 1 Pirate 2 Pirate 3 Ninja 4 Ninja outer join There are 3 kinds of outer join. &amp;gt; The outer keyword can be left out from SQL statements.
left outer join Left outer join produces a complete set of records from Table A, with the matching records (where available) in Table B. If there is no match, the right side will contain null.
SELECT * FROM TableA LEFT OUTER JOIN TableB ON TableA.name = TableB.name id name id name -- ---- -- ---- 1 Pirate 2 Pirate 2 Monkey null null 3 Ninja 4 Ninja 4 Spaghetti null null &amp;nbsp;
right outer join Right outer join produces a complete set of records from Table B, with the matching records (where available) in Table A. If there is no match, the left side will contain null.
SELECT * FROM TableA RIGHT OUTER JOIN TableB ON TableA.name = TableB.name WHERE TableB.id IS null id name id name -- ---- -- ---- null null 1 Rutabaga 1 Pirate 2 Pirate null null 3 Darth Vader 3 Ninja 4 Ninja full outer join Full outer join produces the set of all records in Table A and Table B, with matching records from both sides where available. If there is no match, the missing side will contain null.
SELECT * FROM TableA FULL OUTER JOIN TableB ON TableA.name = TableB.name id name id name -- ---- -- ---- 1 Pirate 2 Pirate 2 Monkey null null 3 Ninja 4 Ninja 4 Spaghetti null null null null 1 Rutabaga null null 3 Darth Vader cross join (cartesian product) SELECT * FROM TableA CROSS JOIN TableB This joins &amp;ldquo;everything to everything&amp;rdquo;, resulting in 4 x 4 = 16 rows, far more than we had in the original sets.
&amp;nbsp;
&amp;nbsp;
</content>
    </entry>
    
     <entry>
        <title>A glimpse of JMS</title>
        <url>http://yangchao.me/post/a-glimpse-of-jms/</url>
        <categories>
          <category>JMS</category>
        </categories>
        <tags>
          <tag>TODO</tag>
        </tags>
        <content type="html">  what messaging provides?  loosely decoupled A component sends a message to a destination, and the recipient can retrieve the message from the destination. However, the sender and the receiver do not have to be available at the same time in order to communicate. In fact, the sender does not need to know anything about the receiver; nor does the receiver need to know anything about the sender. The sender and the receiver need to know only which message format and which destination to use.
 asynchronous A JMS provider can deliver messages to a client as they arrive; a client does not have to request messages in order to receive them.
 reliable The JMS API can ensure that a message is delivered once and only once. Lower levels of reliability are available for applications that can afford to miss messages or to receive duplicate messages.
  JMS architecture  JMS provider - a messaging system implementing JMS specification, like WebSphere MQ, ActiveMQ etc. JMS clients - programs or components written in Java which can produce or consume message messages - the objects that communicate information between JMS clients. Administered objects - preconfigured JMS objects created by an administrator for the use of clients. This objects can be looked up and referenced from JNDI namespace.   Messaging Domains Point-to-Point Messaging Domain  Each message has only one consumer. A sender and a receiver of a message have no timing dependencies. The receiver can fetch the message whether or not it was running when the client sent the message. The receiver acknowledges the successful processing of a message.  Publish/Subscribe Messaging Domain  Each message can have multiple consumers. Publishers and subscribers have a timing dependency. A client that subscribes to a topic can consume only messages published after the client has created a subscription, and the subscriber must continue to be active in order for it to consume messages.  The JMS API Programming Model JMS Administered Objects Two parts of a JMS application, destinations and connection factories, are best maintained administratively rather than programmatically.
A connection factory is the object a client uses to create a connection to a provider.
In the PTP messaging domain, destinations are called queues. In the pub/sub messaging domain, destinations are called topics.
JMS Connections You use a connection to create one or more sessions.
JMS Sessions A session is a single-threaded context for producing and consuming messages. You use sessions to create the following:
 Message producers Message consumers Messages Queue browsers Temporary queues and topics Session class implements Runnable interface.  JMS Message Producers MessageProducer producer = session.createProducer(dest); MessageProducer producer = session.createProducer(queue); MessageProducer producer = session.createProducer(topic); producer.send(message); MessageProducer anon_prod = session.createProducer(null); anon_prod.send(dest, message); JMS Message Consumers MessageConsumer consumer = session.createConsumer(dest); MessageConsumer consumer = session.createConsumer(queue); MessageConsumer consumer = session.createConsumer(topic); connection.start(); Message m = consumer.receive(); connection.start(); Message m = consumer.receive(1000); // time out after a second JMS Message Listeners Listener myListener = new Listener(); consumer.setMessageListener(myListener); JMS Message Selectors This is for message filtering.The syntax of the expression is based on a subset of the SQL92 conditional expression syntax. NewsType = ’Sports’ OR NewsType = ’Opinion’ The message consumer then receives only messages whose headers and properties match the selector.
JMS Messages JMS message includes 3 parts: header, properties, body, of which only header is required.
MS Queue Browsers This browser can browse the messages in the queue and display the header values for each message.
basic usage examples public class PointToPoint { private ConnectionFactory factory; private Connection connection; private Session session; private Destination destination; @Before public void setup() throws Exception { factory = new ActiveMQConnectionFactory(ActiveMQConnection.DEFAULT_BROKER_URL); connection = factory.createConnection(); connection = factory.createConnection(); connection.start(); session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); destination = session.createQueue(&amp;#34;myqueue&amp;#34;); } @Test public void testSend() throws Exception { MessageProducer producer = session.createProducer(destination); TextMessage message = session.createTextMessage(); message.setText(&amp;#34;Hello ...This is a sample message..sending from FirstClient&amp;#34;); producer.send(message); System.out.println(&amp;#34;Sent: &amp;#34; &#43; message.getText()); } @Test public void testReceive() throws Exception { MessageConsumer consumer = session.createConsumer(destination); Message message = consumer.receive(); if (message instanceof TextMessage) { TextMessage text = (TextMessage) message; System.out.println(&amp;#34;Message is : &amp;#34; &#43; text.getText()); } } } reliability mechanisms acknowledge transaction message persistence message expiry message priority level durable subscriber </content>
    </entry>
    
     <entry>
        <title>servlet basics</title>
        <url>http://yangchao.me/post/servlet-basics/</url>
        <categories>
          <category>Servlet / JSP</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html">  Deployment Descriptor: web.xml The following is a complete Deployment Descriptor.
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;ISO-8859-1&amp;#34;?&amp;gt; &amp;lt;web-app xmlns=&amp;#34;http://java.sun.com/xml/ns/j2ee&amp;#34;xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34;xsi:schemaLocation=&amp;#34;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&amp;#34; version=&amp;#34;2.5&amp;#34;&amp;gt; &amp;lt;!-- ========================================================== --&amp;gt; &amp;lt;!-- General --&amp;gt; &amp;lt;!-- ========================================================== --&amp;gt; &amp;lt;!-- Name the application --&amp;gt; &amp;lt;display-name&amp;gt;Example App&amp;lt;/display-name&amp;gt; &amp;lt;description&amp;gt;An example application which is used to play with some of the features of Tomcat&amp;lt;/description&amp;gt; &amp;lt;!-- This app is cluster-ready --&amp;gt; &amp;lt;distributable /&amp;gt; &amp;lt;!-- Set timeout to 120 minutes --&amp;gt; &amp;lt;session-config&amp;gt; &amp;lt;session-timeout&amp;gt;120&amp;lt;/session-timeout&amp;gt; &amp;lt;/session-config&amp;gt; &amp;lt;!-- ========================================================== --&amp;gt; &amp;lt;!-- JSP Configuration --&amp;gt; &amp;lt;!-- ========================================================== --&amp;gt; &amp;lt;!-- Note that you can only have one &amp;lt;jsp-config&amp;gt; element per web.xml --&amp;gt; &amp;lt;jsp-config&amp;gt; &amp;lt;!-- Taglib declarations are no longer required since JSP 2.0, see Removing taglib from web.xml --&amp;gt; &amp;lt;!-- The &amp;lt;taglib&amp;gt; did not need to be a child of &amp;lt;jsp-config&amp;gt; in earlier versions but is required as of Tomcat 7 --&amp;gt; &amp;lt;taglib&amp;gt; &amp;lt;taglib-uri&amp;gt;mytags&amp;lt;/taglib-uri&amp;gt; &amp;lt;taglib-location&amp;gt;/WEB-INF/jsp/mytaglib.tld&amp;lt;/taglib-location&amp;gt; &amp;lt;/taglib&amp;gt; &amp;lt;jsp-property-group&amp;gt; &amp;lt;url-pattern&amp;gt;*.jsp&amp;lt;/url-pattern&amp;gt; &amp;lt;include-prelude&amp;gt;/WEB-INF/jspf/prelude1.jspf&amp;lt;/include-prelude&amp;gt; &amp;lt;include-coda&amp;gt;/WEB-INF/jspf/coda1.jspf&amp;lt;/include-coda&amp;gt; &amp;lt;/jsp-property-group&amp;gt; &amp;lt;/jsp-config&amp;gt; &amp;lt;!-- ========================================================== --&amp;gt; &amp;lt;!-- Context Parameters --&amp;gt; &amp;lt;!-- ========================================================== --&amp;gt; &amp;lt;context-param&amp;gt; &amp;lt;description&amp;gt;Enable debugging for the application&amp;lt;/description&amp;gt; &amp;lt;param-name&amp;gt;debug&amp;lt;/param-name&amp;gt; &amp;lt;param-value&amp;gt;true&amp;lt;/param-value&amp;gt; &amp;lt;/context-param&amp;gt; &amp;lt;context-param&amp;gt; &amp;lt;description&amp;gt;The email address of the administrator, used to send error reports.&amp;lt;/description&amp;gt; &amp;lt;param-name&amp;gt;webmaster&amp;lt;/param-name&amp;gt; &amp;lt;param-value&amp;gt;address@somedomain.com&amp;lt;/param-value&amp;gt; &amp;lt;/context-param&amp;gt; &amp;lt;!-- ========================================================== --&amp;gt; &amp;lt;!-- Servlets --&amp;gt; &amp;lt;!-- ========================================================== --&amp;gt; &amp;lt;!-- Simple Servlet, provide a name, class, description and map to URL /servlet/SimpleServlet --&amp;gt; &amp;lt;servlet&amp;gt; &amp;lt;servlet-name&amp;gt;Simple&amp;lt;/servlet-name&amp;gt; &amp;lt;servlet-class&amp;gt;SimpleServlet&amp;lt;/servlet-class&amp;gt; &amp;lt;description&amp;gt;This is a simple Hello World servlet&amp;lt;/description&amp;gt; &amp;lt;/servlet&amp;gt; &amp;lt;servlet-mapping&amp;gt; &amp;lt;servlet-name&amp;gt;Simple&amp;lt;/servlet-name&amp;gt; &amp;lt;url-pattern&amp;gt;/servlet/SimpleServlet&amp;lt;/url-pattern&amp;gt; &amp;lt;/servlet-mapping&amp;gt; &amp;lt;!-- CMS Servlet, responds to *.cms URL&amp;#39;s --&amp;gt; &amp;lt;servlet&amp;gt; &amp;lt;!-- Identification --&amp;gt; &amp;lt;servlet-name&amp;gt;cms&amp;lt;/servlet-name&amp;gt; &amp;lt;servlet-class&amp;gt;com.metawerx.servlets.ContentManagementSystem&amp;lt;/servlet-class&amp;gt; &amp;lt;description&amp;gt;This servlet handles requests for the CMS (it is a controller in an MVC architecture)&amp;lt;/description&amp;gt; &amp;lt;!-- This servlet has two parameters --&amp;gt; &amp;lt;init-param&amp;gt; &amp;lt;param-name&amp;gt;debug&amp;lt;/param-name&amp;gt; &amp;lt;param-value&amp;gt;true&amp;lt;/param-value&amp;gt; &amp;lt;/init-param&amp;gt; &amp;lt;init-param&amp;gt; &amp;lt;param-name&amp;gt;detail&amp;lt;/param-name&amp;gt; &amp;lt;param-value&amp;gt;2&amp;lt;/param-value&amp;gt; &amp;lt;/init-param&amp;gt; &amp;lt;!-- Load this servlet when the application starts (call the init() method of the servlet) --&amp;gt; &amp;lt;load-on-startup&amp;gt;5&amp;lt;/load-on-startup&amp;gt; &amp;lt;!-- &amp;lt;run-at&amp;gt;0:00, 6:00, 12:00, 18:00&amp;lt;/run-at&amp;gt; This tag is only valid for Resin --&amp;gt; &amp;lt;/servlet&amp;gt; &amp;lt;!-- Map some URLs to the cms servlet (demonstrates *.extension mapping) --&amp;gt; &amp;lt;servlet-mapping&amp;gt; &amp;lt;!-- For any URL ending in .cms, the cms servlet will be called --&amp;gt; &amp;lt;servlet-name&amp;gt;cms&amp;lt;/servlet-name&amp;gt; &amp;lt;url-pattern&amp;gt;*.cms&amp;lt;/url-pattern&amp;gt; &amp;lt;/servlet-mapping&amp;gt; &amp;lt;!-- Rewriter Servlet, responds to /content/* and /admin/RewriterStatistics URL&amp;#39;s --&amp;gt; &amp;lt;!-- Define a servlet to respond to /content/* URL&amp;#39;s --&amp;gt; &amp;lt;servlet&amp;gt; &amp;lt;servlet-name&amp;gt;rewriter&amp;lt;/servlet-name&amp;gt; &amp;lt;servlet-class&amp;gt;com.metawerx.servlets.URLRewriter&amp;lt;/servlet-class&amp;gt; &amp;lt;/servlet&amp;gt; &amp;lt;!-- Map some URL&amp;#39;s to the rewriter servlet (demonstrates /path/* and specific URL mapping) --&amp;gt; &amp;lt;servlet-mapping&amp;gt; &amp;lt;!-- For any URL starting with /content/, the rewriter servlet will be called --&amp;gt; &amp;lt;servlet-name&amp;gt;rewriter&amp;lt;/servlet-name&amp;gt; &amp;lt;url-pattern&amp;gt;/content/*&amp;lt;/url-pattern&amp;gt; &amp;lt;/servlet-mapping&amp;gt; &amp;lt;servlet-mapping&amp;gt; &amp;lt;!-- The rewriter servlet can also be called directly as /admin/RewriterStatistics, to return stats --&amp;gt; &amp;lt;servlet-name&amp;gt;rewriter&amp;lt;/servlet-name&amp;gt; &amp;lt;url-pattern&amp;gt;/admin/RewriterStatistics&amp;lt;/url-pattern&amp;gt; &amp;lt;/servlet-mapping&amp;gt; &amp;lt;!-- PathJSP Servlet, maps /shop/item/* URL&amp;#39;s to a JSP file --&amp;gt; &amp;lt;!-- Define a JSP file to respond to /shop/item/* URL&amp;#39;s --&amp;gt; &amp;lt;servlet&amp;gt; &amp;lt;servlet-name&amp;gt;pathjsp&amp;lt;/servlet-name&amp;gt; &amp;lt;jsp-file&amp;gt;pathfinder.jsp&amp;lt;/jsp-file&amp;gt; &amp;lt;/servlet&amp;gt; &amp;lt;!-- Map some URL&amp;#39;s to the pathjsp servlet (demonstrates /long/path/* URL mapping) --&amp;gt; &amp;lt;servlet-mapping&amp;gt; &amp;lt;!-- For any URL starting with /shop/item/, the pathjsp servlet will be called --&amp;gt; &amp;lt;servlet-name&amp;gt;pathjsp&amp;lt;/servlet-name&amp;gt; &amp;lt;url-pattern&amp;gt;/shop/item/*&amp;lt;/url-pattern&amp;gt; &amp;lt;/servlet-mapping&amp;gt; &amp;lt;!-- ========================================================== --&amp;gt; &amp;lt;!-- Filters --&amp;gt; &amp;lt;!-- ========================================================== --&amp;gt; &amp;lt;!-- Example filter to set character encoding on each request (from Tomcat servlets-examples context) --&amp;gt; &amp;lt;filter&amp;gt; &amp;lt;filter-name&amp;gt;Set Character Encoding&amp;lt;/filter-name&amp;gt; &amp;lt;filter-class&amp;gt;filters.SetCharacterEncodingFilter&amp;lt;/filter-class&amp;gt; &amp;lt;init-param&amp;gt; &amp;lt;param-name&amp;gt;encoding&amp;lt;/param-name&amp;gt; &amp;lt;param-value&amp;gt;EUC_JP&amp;lt;/param-value&amp;gt; &amp;lt;/init-param&amp;gt; &amp;lt;/filter&amp;gt; &amp;lt;filter-mapping&amp;gt; &amp;lt;filter-name&amp;gt;Set Character Encoding&amp;lt;/filter-name&amp;gt; &amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt; &amp;lt;/filter-mapping&amp;gt; &amp;lt;!-- Example filter to dump the HTTP request at the top of each page (from Tomcat servlets-examples context) --&amp;gt; &amp;lt;filter&amp;gt; &amp;lt;filter-name&amp;gt;Request Dumper Filter&amp;lt;/filter-name&amp;gt; &amp;lt;filter-class&amp;gt;filters.RequestDumperFilter&amp;lt;/filter-class&amp;gt; &amp;lt;/filter&amp;gt; &amp;lt;filter-mapping&amp;gt; &amp;lt;filter-name&amp;gt;Request Dumper Filter&amp;lt;/filter-name&amp;gt; &amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt; &amp;lt;/filter-mapping&amp;gt; &amp;lt;!-- ========================================================== --&amp;gt; &amp;lt;!-- Listeners --&amp;gt; &amp;lt;!-- ========================================================== --&amp;gt; &amp;lt;!-- Define example application events listeners --&amp;gt; &amp;lt;listener&amp;gt; &amp;lt;listener-class&amp;gt;com.metawerx.listener.ContextListener&amp;lt;/listener-class&amp;gt; &amp;lt;/listener&amp;gt; &amp;lt;listener&amp;gt; &amp;lt;listener-class&amp;gt;com.metawerx.listener.SessionListener&amp;lt;/listener-class&amp;gt; &amp;lt;/listener&amp;gt; &amp;lt;!-- ========================================================== --&amp;gt; &amp;lt;!-- Security --&amp;gt; &amp;lt;!-- ========================================================== --&amp;gt; &amp;lt;!-- Define roles --&amp;gt; &amp;lt;security-role&amp;gt; &amp;lt;role-name&amp;gt;admin&amp;lt;/role-name&amp;gt; &amp;lt;/security-role&amp;gt; &amp;lt;security-role&amp;gt; &amp;lt;role-name&amp;gt;cms_editors&amp;lt;/role-name&amp;gt; &amp;lt;/security-role&amp;gt; &amp;lt;!-- Define a constraint to restrict access to /private/* --&amp;gt; &amp;lt;security-constraint&amp;gt; &amp;lt;display-name&amp;gt;Security constraint for the /private folder&amp;lt;/display-name&amp;gt; &amp;lt;web-resource-collection&amp;gt; &amp;lt;web-resource-name&amp;gt;Protected Area&amp;lt;/web-resource-name&amp;gt; &amp;lt;url-pattern&amp;gt;/private/*&amp;lt;/url-pattern&amp;gt; &amp;lt;!-- If you list http methods, only those methods are protected. --&amp;gt; &amp;lt;!-- Leave this commented out to protect all access --&amp;gt; &amp;lt;!-- &amp;lt;http-method&amp;gt;DELETE&amp;lt;/http-method&amp;gt; &amp;lt;http-method&amp;gt;GET&amp;lt;/http-method&amp;gt; &amp;lt;http-method&amp;gt;POST&amp;lt;/http-method&amp;gt; &amp;lt;http-method&amp;gt;PUT&amp;lt;/http-method&amp;gt; --&amp;gt; &amp;lt;/web-resource-collection&amp;gt; &amp;lt;auth-constraint&amp;gt; &amp;lt;!-- Only only administrator and CMS editors to access this area --&amp;gt; &amp;lt;role-name&amp;gt;admin&amp;lt;/role-name&amp;gt; &amp;lt;role-name&amp;gt;cms_editors&amp;lt;/role-name&amp;gt; &amp;lt;/auth-constraint&amp;gt; &amp;lt;/security-constraint&amp;gt; &amp;lt;!-- FORM based authentication --&amp;gt; &amp;lt;!-- Leave this commented out, we will use BASIC (HTTP) authentication instead --&amp;gt; &amp;lt;!-- &amp;lt;login-config&amp;gt; &amp;lt;auth-method&amp;gt;FORM&amp;lt;/auth-method&amp;gt; &amp;lt;form-login-config&amp;gt; &amp;lt;form-login-page&amp;gt;/login.jsp&amp;lt;/form-login-page&amp;gt; &amp;lt;form-error-page&amp;gt;/error.jsp&amp;lt;/form-error-page&amp;gt; &amp;lt;/form-login-config&amp;gt; &amp;lt;/login-config&amp;gt; --&amp;gt; &amp;lt;!-- This application uses BASIC authentication --&amp;gt; &amp;lt;login-config&amp;gt; &amp;lt;auth-method&amp;gt;BASIC&amp;lt;/auth-method&amp;gt; &amp;lt;realm-name&amp;gt;Editor Login&amp;lt;/realm-name&amp;gt; &amp;lt;/login-config&amp;gt; &amp;lt;!-- Define a constraint to force SSL on all pages in the application --&amp;gt; &amp;lt;security-constraint&amp;gt; &amp;lt;web-resource-collection&amp;gt; &amp;lt;web-resource-name&amp;gt;Entire Application&amp;lt;/web-resource-name&amp;gt; &amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt; &amp;lt;/web-resource-collection&amp;gt; &amp;lt;user-data-constraint&amp;gt; &amp;lt;transport-guarantee&amp;gt;CONFIDENTIAL&amp;lt;/transport-guarantee&amp;gt; &amp;lt;/user-data-constraint&amp;gt; &amp;lt;/security-constraint&amp;gt; &amp;lt;!-- ========================================================== --&amp;gt; &amp;lt;!-- Error Handler --&amp;gt; &amp;lt;!-- ========================================================== --&amp;gt; &amp;lt;!-- Define an error handler for 404 pages --&amp;gt; &amp;lt;error-page&amp;gt; &amp;lt;error-code&amp;gt;404&amp;lt;/error-code&amp;gt; &amp;lt;location&amp;gt;/error404.jsp&amp;lt;/location&amp;gt; &amp;lt;/error-page&amp;gt; &amp;lt;!-- Define an error handler for java.lang.Throwable --&amp;gt; &amp;lt;error-page&amp;gt; &amp;lt;exception-type&amp;gt;java.lang.Throwable&amp;lt;/exception-type&amp;gt; &amp;lt;location&amp;gt;/errorThrowable.jsp&amp;lt;/location&amp;gt; &amp;lt;/error-page&amp;gt; &amp;lt;!-- ========================================================== --&amp;gt; &amp;lt;!-- Extra MIME types --&amp;gt; &amp;lt;!-- ========================================================== --&amp;gt; &amp;lt;!-- Set XML mime-mapping so spreadsheets open properly instead of being sent as an octet/stream --&amp;gt; &amp;lt;mime-mapping&amp;gt; &amp;lt;extension&amp;gt;xls&amp;lt;/extension&amp;gt; &amp;lt;mime-type&amp;gt;application/vnd.ms-excel&amp;lt;/mime-type&amp;gt; &amp;lt;/mime-mapping&amp;gt; &amp;lt;!-- ========================================================== --&amp;gt; &amp;lt;!-- Locale --&amp;gt; &amp;lt;!-- ========================================================== --&amp;gt; &amp;lt;!-- Set Locale Encoding --&amp;gt; &amp;lt;locale-encoding-mapping-list&amp;gt; &amp;lt;locale-encoding-mapping&amp;gt; &amp;lt;locale&amp;gt;ja&amp;lt;/locale&amp;gt; &amp;lt;encoding&amp;gt;Shift_JIS&amp;lt;/encoding&amp;gt; &amp;lt;/locale-encoding-mapping&amp;gt; &amp;lt;/locale-encoding-mapping-list&amp;gt; &amp;lt;!-- ========================================================== --&amp;gt; &amp;lt;!-- Welcome Files --&amp;gt; &amp;lt;!-- ========================================================== --&amp;gt; &amp;lt;!-- Define, in order of preference, which file to show when no filename is defined in the path --&amp;gt; &amp;lt;!-- eg: when user goes to http://yoursite.com/ or http://yoursite.com/somefolder --&amp;gt;  &amp;lt;!-- Defaults are provided in the server-wide web.xml file, such as index.jsp, index.htm --&amp;gt; &amp;lt;!-- Note: using this tag overrides the defaults, so don&amp;#39;t forget to add them here --&amp;gt; &amp;lt;welcome-file-list&amp;gt; &amp;lt;!-- Use index.swf if present, or splash.jsp, otherwise just look for the normal defaults --&amp;gt; &amp;lt;welcome-file&amp;gt;index.swf&amp;lt;/welcome-file&amp;gt; &amp;lt;welcome-file&amp;gt;splash.jsp&amp;lt;/welcome-file&amp;gt; &amp;lt;welcome-file&amp;gt;index.html&amp;lt;/welcome-file&amp;gt; &amp;lt;welcome-file&amp;gt;index.htm&amp;lt;/welcome-file&amp;gt; &amp;lt;welcome-file&amp;gt;index.jsp&amp;lt;/welcome-file&amp;gt; &amp;lt;/welcome-file-list&amp;gt; &amp;lt;!-- ========================================================== --&amp;gt; &amp;lt;!-- JNDI Environment Variables --&amp;gt; &amp;lt;!-- ========================================================== --&amp;gt; &amp;lt;env-entry&amp;gt; &amp;lt;env-entry-name&amp;gt;webmasterName&amp;lt;/env-entry-name&amp;gt; &amp;lt;env-entry-value&amp;gt;Ms. W. Master&amp;lt;/env-entry-value&amp;gt; &amp;lt;env-entry-type&amp;gt;java.lang.String&amp;lt;/env-entry-type&amp;gt; &amp;lt;/env-entry&amp;gt; &amp;lt;env-entry&amp;gt; &amp;lt;env-entry-name&amp;gt;cms/defaultUserSettings/recordsPerPage&amp;lt;/env-entry-name&amp;gt; &amp;lt;env-entry-value&amp;gt;30&amp;lt;/env-entry-value&amp;gt; &amp;lt;env-entry-type&amp;gt;java.lang.Integer&amp;lt;/env-entry-type&amp;gt; &amp;lt;/env-entry&amp;gt; &amp;lt;!-- ===========Programmer&amp;#39;s virtual name for resource=====================--&amp;gt; &amp;lt;resource-ref&amp;gt; &amp;lt;res-ref-name&amp;gt;jdbc/iass_ds&amp;lt;/res-ref-name&amp;gt; &amp;lt;res-type&amp;gt;javax.sql.DataSource&amp;lt;/res-type&amp;gt; &amp;lt;res-auth&amp;gt;Container&amp;lt;/res-auth&amp;gt; &amp;lt;res-sharing-scope&amp;gt;Shareable&amp;lt;/res-sharing-scope&amp;gt; &amp;lt;/resource-ref&amp;gt; &amp;lt;resource-env-ref&amp;gt; &amp;lt;resource-env-ref-name&amp;gt;jms/StockQueue&amp;lt;/resource-env-ref-name&amp;gt; &amp;lt;resource-env-ref-type&amp;gt;javax.jms.Queue&amp;lt;/resource-env-ref-type&amp;gt; &amp;lt;/resource-env-ref&amp;gt; &amp;lt;/web-app&amp;gt; some confusing tags: &amp;lt;resource-ref&amp;gt; &amp;lt;resource-env-ref&amp;gt;
ServletContext, ServletConfig Basically, ServletContext defines a set of methods that a servlet uses to communicate with its servlet container.
There is one context per &amp;ldquo;web application&amp;rdquo; per Java Virtual Machine. (A web application&amp;rdquo; is a collection of servlets and content installed under a specific subset of the server&amp;rsquo;s URL namespace such as /catalog and possibly installed via a .war file.)
ServletConfig is used to pass parameters to a servlet during initialization.
its methods include:
getServletName(); getServletContext(); getInitParameter(String name); getInitParameterNames(); GenericServlet has implemented ServletConfig interface.
thread safe consideration Generally, a typical servlet lifecyle creates a single instance of a servlet class, but pools multiple threads to handle the service() method.
So the shared resources like instance variables, helpers must be coded in thread-safe manners.
forward vs. redirect RequestDispatcher.forward(&amp;hellip;), Response.sendRedirect(..)
As per what is RequestDespatcher include(), now look at the following test:
public class DispatcherServlet extends HttpServlet { private static final long serialVersionUID = 1L; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { PrintWriter out = response.getWriter(); out.println(&amp;#34;In dispatcherServlet &amp;lt;BR&amp;gt;&amp;#34;); RequestDispatcher rd = request.getRequestDispatcher(&amp;#34;Hello.jsp&amp;#34;); rd.include(request, response); } } &amp;nbsp;
&amp;lt;%@ page language=&amp;#34;java&amp;#34; contentType=&amp;#34;text/html; charset=ISO-8859-1&amp;#34; pageEncoding=&amp;#34;ISO-8859-1&amp;#34;%&amp;gt; &amp;lt;!DOCTYPE html PUBLIC &amp;#34;-//W3C//DTD HTML 4.01 Transitional//EN&amp;#34; &amp;#34;http://www.w3.org/TR/html4/loose.dtd&amp;#34;&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta http-equiv=&amp;#34;Content-Type&amp;#34; content=&amp;#34;text/html; charset=ISO-8859-1&amp;#34;&amp;gt; &amp;lt;title&amp;gt;Insert title here&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; Hello page. &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; Now the output is:
In dispatcherServlet Hello page Here we are not hard to know its accurate meaning - including and merging the response content of another servlet, JSP or static resources.
JNDI declaration tags We usually use &amp;lt;resource-ref&amp;gt; for DataSource declaration, but there&amp;rsquo;re also other JNDI object declarations which can be used in servlet application.
&amp;lt;env-entry&amp;gt;, &amp;lt;resource-ref&amp;gt; and &amp;lt;resource-env-ref&amp;gt; * **env-entry** - Environment entry, a single-value parameter that can be used to configure how the application will operate. An example [here](http://www.cs-repository.info/2014/04/bind-and-lookup-wrapper-objects-using.html) * **resource-ref** - Resource reference, which is typically to an object factory for resources such as a JDBC DataSource, a JavaMail Session, or custom object factories configured into Tomcat. An example [here](http://www.cs-repository.info/2014/04/using-jndi-lookup-for-datasource-objects.html) * **resource-env-ref** - Resource environment reference, a new variation of resource-ref added in Servlet 2.4 that is simpler to configure for resources that do not require authentication information. An example[here ](http://www.cs-repository.info/2014/04/bind-and-lookup-beans-using-resource_1.html)and [here](http://www.cs-repository.info/2014/04/bind-and-lookup-beans-using-resource.html).  Environment Entries For parameter values that may need to change during deployment, it&amp;rsquo;s better to use environment entries instead, as indicated by the &amp;amp;lt;env-entry&amp;amp;gt; tag.
&amp;lt;env-entry&amp;gt; &amp;lt;description&amp;gt;Send pincode by mail&amp;lt;/description&amp;gt; &amp;lt;env-entry-name&amp;gt;mailPincode&amp;lt;/env-entry-name&amp;gt; &amp;lt;env-entry-value&amp;gt;false&amp;lt;/env-entry-value&amp;gt; &amp;lt;env-entry-type&amp;gt;java.lang.Boolean&amp;lt;/env-entry-type&amp;gt; &amp;lt;/env-entry&amp;gt; This is a good way for environment-specific application variables. The type may be a String, Byte, Short, Integer, Long, Boolean, Double, or Float (all with their full java.lang qualification).
Java code can retrieve the &amp;amp;lt;env-entry&amp;amp;gt; values using JNDI:
Context initCtx = new InitialContext( ); Boolean mailPincode = (Boolean) initCtx.lookup(&amp;#34;java:comp/env/mailPincode&amp;#34;); Now you could change the variable value in deployment time:
References to External Resource Manager Connection Factories When the environment entry is a resource factory, there&amp;rsquo;s a &amp;amp;lt;resource-ref&amp;amp;gt; tag to use. A factory is an object that creates other objects on demand. A resource factory creates resource objects, such as database connections or message queues.
&amp;lt;!-- JDBC DataSources (java:comp/env/jdbc) --&amp;gt; &amp;lt;resource-ref&amp;gt; &amp;lt;description&amp;gt;The default DS&amp;lt;/description&amp;gt; &amp;lt;res-ref-name&amp;gt;jdbc/DefaultDS&amp;lt;/res-ref-name&amp;gt; &amp;lt;res-type&amp;gt;javax.sql.DataSource&amp;lt;/res-type&amp;gt; &amp;lt;res-auth&amp;gt;Container&amp;lt;/res-auth&amp;gt; &amp;lt;/resource-ref&amp;gt; &amp;lt;!-- JavaMail Connection Factories (java:comp/env/mail) --&amp;gt; &amp;lt;resource-ref&amp;gt; &amp;lt;description&amp;gt;Default Mail&amp;lt;/description&amp;gt; &amp;lt;res-ref-name&amp;gt;mail/DefaultMail&amp;lt;/res-ref-name&amp;gt; &amp;lt;res-type&amp;gt;javax.mail.Session&amp;lt;/res-type&amp;gt; &amp;lt;res-auth&amp;gt;Container&amp;lt;/res-auth&amp;gt; &amp;lt;/resource-ref&amp;gt; &amp;lt;!-- JMS Connection Factories (java:comp/env/jms) --&amp;gt; &amp;lt;resource-ref&amp;gt; &amp;lt;description&amp;gt;Default QueueFactory&amp;lt;/description&amp;gt; &amp;lt;res-ref-name&amp;gt;jms/QueueFactory&amp;lt;/res-ref-name&amp;gt; &amp;lt;res-type&amp;gt;javax.jms.QueueConnectionFactory&amp;lt;/res-type&amp;gt; &amp;lt;res-auth&amp;gt;Container&amp;lt;/res-auth&amp;gt; &amp;lt;/resource-ref&amp;gt; It can have two values: CONTAINER or SERVLET. If CONTAINER is specified, the servlet container (the J2EE server) handles authentication before binding the factory to JNDI, using credentials provided by the deployer. If SERVLET is specified, the servlet must handle authentication duties programmatically.
It&amp;rsquo;s recommended but not required to place the resource factories under a subcontext that describes the resource type:
 jdbc/ for a JDBC javax.sql.DataSource factory jms/ for a JMS javax.jms.QueueConnectionFactory or javax.jms.TopicConnectionFactory mail/ for a JavaMail javax.mail.Session factory url/ for a java.net.URL factory  References to Administered Objects &amp;lt;resource-env-ref&amp;gt; &amp;lt;description&amp;gt;This is a reference to a JMS queue&amp;lt;/description&amp;gt; &amp;lt;resource-env-ref-name&amp;gt;jms/myqueue&amp;lt;/resource-env-ref-name&amp;gt; &amp;lt;resource-env-ref-type&amp;gt;javax.jms.Queue&amp;lt;/resource-env-ref-type&amp;gt; &amp;lt;/resource-env-ref&amp;gt; References to EJB Components &amp;lt;ejb-ref&amp;gt; &amp;lt;description&amp;gt;Cruise ship cabin&amp;lt;/description&amp;gt; &amp;lt;ejb-ref-name&amp;gt;ejb/CabinHome&amp;lt;/ejb-ref-name&amp;gt; &amp;lt;ejb-ref-type&amp;gt;Entity&amp;lt;/ejb-ref-type&amp;gt; &amp;lt;home&amp;gt;com.titan.cabin.CabinHome&amp;lt;/home&amp;gt; &amp;lt;remote&amp;gt;com.titan.cabin.Cabin&amp;lt;/remote&amp;gt; &amp;lt;/ejb-ref&amp;gt; &amp;nbsp;
</content>
    </entry>
    
     <entry>
        <title>GoF Creational Patterns: Singleton, Factory, Factory Method, Abstract Factory</title>
        <url>http://yangchao.me/post/gof-creational-patterns-singleton-factory-factory-method-abstract-factory/</url>
        <categories>
          <category>Design Patterns</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html">  Now, ultimately we start discussing design patterns - really buzzwords.
Singleton Singleton pattern is to ensure the unique instance of some class in a JVM.
class LazySingleton { private static LazySingleton instance; private LazySingleton() { } public static LazySingleton getInstance() { if (instance == null) { instance = new LazySingleton(); } return instance; } public void doSomething() { System.out.println(&amp;#34;doSomething(): Singleton does something!&amp;#34;); } } // DCL for thread safe class DoubleCheckedLockingLazySingleton { private static DoubleCheckedLockingLazySingleton instance; private DoubleCheckedLockingLazySingleton() { System.out.println(&amp;#34;Singleton(): Initializing Instance&amp;#34;); } public static DoubleCheckedLockingLazySingleton getInstance() { if (instance == null) { synchronized (DoubleCheckedLockingLazySingleton.class) { if (instance == null) { System.out.println(&amp;#34;getInstance(): First time getInstance was invoked!&amp;#34;); instance = new DoubleCheckedLockingLazySingleton(); } } } return instance; } public void doSomething() { System.out.println(&amp;#34;doSomething(): Singleton does something!&amp;#34;); } } class EagerSingleton { private final static EagerSingleton instance = new EagerSingleton(); private EagerSingleton() { System.out.println(&amp;#34;Singleton(): Initializing Instance&amp;#34;); } public static EagerSingleton getInstance() { return instance; } public void doSomething() { System.out.println(&amp;#34;doSomething(): Singleton does something!&amp;#34;); } } You can see there is a DCL(Double-checked-Locking) implementation for lazy initialization. But this clever-seeming may not work. Please refer to Double-checked locking: Clever, but broken
Factory Factory pattern is very easy to understand.
classic factory  interface Product {} class ConcreteProduct implements Product { } class SimpleFactory { public static Product createProduct() { Product product = new ConcreteProduct(); // do other tasks for initialization  return product; } } conditional switch factory class AnotherConcreteProduct implements Product {} class ConditionalFactory { public static Product createProduct(String productId) { Product product = null; if (&amp;#34;concreteProduct&amp;#34;.equals(productId)) { product = new ConcreteProduct(); } if (&amp;#34;anotherConcreteProduct&amp;#34;.equals(productId)) { product = new AnotherConcreteProduct(); } // do other tasks for initialization  return product; } } class registry factory class ProductClassRegistryFactory { private HashMap&amp;lt;String, Class&amp;lt;Product&amp;gt;&amp;gt; registry = new HashMap(); public void registerProduct(String productID, Class productClass) { registry.put(productID, productClass); } public Product createProduct(String productID) throws Exception { Class clazz = (Class) registry.get(productID); Constructor productConstructor = clazz.getDeclaredConstructor(new Class[]{String.class}); return (Product) productConstructor.newInstance(new Object[]{}); } } instance registry factory // For registeration on its own abstract class SelfRegisterableProduct implements Product { public abstract Product createProduct(); } class OneProduct implements Product { static { new ProductRegistryFactory().registerProduct(&amp;#34;ID1&amp;#34;, new OneProduct()); } public OneProduct createProduct() { return new OneProduct(); } } class ProductRegistryFactory { private HashMap&amp;lt;String, Product&amp;gt; registry = new HashMap(); public void registerProduct(String productID, Product p) { registry.put(productID, p); } public Product createProduct(String productID) { return ((SelfRegisterableProduct) registry.get(productID)).createProduct(); } } Factory Method Factory method is really no difference as a variant of factory pattern. It makes the factory as abstract class instead of implementing the creation logic in itself.
A concrete factory is responsible for a kind of concrete product.
Abstract Factory Simply speaking, abstract factory is responsible for the creation of a family of products. So it provides multiple methods to create several related products of different types.
</content>
    </entry>
    
     <entry>
        <title>Generics revisit</title>
        <url>http://yangchao.me/post/generics-revisit/</url>
        <categories>
          <category>Generics</category>
        </categories>
        <tags>
          <tag>TODO</tag>
        </tags>
        <content type="html">  Generics is an important feature since JDK 1.5
subtyping and wildcards   Integer is a subtype of Number   Double is a subtype of Number   ArrayList&amp;lt;E&amp;gt; is a subtype of List&amp;lt;E&amp;gt;   List&amp;lt;E&amp;gt; is a subtype of Collection&amp;lt;E&amp;gt;   Collection&amp;lt;E&amp;gt; is a subtype of Iterable&amp;lt;E&amp;gt;   Long[] is a subtype of Number[]   List&amp;lt;Integer&amp;gt; is NOT a subtype of List&amp;lt;Number&amp;gt;    In Java, array subtyping is covariant, meaning that type S[] is considered to be a subtype of T[] whenever S is a subtype of T.
In contrast, the subtyping relation for generics is invariant, meaning that type List&amp;lt;S&amp;gt; is _not _considered to be a subtype of List&amp;lt;T&amp;gt;, except in the trivial case where S and T are identical.
So now it&amp;rsquo;s what the wildcards for.
 Wildcards reintroduce covariant subtyping for generics, in that type List&amp;lt;S&amp;gt; _is _considered to be a subtype of List&amp;lt;? extends T&amp;gt; when S is a subtype of T. Wildcards also introduce _contravariant _subtyping for generics, in that type List&amp;lt;S&amp;gt; is considered to be a _subtype _of List&amp;lt;? super T&amp;gt; when S is a _supertype _of T.  List&amp;lt;? extends Number&amp;gt; list = new ArrayList&amp;lt;Integer&amp;gt;; The question mark is called a wildcard, since it stands for some type that is a subtype of E.
&amp;nbsp;
You can always consider the generic class with wildcard as a family of generic classes.
For example,
Collection&amp;lt;? extends Fruit&amp;gt; is a family of generic classes: Collection&amp;lt;Fruit&amp;gt;, Collection&amp;lt;Apple&amp;gt;, Collection&amp;lt;Orange&amp;gt;&amp;hellip;
Collection&amp;lt;? super Apple&amp;gt; is a family of generic classes: Collection&amp;lt;Apple&amp;gt;, Collection&amp;lt;Fruit&amp;gt;, Collection&amp;lt;Plant&amp;gt;&amp;hellip;
Get and Put principal Some tutorals said: &amp;gt; The Get and Put Principle: use an extends wildcard when you only _get _values out of a structure, use a super wildcard when you only _put _values into a structure, and don’t use a wildcard when you _both _get and put. I think this has a little flaw. Actually, get and put is just a too vague expression. For instance, the remove() method of List interface is get or set?
So more general means is by using reasoning.
public class GenericClass&amp;lt;T&amp;gt; { public T foo() { return null; } public void bar(T a) {} public static void main() { GenericClass&amp;lt;? extends Fruit&amp;gt; g1 = new GenericClass&amp;lt;Fruit&amp;gt;(); Fruit fruit = g1.foo(); Plant plant = g1.foo(); Creature creature = g1.foo(); GenericClass&amp;lt;? super Fruit&amp;gt; g2 = new GenericClass&amp;lt;Fruit&amp;gt;(); g2.bar(new Fruit()); g2.bar(new Apple()); g2.bar(new RoyalGala()); } } class Creature {} class Plant extends Creature {} class Fruit extends Plant {} class Apple extends Fruit {} class RoyalGala extends Apple {} In the above code, we have a deep hierarchy. But all the rule is based on this:
 &amp;lt;? extend Fruit&amp;gt; means it is some fruit sub type, maybe Fruit, Apple or RoyalGala. &amp;lt;? super Fruit&amp;gt; means it is some fruit super type, maybe Fruit, Plant or Creature.  &amp;lt;? extends Fruit&amp;gt; a = ...; Apple aa = a; // wrong, if a is really a fruit? downcast failed RoyalGala aaa = a; // wrong, if a is really a apple? downcast failed Fruit aa = a; // ok, whatever a is fruit, apple or royal gala. Plant aaa = a; // ok, whatever a is fruit, apple or royal gala. Creature aaaa = a; // ok, whatever a is fruit, apple or royal gala.  &amp;lt;? super Fruit&amp;gt; b = ...; b = new Plant(); // wrong, if b is really a fruit? downcast failed b = new Creature(); // wrong, if b is really a plant? downcast failed b = new Fruit(); // ok, whatever b is fruit, plant or royal gala. b = new Apple(); // ok, whatever b is fruit, plant or royal gala. b = new RoyalGala(); // ok, whatever b is fruit, apple or royal gala. From the above pseudo code, we know how the compiler do reasoning. As per uncertain things the compiler cannot ensure, the compilation will fail naturally.
So for g1.foo(), compiler infer to return &amp;lt;? extends Fruit&amp;gt; type, but this is just a parameterize type, which cannot exist standalone. But the compiler can ensure the assignment to Fruit/Plant/Creature variable is safe.
That&amp;rsquo;s it!
wildcard capture //todo
constraints on wildcards  instance creation  List&amp;lt;?&amp;gt; list = new ArrayList&amp;lt;?&amp;gt;(); // compile-time error Map&amp;lt;String, ? extends Number&amp;gt; map = new HashMap&amp;lt;String, ? extends Number&amp;gt;(); // compile-time error &amp;nbsp;
 generic method calls  List&amp;lt;?&amp;gt; list = Lists.&amp;lt;?&amp;gt;factory(); // compile-time error bounds &amp;nbsp;
bridge method </content>
    </entry>
    
     <entry>
        <title>widen cast vs. narrow cast</title>
        <url>http://yangchao.me/post/widen-cast-vs-narrow-cast/</url>
        <categories>
          <category>Basics</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html"> </content>
    </entry>
    
     <entry>
        <title>String class, text formatting</title>
        <url>http://yangchao.me/post/string-class-text-formatting/</url>
        <categories>
          <category>Basics</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html">  working with String class String is most frequently used class in Java.
immutable and flyweight design String is immutable
String is designed with the Flyweight design pattern. A pool of Strings is maintained by the String class.
pool of Strings and intern() You can always get the string in the pool by invoking intern().
For any two Strings s1 &amp;amp; s2, _s1.intern( ) _== _s2.intern( ) _only if _s1.equals(s2) _is true.
All literal strings and string-valued constant expressions are interned.
For more details about intern(), please refer to http://java-performance.info/string-intern-in-java-6-7-8/
stings concatenation  Use plus (“&#43;”) operator for concatenating constants. Use _concat( ) _method for concatenating 2 string variables. Use _StringBuilder _or _StringBuffer _for concatenating a number of _String _variables, and most importantly in loops. Prefer _StringBuilder _to _StringBuffer _unless multiple threads can have access to it. Notice: Plus operator is more efficient than the other two as the JVM optimizes constants.  Text formatting In Java, it&amp;rsquo;s convenient to format something as text representations.
printf-style formatting This is supported by java.util.Formatter class.
Some class uses this Formatter indirectly:
System.out.printf(String, Object...) String.format(String, Object...) java.text.Format family Format
|&amp;mdash; NumberFormat
|&amp;mdash; ChoiceFormat
|&amp;mdash; DecimalFormat
|&amp;mdash; DateFormat
|&amp;mdash; SimpleDateFormat
|&amp;mdash; MessageFormat
</content>
    </entry>
    
     <entry>
        <title>cloning objects</title>
        <url>http://yangchao.me/post/cloning-objects/</url>
        <categories>
          <category>Basics</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html">  Java has built-in support for shadow copy by Object.clone() and Cloneable interface.
shadow copy This is default implementation in java.
Object class has a method named clone(), but if we&amp;rsquo;d like to succeed with this built-in cloning capability, we need to use Cloneable marker interface.
The method performs a specific cloning operation. If the class of this object does not implement the interface, then a CloneNotSupportedException is thrown.
Note that all arrays are considered to implement the interface Cloneable.
By default, java cloning is ‘field by field copy’ i.e. as the Object class does not have idea about the structure of class on which clone() method will be invoked. So, JVM when called for cloning, do following things:
1) If the class has only primitive data type members then a completely new copy of the object will be created and the reference to the new object copy will be returned.
2) If the class contains members of any class type then only the object references to those members are copied and hence the member references in both the original object as well as the cloned object refer to the same object.
package basics; import org.junit.Test; import static org.junit.Assert.*; public class Clones { @Test public void testClone() throws Exception { Employee emp = new Employee(1, &amp;#34;Jack&amp;#34;, new Department(2, &amp;#34;HR&amp;#34;)); Employee clone = (Employee)emp.clone(); assertTrue(emp.empoyeeId == clone.empoyeeId); // true  assertTrue(emp.employeeName == clone.employeeName); // true  assertTrue(emp.department == clone.department); // true  Department dept = new Department(1, &amp;#34;IT&amp;#34;); // throw CloneNotSupportedException, as Department hasn&amp;#39;t implement Cloneable  Department deptClone = (Department)dept.clone(); } } class Employee implements Cloneable{ protected int empoyeeId; protected String employeeName; protected Department department; public Employee(int id, String name, Department dept) { this.empoyeeId = id; this.employeeName = name; this.department = dept; } @Override protected Object clone() throws CloneNotSupportedException { return super.clone(); } //Accessor/mutators methods will go there } class Department { protected int id; protected String name; public Department(int id, String name) { this.id = id; this.name = name; } //Accessor/mutators methods will go there  @Override protected Object clone() throws CloneNotSupportedException { return super.clone(); } } deep copy In most of time, default clone mechanism is enough for us. But in some special case, we need real deep copy.
There are several method you can achieve this aim.
overriding clone() method and write your own //Modified clone() method in Employee class @Override protected Object clone() throws CloneNotSupportedException { Employee cloned = (Employee)super.clone(); cloned.setDepartment((Department)cloned.getDepartment().clone()); return cloned; } in-memory serialization This method is for Serializable object.
public static T cloneThroughSerialize(T t) throws Exception { ByteArrayOutputStream bos = new ByteArrayOutputStream(); serializeToOutputStream(t, bos); byte[] bytes = bos.toByteArray(); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bytes)); return (T)ois.readObject(); } private static void serializeToOutputStream(Serializable ser, OutputStream os) throws IOException { ObjectOutputStream oos = null; try { oos = new ObjectOutputStream(os); oos.writeObject(ser); oos.flush(); } finally { oos.close(); } } // using our custom method Object cloned = cloneThroughSerialize (someObject); // or with Apache Commons cloned = org.apache.commons.lang. SerializationUtils.clone(someObject); options for non Serializable object But what if the class we want to clone isn’t Serializable and we have no control over the source code or can’t make it Serializable?
Option 1 – Java Deep Cloning Library
There’s a nice little library which can deep clone virtually any Java Object – cloning. It takes advantage of Java’s excellent reflection capabilities to provide optimized deep-cloned versions of objects. Cloner cloner=new Cloner(); Object cloned = cloner.deepClone(someObject); Option 2 – JSON Cloning
This is very useful and straightforward, especially now JDK 7 has the out-of-the-box JSON library support - Java API for JSON Processing (JSR 353) .
&amp;nbsp;
  
</content>
    </entry>
    
     <entry>
        <title>java modifiers revisit</title>
        <url>http://yangchao.me/post/java-modifiers-revist/</url>
        <categories>
          <category>Basics</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html">  acess control modifiers In Java, there are four different types of access modifiers for fields and methods:
 public: every class can access the element protected: only subclasses and classes in the same package can access the element default: only classes in the same package can access the element private: only this class can access the element  what does accessing mean? Accessing means you can refer. As in java only class can be the top-level element, thus top-level class access just use its name without a prefix. But for other enclosed elements like fields(instance or class), methods(instance or class), inner classes(member, local or anonymous class), nested classes/interfaces, you must access them with a prefix(class name or instance name) explicitly or implicitly if possible.
where does accessing happen? Many places are where accessing happen, including instance field assignments, intialization blocks, static field assignments, static intialization blocks, instance methods, static methods(class methods), inner class definition body, nested class definition body&amp;hellip;
package accessing.somepackage; public class BaseClass { private int private_instance_field = 1; long package_instance_field = 2l; protected double protected_instance_field = 2.0; public String public_instance_field = &amp;#34;d&amp;#34;; private void private_instance_method() {} void package_instance_method() {} protected void protected_instance_method() {} public void public_instance_method() {} private static int private_class_field = 1; static long package_class_field = 2l; protected static double protected_class_field = 3.0; public static String public_class_field = &amp;#34;h&amp;#34;; private static void private_class_method() {} static void package_class_method() {} protected static void protected_class_method() {} public static void public_class_method() {} private class Private_instance_inner_class_A {} class Package_instance_inner_class_B {} protected class Protected_instance_inner_class_C {} public class Public_instance_inner_class_D {} private static class Private_class_nested_class_A {} static class Package_class_nested_class_B {} protected static class Protected_class_nested_class_C {} public static class Public_class_nested_class_D {} public void testAccessInInstanceMethod() { Object o = null; o = BaseClass.private_class_field; o = BaseClass.package_class_field; o = BaseClass.protected_class_field; o = BaseClass.public_class_field; BaseClass.private_class_method(); BaseClass.package_class_method(); BaseClass.protected_class_method(); BaseClass.public_class_method(); Private_instance_inner_class_A a = null; Package_instance_inner_class_B b = null; Protected_instance_inner_class_C c = null; Public_instance_inner_class_D d = null; Package_class_nested_class_B aa = null; Package_class_nested_class_B bb = null; Protected_class_nested_class_C cc = null; Public_class_nested_class_D dd = null; //////////////////////////////////////////  BaseClass base = new BaseClass(); o = base.private_instance_field; o = base.package_instance_field; o = base.protected_instance_field; o = base.public_instance_field; base.private_instance_method(); base.package_instance_method(); base.protected_instance_method(); base.public_instance_method(); o = base.private_class_field; o = base.package_class_field; o = base.protected_class_field; o = base.public_class_field; base.private_class_method(); base.package_class_method(); base.protected_class_method(); base.public_class_method(); ///////////////////////////////  o = this.private_instance_field; o = this.package_instance_field; o = this.protected_instance_field; o = this.public_instance_field; this.private_instance_method(); this.package_instance_method(); this.protected_instance_method(); this.public_instance_method(); o = this.private_class_field; o = this.package_class_field; o = this.protected_class_field; o = this.public_class_field; this.private_class_method(); this.package_class_method(); this.protected_class_method(); this.public_class_method(); Private_instance_inner_class_A aaa = null; Package_instance_inner_class_B bbb = null; Protected_instance_inner_class_C ccc = null; Public_instance_inner_class_D ddd = null; Private_class_nested_class_A aaaa = null; Package_class_nested_class_B bbbb = null; Protected_class_nested_class_C cccc = null; Public_class_nested_class_D dddd = null; } public static void testAccessInClassMethod() { Object o = null; o = BaseClass.private_class_field; o = BaseClass.package_class_field; o = BaseClass.protected_class_field; o = BaseClass.public_class_field; BaseClass.private_class_method(); BaseClass.package_class_method(); BaseClass.protected_class_method(); BaseClass.public_class_method(); Private_instance_inner_class_A a = null; Package_instance_inner_class_B b = null; Protected_instance_inner_class_C c = null; Public_instance_inner_class_D d = null; Package_class_nested_class_B aa = null; Package_class_nested_class_B bb = null; Protected_class_nested_class_C cc = null; Public_class_nested_class_D dd = null; //////////////////////////////////////////  BaseClass base = new BaseClass(); o = base.private_instance_field; o = base.package_instance_field; o = base.protected_instance_field; o = base.public_instance_field; base.private_instance_method(); base.package_instance_method(); base.protected_instance_method(); base.public_instance_method(); o = base.private_class_field; o = base.package_class_field; o = base.protected_class_field; o = base.public_class_field; base.private_class_method(); base.package_class_method(); base.protected_class_method(); base.public_class_method(); //////////////////////////////////////////  o = private_class_field; o = package_class_field; o = protected_class_field; o = public_class_field; private_class_method(); package_class_method(); protected_class_method(); public_class_method(); Private_instance_inner_class_A aaa = null; Package_instance_inner_class_B bbb = null; Protected_instance_inner_class_C ccc = null; Public_instance_inner_class_D ddd = null; Private_class_nested_class_A aaaa = null; Package_class_nested_class_B bbbb = null; Protected_class_nested_class_C cccc = null; Public_class_nested_class_D dddd = null; } } &amp;nbsp;
package accessing.somepackage; public class PackageClass { public void testAccessInInstanceMethod() { Object o = null; o = BaseClass.package_class_field; o = BaseClass.protected_class_field; o = BaseClass.public_class_field; BaseClass.package_class_method(); BaseClass.protected_class_method(); BaseClass.public_class_method(); BaseClass.Package_instance_inner_class_B b = null; BaseClass.Protected_instance_inner_class_C c = null; BaseClass.Public_instance_inner_class_D d = null; BaseClass.Package_class_nested_class_B bb = null; BaseClass.Protected_class_nested_class_C cc = null; BaseClass.Public_class_nested_class_D dd = null; //////////////////////////////////////////  BaseClass base = new BaseClass(); o = base.package_instance_field; o = base.protected_instance_field; o = base.public_instance_field; base.package_instance_method(); base.protected_instance_method(); base.public_instance_method(); o = base.package_class_field; o = base.protected_class_field; o = base.public_class_field; base.package_class_method(); base.protected_class_method(); base.public_class_method(); } public static void testAccessInClassMethod() { Object o = null; o = BaseClass.package_class_field; o = BaseClass.protected_class_field; o = BaseClass.public_class_field; BaseClass.package_class_method(); BaseClass.protected_class_method(); BaseClass.public_class_method(); BaseClass.Package_instance_inner_class_B b = null; BaseClass.Protected_instance_inner_class_C c = null; BaseClass.Public_instance_inner_class_D d = null; BaseClass.Package_class_nested_class_B bb = null; BaseClass.Protected_class_nested_class_C cc = null; BaseClass.Public_class_nested_class_D dd = null; //////////////////////////////////////////  BaseClass base = new BaseClass(); o = base.package_instance_field; o = base.protected_instance_field; o = base.public_instance_field; base.package_instance_method(); base.protected_instance_method(); base.public_instance_method(); o = base.package_class_field; o = base.protected_class_field; o = base.public_class_field; base.package_class_method(); base.protected_class_method(); base.public_class_method(); } } &amp;nbsp;
package accessing; import accessing.somepackage.BaseClass; public class InheritedClass extends BaseClass { public void testAccessInInstanceMethod() { Object o = null; o = BaseClass.protected_class_field; o = BaseClass.public_class_field; BaseClass.protected_class_method(); BaseClass.public_class_method(); Protected_instance_inner_class_C c = null; Public_instance_inner_class_D d = null; Protected_class_nested_class_C cc = null; Public_class_nested_class_D dd = null; //////////////////////////////////////////  BaseClass base = new BaseClass(); // o = base.protected_instance_field;  o = base.public_instance_field; // base.protected_instance_method();  base.public_instance_method(); o = base.protected_class_field; o = base.public_class_field; base.protected_class_method(); base.public_class_method(); //////////////////////////////////////////  o = this.protected_instance_field; o = this.public_instance_field; this.protected_instance_method(); this.public_instance_method(); o = this.protected_class_field; o = this.public_class_field; this.protected_class_method(); this.public_class_method(); Protected_instance_inner_class_C ccc = null; Public_instance_inner_class_D ddd = null; Protected_class_nested_class_C cccc = null; Public_class_nested_class_D dddd = null; } public static void testAccessInClassMethod() { Object o = null; o = BaseClass.protected_class_field; o = BaseClass.public_class_field; BaseClass.protected_class_method(); BaseClass.public_class_method(); Protected_instance_inner_class_C c = null; Public_instance_inner_class_D d = null; Protected_class_nested_class_C cc = null; Public_class_nested_class_D dd = null; //////////////////////////////////////////  BaseClass base = new BaseClass(); // o = base.protected_instance_field;  o = base.public_instance_field; // base.protected_instance_method();  base.public_instance_method(); o = base.protected_class_field; o = base.public_class_field; base.protected_class_method(); base.public_class_method(); //////////////////////////////////////////  o = protected_class_field; o = public_class_field; protected_class_method(); public_class_method(); Protected_instance_inner_class_C ccc = null; Public_instance_inner_class_D ddd = null; Protected_class_nested_class_C cccc = null; Public_class_nested_class_D dddd = null; } } &amp;nbsp;
package accessing; import basics.accessing.somepackage.BaseClass; public class AnyClass { public void testAccessInInstanceMethod() { Object o = null; o = BaseClass.public_class_field; BaseClass.public_class_method(); BaseClass.Public_instance_inner_class_D d = null; BaseClass.Public_class_nested_class_D dd = null; //////////////////////////////////////////  BaseClass base = new BaseClass(); o = base.public_instance_field; base.public_instance_method(); o = base.public_class_field; base.public_class_method(); } public static void testAccessInClassMethod() { Object o = null; o = BaseClass.public_class_field; BaseClass.public_class_method(); BaseClass.Public_instance_inner_class_D d = null; BaseClass.Public_class_nested_class_D dd = null; //////////////////////////////////////////  BaseClass base = new BaseClass(); o = base.public_instance_field; base.public_instance_method(); o = base.public_class_field; base.public_class_method(); } } a pitfall for protected access A point that is worth noticing is the Line 21, 23, 66 and 68 of InheritedClass.
But why?
As always, this is covered in the JLS, 6.6.2: &amp;gt; A protected member or constructor of an object may be accessed from outside the package in which it is declared only by code that is responsible for the implementation of that object. That means you can only access the protected member by using _this _or super.
static modifier We can use static for non top-level class (inner classes or nested class), class methods, class variables.
abstract / final modifiers abstract / final is mutually exclusive. This means we cannot use them at the same time.    class method variable   abstract 
 intend to inherit it, overriding implemented methods or completing the unimplemented methods include &amp;gt;=0 abstract methods cannot be initialized  
 declare an unimplemented method without body
 the class it defines in must be also abstract  n/a   final intend to not inherit it intend to not override it cannot be changed after initialization   
  other modifiers: _synchronized, _volatile, transient  synchronized can be used before instance/class methods or blocks for synchronization semantics. volatile can be used before instance/class variables for atomicity and visibility purpose. transient can be used before instance variables for marking the fields as non-serialization ones.  combination of modifiers &amp;nbsp;      abstract final   top level class public/package public/package abstract public/package final   instance method public/protected/package/private public/protected/package abstract public/protected/package/private final  class method public/protected/package/private static  public/protected/package/private static final   instance variable public/protected/package/private  public/protected/package/private final  class variable public/protected/package/private static  public/protected/package/private static final   local variable   final   inner class public/protected/package/private public/protected/package/private abstract public/protected/package/private final   local class  abstract final   anonymous &amp;lt;local&amp;gt; class     nested class public/protected/package/private static public/protected/package/private static abstract public/protected/package/private static final   interface public/package public/package &amp;lt;abstract&amp;gt;   nested interface public/protected/package/private public/protected/package/private &amp;lt;static&amp;gt; &amp;lt;abstract&amp;gt;     &amp;gt; NOTICE: &amp;lt;&amp;hellip;&amp;gt; represents this is default modifier implicitly.
</content>
    </entry>
    
     <entry>
        <title>wordpress ssh update not working</title>
        <url>http://yangchao.me/post/wordpress-ssh-update-not-working/</url>
        <categories>
          <category>PHP</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html"> chown -R www-data:www-data *
</content>
    </entry>
    
     <entry>
        <title>Overriding vs. hiding(aka. shadowing)</title>
        <url>http://yangchao.me/post/overriding-vs-hidingaka-shadowing/</url>
        <categories>
          <category>OOP</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html">  Simply speaking, overriding is for member methods, while hiding is for fields and static methods.
Override Override is the feature of dynamic binding or run-time polymorphism.
It&amp;rsquo;s necessary for overriding that the method of subclasses has the same method signature as that of its super class.
&amp;ldquo;Same&amp;rdquo; means the number and types of the method argument list must be the same. But the return type is not necessary the same. You can use the more concrete type as the return type, like its sub types.
As per the access modifier, you can use the less restrictive access (stronger) modifier &amp;mdash; (increase visibility). &amp;gt; stronger-&amp;gt; weaker: public &amp;gt; protected &amp;gt; package-default &amp;gt; private For more access modifier details, refer to java modifiers review
For instance:
 if the to-be-overridden method is package, you can make it package/protected/public accessible in the sub classes. if the to-be-overridden method is protected, you can make it protected/public accessible in the sub classes. if the to-be-overridden method is public, you can only make it public accessible in the sub classes.   Access modifier in super class method Allowed access modifier for overriding   private private, package, protected, public   package package, protected, public   protected protected, public   public public    As per the exception throwing, you can reduce the checked exceptions throwings, but no matter the runtime exceptions.  All the rules concerning the access modifier and exception throwing, it&amp;rsquo;s easy to understand because you must maintain the contract given by the parent class.
class Animal { void drink() {} protected Number eat(Food food) { return 1; } } class Horse extends Animal { @Override protected void drink() {} @Override protected Integer eat(Food food) { return 2; } protected Number eat(Grass food) { // override failed  return 2; } } class Food {} class Grass extends Food {} For more complicated overriding example, refer to override - a pitfall
Hiding Hiding/shadowing is another type of static binding or compile-time polymophism.
variable shadowing When both a parent class and its sub class have a field with the same name, this technique is called variable shadowing.
public class Hiding { @Test public void testVariableShadowing() { Animal animal = new Cat(); Cat cat = new Cat(); System.out.println(animal.name); System.out.println(cat.name); System.out.println(((Cat)animal).name); System.out.println(((Animal)cat).name); System.out.println(animal.getName()); System.out.println(cat.getName()); } } abstract class Animal { String name = &amp;#34;animal&amp;#34;; public String getName() { return this.name; } } class Cat extends Animal { String name = &amp;#34;Cat&amp;#34;; public String getName() { return this.name; } } Output: animal Cat Cat animal Cat Cat
Static variable is similar as per hiding.
public class OverridingHiding { @Test public void testStaticVariableHiding() { Animal animal = new Cat(); Cat cat = new Cat(); System.out.println(animal.name); System.out.println(cat.name); } } class Animal { static String name = &amp;#34;Animal&amp;#34;; } class Cat extends Animal { static String name = &amp;#34;Cat&amp;#34;; } Output: Animal Cat
static method hiding When both a parent class and its sub class have a static method with the same signature, this technique is called static method hiding.
public class Hiding { @Test public void testStaticMethodHiding() { Animal animal = new Cat(); Cat cat = new Cat(); System.out.println(animal.who()); System.out.println(cat.who()); } } abstract class Animal { static String who() { return &amp;#34;Animal&amp;#34;; } } class Cat extends Animal { static String who() { return &amp;#34;Cat&amp;#34;; } } Output: Animal Cat
</content>
    </entry>
    
     <entry>
        <title>finalize()</title>
        <url>http://yangchao.me/post/finalize/</url>
        <categories>
          <category>Basics</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html"> finalize() method is a protected method of Object class. It&amp;rsquo;s intended to be invoked by GC thread before GC reclaim the memory allocated to the object.
Misguidingly it&amp;rsquo;s regarded as a place for doing some cleaning works, like releasing resources.
But this is NOT recommended!!
As we cannot know when GC do the thing, so we do some cleaning work becomes not guaranteed at all and uncertain.
Other drawbacks:
1) exceptions thrown in the finalize() method will be ignored by the GC thread and will not be propagated further. This is pretty bad, we cannot know what happened and no log left for error handling.
2) Not like the constructor invoking the constructor of its super classes implicitly, you should invoke super class&amp;rsquo;s finalize() explicitly.
Runtime has some methods to make best efforts to do something.
 System.gc() &amp;mdash; this is a shortcut of Runtime.getRuntime().gc() Runtime.getRuntime().runFinalization() Runtime.runFinalizersOnExit(true)  this method is deprecated because of being unsafe “This method is inherently unsafe. It may result in finalizers being called on live objects while other threads are concurrently manipulating those objects, resulting in erratic behavior or deadlock.”  class ObjectWithFinalizer { protected void finalized() throws Throwable { try { System.out.println(&amp;#34;finalize() invoked&amp;#34;); int i = 1 / 0; // expect to throw ArithmeticException  } finally { super.finalize(); } } public static void main(String[] args) { ObjectWithFinalizer o = new ObjectWithFinalizer(); o = null; // wish GC to reclaim the memory // System.gc();  Runtime.runFinalizersOnExit(true); } } After running the above code, we cannot see the expected result.
</content>
    </entry>
    
     <entry>
        <title>What is the exact answer, When interviewer ask Architecture of the project.</title>
        <url>http://yangchao.me/post/what-is-the-exact-answer-when-interviewer-ask-architecture-of-the-project/</url>
        <categories>
          <category>Uncategorized</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html"> Some good answers from linkedin:
What-is-exact-answer-When-
@Rick Ryker
Your (technical) interviewer is looking for the following:
1) Can you communicate confidently and effectively about the subject?
2) Can you communicate the high level relationships between different parts of the system? Or are you just throwing buzz words around? Buzz words impress recruiters but not technical interviewers. They want to know if you understand the buzz words, so they might ask you to explain your answers.
3) Does your communication reveal experience in modifying, configuring, deploying the technologies that you have shown on your resume? Or are/were you just a user of the technology stack? If so, that&amp;rsquo;s ok; most of us are. Exactly where is your experience? Do you understand what those other parts of the technology stack do for the application and the system? How do they impact how you write your code?
4) Does your answer allow the interviewer to ask deeper questions pertaining to your experience that is pertinent to the position(s) that you are being interviewed for? And/or for potential future work?
Before I get into the technical questions, I like to ask my interviewees to write a simple for loop and explain it to me as they write it and then make changes to it as instructed. You would be amazed at how hard that is for java programmers with self-reported 4-6 years experience for whom it should be second nature.
If you cannot communicate to me how you do your work during the interview, how am I going to communicate with you while we do the actual work?
</content>
    </entry>
    
     <entry>
        <title>Immutable objects</title>
        <url>http://yangchao.me/post/immutable-objects/</url>
        <categories>
          <category>Basics</category><category>Best Pricatice</category>
        </categories>
        <tags>
          <tag>Immutable</tag>
        </tags>
        <content type="html">  An immutable class is one whose state can not be changed once created. There are certain guidelines to create an class immutable. In this post, we will revisit these guidelines.
Benefits of making a class immutable Lets first identify benefits of making a class immutable. Immutable classes are
 are simple to construct, test, and use are automatically thread-safe and have no synchronization issues do not need a copy constructor do not need an implementation of clone allow hashCode to use lazy initialization, and to cache its return value do not need to be copied defensively when used as a field make good Map keys and Set elements (these objects must not change state while in the collection) have their class invariant established once upon construction, and it never needs to be checked again always have “failure atomicity” (a term used by Joshua Bloch) : if an immutable object throws an exception, it’s never left in an undesirable or indeterminate state  Guidelines to make a class immutable Java documentation itself has some guidelines identified in this link. We will understand what they mean actually:
1) Don’t provide “setter” methods — methods that modify fields or objects referred to by fields.
This principle says that for all mutable properties in your class, do not provide setter methods. Setter methods are meant to change the state of object and this is what we want to prevent here.
2) Make all fields final and private
This is another way to increase immutability. Fields declared private will not be accessible outside the class and making them final will ensure the even accidentally you can not change them.
3) Don’t allow subclasses to override methods
The simplest way to do this is to declare the class as final. Final classes in java can not be overridden.
4) Special attention when having mutable instance variables
Always remember that your instance variables will be either mutable or immutable. Identify them and return new objects with copied content for all mutable objects. Immutable variables can be returned safely without extra effort.
A more sophisticated approach is to make the constructor private and construct instances in factory methods.
A central idea of these rules is that you must ensure all the** accessible objects in the object graph** are immutable.
&amp;nbsp;
Built-in library has many immutable classes:
 String Primitive wraper classes: Byte, Character, Short, Integer, Long, Float, Double  Collections.unmodifiableList(..) like ISN&amp;rsquo;T immutable public class ImmutableTest { @Test public void testUnmodifiedCollectionImmutable(){ List&amp;lt;String&amp;gt; list=new ArrayList&amp;lt;String&amp;gt;(); list.add(&amp;#34;a&amp;#34;); list.add(&amp;#34;b&amp;#34;); list.add(&amp;#34;c&amp;#34;); System.out.println(list); List&amp;lt;String&amp;gt; unmodifiableList=Collections.unmodifiableList(list); System.out.println(unmodifiableList); List&amp;lt;String&amp;gt; unmodifiableList1=Collections.unmodifiableList(Arrays.asList(&amp;#34;a&amp;#34;,&amp;#34;b&amp;#34;,&amp;#34;c&amp;#34;)); System.out.println(unmodifiableList1); String temp=unmodifiableList.get(1); System.out.println(&amp;#34;unmodifiableList [0]：&amp;#34;&#43;temp); list.add(&amp;#34;baby&amp;#34;); System.out.println(&amp;#34;list add a item after list:&amp;#34;&#43;list); System.out.println(&amp;#34;list add a item after unmodifiableList:&amp;#34;&#43;unmodifiableList); unmodifiableList1.add(&amp;#34;bb&amp;#34;); System.out.println(&amp;#34;unmodifiableList add a item after list:&amp;#34;&#43;unmodifiableList1); unmodifiableList.add(&amp;#34;cc&amp;#34;); System.out.println(&amp;#34;unmodifiableList add a item after list:&amp;#34;&#43;unmodifiableList); } } Output: [a, b, c] [a, b, c] [a, b, c] unmodifiableList [0]：b list add a item after list:[a, b, c, baby] list add a item after unmodifiableList1:[a, b, c, baby]
From the above example, you can see unmodifiableList is not immutable. It will change if the underlying List is changed.
So the correct usage of unmodified List is like:
List list = Collections.unmodifiableList(Arrays.asList(&amp;#39;1&amp;#39;,&amp;#39;2&amp;#39;,&amp;#39;3&amp;#39;); or
List list = new ArrayList(); list.add(&amp;#34;1&amp;#34;); list.add(2); list.add(&amp;#34;333&amp;#34;); list = Collections.unmodifiableList(list); Never expose the underlying list reference to anything, so the best way is passing an argument and initialization in place.
</content>
    </entry>
    
     <entry>
        <title>String#substring(..) implementation</title>
        <url>http://yangchao.me/post/stringsubstring-implementation/</url>
        <categories>
          <category>Basics</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html"> I heard that in new version of JDK (&amp;gt;JDK7u5), substring implementation is changed.
In the past, substring() don&amp;rsquo;t copy the specified character string but share the inherent character array reference with the original String. In this case, String substring can result in retaining more memory than you might expect. As such it&amp;rsquo;s not a memory leak as this memory can be recovered normally (potential memory leak).
But note this behaviour has changed as of Java 7u6.
</content>
    </entry>
    
     <entry>
        <title>Why two Date classes: java.util.Date and java.sql.Date?</title>
        <url>http://yangchao.me/post/why-two-date-classes-java-util-date-and-java-sql-date/</url>
        <categories>
          <category>Basics</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html"> A java.util.Date represents date and time of day, a java.sql.Date only represents a date. The complement of java.sql.Date is java.sql.Time, which only represents a time of day. The java.sql.Date is a subclass (an extension) of java.util.Date. So, what changed in java.sql.Date:
&amp;ndash; toString() generates a different string representation: yyyy-mm-dd &amp;ndash; a static valueOf(String) methods to create a Date from a String with above representation &amp;ndash; the getters and setter for hours, minutes and seconds are deprecated
The java.sql.Date class is used with JDBC and it was intended to not have a time part, that is, hours, minutes, seconds, and milliseconds should be zero… but this is not enforced by the class.
You can still use its setTime(long) method to set the date in the form of millisecond time value.
java.sql.Time is similar to java.sql.Date and inherited to java.util.Date.
java.sql.Timestamp can represent date and time together, just like java.util.Date
</content>
    </entry>
    
     <entry>
        <title>auto-boxing and valueOf(..)</title>
        <url>http://yangchao.me/post/autoboxing-and-valueof/</url>
        <categories>
          <category>Basics</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html"> Autoboxing uses Integer.valueOf(int),which internally caches Integer objects for small integers (by default -128 to 127, but the max value can be configured with the &amp;ldquo;java.lang.Integer.IntegerCache.high&amp;rdquo; property.
Double is the same by using Double.valueOf(..)
So the following two lines are equivalent.
Integer i = 12; Integer i = Integer.valueOf(12); If you don&amp;rsquo;t believe it, you can decompile the .class file to see what the compiler does.
</content>
    </entry>
    
     <entry>
        <title>Float numbers</title>
        <url>http://yangchao.me/post/float-numbers/</url>
        <categories>
          <category>Basics</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html"> </content>
    </entry>
    
     <entry>
        <title>equals() / hashCode() contract, Comparable contract</title>
        <url>http://yangchao.me/post/equals-and-hashcode-contract/</url>
        <categories>
          <category>Basics</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html">  Although Java encourage and support to maintain contract by interface, but there are some implicit contracts that should be noticed when you are implementing some special functions.
What is equals and hashCode contract?  The interface contract for Object requires that if two objects are equal according to equals(), then they must have the same hashCode()value.
1. If two objects are equal, then they must have the same hash code.
2. If two objects have the same hashcode, they may or may not be equal.
 Why override equals() and hashCode()? The hashCode() method exists purely for efficiency. The Java platform architects anticipated the importance of hash-based collection classes &amp;ndash; such as Hashtable, HashMap, and HashSet &amp;ndash; in typical Java applications, and comparing against many objects with equals() can be computationally expensive. Having every Java object support hashCode() allows for efficient storage and retrieval using hash-based collections.
For the class as key of HashMap or HashSet(which is inner implemented by HashMap and the entry with a dummy value), it must rewrite the hashCode() and equals() methods.
Some developers rewrite the equals() methods but don&amp;rsquo;t rewrite the hashCode() method, it will be error prone. The following is a common mistake.
public class BrokenEqualsHashCode { @Test public void testEuals() { SomeObject a = new SomeObject(1,&amp;#34;1&amp;#34;); SomeObject b = new SomeObject(2, &amp;#34;1&amp;#34;); System.out.println(a.hashCode()); System.out.println(b.hashCode()); System.out.println(b.equals(a)); Map&amp;lt;SomeObject, String&amp;gt; map = new HashMap&amp;lt;SomeObject, String&amp;gt;(10); map.put(a, &amp;#34;1&amp;#34;); map.put(b, &amp;#34;2&amp;#34;); System.out.println(map.get(new SomeObject(1, &amp;#34;1&amp;#34;))); } } class SomeObject { int a; String b; public SomeObject(int a, String b) { this.a = a; this.b = b; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; SomeObject that = (SomeObject) o; if (!b.equals(that.b)) return false; return true; } } 3790865 26759037 true null
You can see, although the two objects as key are equal, but it cannot get the expected effect.
Actually, the two entries are stored in the hash map, but it cannot be retrieved by the equal object.
How to design a good key for HashMap The very basic need for designing a good key is that “_we should be able to retrieve the value object back from the map without failure_“, otherwise no matter how fancy data structure you build, it will be of no use.
For this basic reasoning, key objects are suggested to be IMMUTABLE. IMMUTABILITY allows you to get same hash code every time, for a key object.
But remember that immutability is recommended and not mandatory.
An example is always better for demonstration, right? Then lets have one.
In this example, I have created an account class with only two fields for simplicity. I have overridden the hash code and equals method such that it uses only account number to verify the uniqueness of Account object. All other possible attributes of Account class can be changed on runtime.
public class Account { private int accountNumber; private String holderName; public Account(int accountNumber) { this.accountNumber = accountNumber; } public String getHolderName() { return holderName; } public void setHolderName(String holderName) { this.holderName = holderName; } public int getAccountNumber() { return accountNumber; } //Depends only on account number  @Override public int hashCode() { final int prime = 31; int result = 1; result = prime * result &#43; accountNumber; return result; } //Compare only account numbers  @Override public boolean equals(Object obj) { if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; Account other = (Account) obj; if (accountNumber != other.accountNumber) return false; return true; } } Output:
A_ONE A_TWO A_ONE
What is Comparable contract? Basically, Comparable contract is related to sorting or ordering.
So to do the following things, you must implement Comparable:
 calling Collections.sort and Collections.binarySearch calling Arrays.sort and Arrays.binarySearch using objects as keys in a TreeMap using objects as elements in a TreeSet It&amp;rsquo;s not hard to notice that these are all related to ordering.  Compare the various types of fields as follows:
 numeric primitive : use &amp;lt; and &amp;gt;. There is an exception to this rule: float and double primitives should be compared using Float.compare(float, float) and Double.compare(double, double). This avoids problems associated with special border values. boolean primitive : use tests of the form (x &amp;amp;&amp;amp; !y) All primitive wrapper classes implement Comparable Object : use compareTo. (Note that possibly-null fields present a problem : while x.equals(null) returns false, x.compareTo(null) will always throw a NullPointerException) type-safe enumeration : use compareTo, like any Object collection or array : Comparable does not seem to be intended for these kinds of fields. For example, List, Map and Set do not implement Comparable. As well, some collections have no definite order of iteration, so doing an element-by-element comparison cannot be meaningful in those cases. If the task is to perform a sort of items which are stored in a relational database, then it is usually much preferred to let the database perform the sort using the ORDER BY clause, rather than in code.  An alternative to implementing Comparable is passing Comparator objects as parameters. Be aware that if a Comparator compares only one of several significant fields, then the Comparator is very likely not consistent with equals.
</content>
    </entry>
    
     <entry>
        <title>Character encoding and charset in Java</title>
        <url>http://yangchao.me/post/character-encoding-and-charset-in-java/</url>
        <categories>
          <category>Basics</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html">  Concepts At the beginning, we need to distinguish some key concepts.
character Character (aka. abstract character) is a textual representation of character.
glyph glyph is the particular images representing a character or part of a character. Glyphs for the same character may have very different shapes
abstract character repertoire (ACR) A character repertoire is the full set of unordered abstract characters that a system supports.
coded character set (CCS) A coded character set (CCS) specifies how to represent a repertoire of characters using a number of (typically non-negative) integer values called code points.
A complete set of characters and corresponding integers is a coded character set.
Multiple coded character sets may share the same repertoire.
character encoding form (CEF) A character encoding form (CEF) specifies the conversion of a coded character set&amp;rsquo;s integer codes into a set of limited-size integer code values that facilitate storage in a system that represents numbers in binary form using a fixed number of bits.
This is what a CEF accommodates: it defines a way of mapping a single code point to a sequences of octets.
character encoding scheme (CES) a character encoding scheme (CES) specifies how the fixed-size integer code values should be mapped into an octet sequence suitable for saving on an octet-based file system or transmitting over an octet-based network.
   Character encoding Code unit width     US-ASCII 7   UTF-8 8   EBCDIC 8   UTF-16 16   UTF-32 32    Notice: although UTF-8 use the eight-unit code unit, but it doesn&amp;rsquo;t necessarily mean that each character is encoded as a single code unit. Actually, a character can be encoded as one or more than one code units in UTF-8.
For code unit including more thant 8 bits(byte), there is a problem named as endian (byte order). BE is big-endian, while LE is little-endian.
Java internal string representation Java uses UTF-16BE encoding as its internal representation. &amp;gt; UTF-16 developed from an earlier fixed-width 16-bit encoding known as UCS-2 (for 2-byte Universal Character Set) once it became clear that a fixed-width 2-byte encoding could not encode enough characters to be truly universal. &amp;gt; &amp;gt; &amp;gt; The encoding is variable-length, as code points are encoded with one or two 16-bit code units. So, in Java:
 a code point is a 32-bit int data type, where the lower 21 bits represent a valid code point value and the upper 11 bits are 0. (thus no negative code point) a code unit is a 16-bit char value. To express a Unicode character, the hexadecimal value is prefixed with the string U&#43;.     Character Unicode Code Point Glyph     Latin A U&#43;0041    Latin sharp S U&#43;00DF    Han for East U&#43;6771    Deseret, LONG I U&#43;10400     Characters that are in the range U&#43;10000 to U&#43;10FFFF are called supplementary characters. The set of characters from U&#43;0000 to U&#43;FFFF are sometimes referred to as the Basic Multilingual Plane (BMP). &amp;gt; U&#43;10FFFF is the current upper limit of unicode defined code points. Obviously, supplementary characters cannot be represented by a 16-bit char.
To support supplementary characters without changing the char primitive data type and causing incompatibility with previous Java programs, supplementary characters are defined by a pair of code point values that are called surrogates. The first code point is from the high surrogates range of U&#43;D800 to U&#43;DBFF, and the second code point is from the low surrogates range of U&#43;DC00 to U&#43;DFFF. You can simply think surogates ranges are the blocks reserved in BMP.
Therefore, a unicode character can be represented by one char (BMP), or a surrogate pair (2 elements array of char).
Until now, you shold be able to answer these questions: - can any unicode character be represented by a Java char? No - how do we initialize a char exceeding BMP with char literals? No
Simply, char ≠ unicode character
The table above shows some of the interesting things we have to look out for.
 Stored characters can take up an inconsistent number of bytes. A UTF-8 encoded character might take between one (LATIN_CAPITAL_LETTER_A) and four (MATHEMATICAL_FRAKTUR_CAPITAL_G) bytes.Variable width encoding has implications for reading into and decoding from byte arrays.
 Not all code points can be stored in a char. The MATHEMATICAL_FRAKTUR_CAPITAL_G example lies in the supplementary range of characters and cannot be stored in 16 bits. It must be represented by two sequential char values, neither of which is meaningful by itself. The Character class provides methods for working with 32-bit code points.
  // Unicode code point to char array char[] math_fraktur_cap_g = Character.toChars(0x1D50A);  The relationship between the grapheme visible to the user and the code point type may not be 1:1.  This can be seen in the combining character sequences (the e-acute example). As the Devenagari example shows, combining sequences can get quite complex.
Character and String API How long is a string?  String.length() returns the number of chars in the String. That&amp;rsquo;s also the number of code units. String.codePointCount(int, int) returns the number of Unicode code points in the String. BreakIterator.getCharacterInstance() can be used to count the number of graphemes in a String.  Play with charsets and encodings in Java Here, the name of charset is misleading, actually it is defined as the combination of one or more coded character sets and a character-encoding scheme. If you are a serious programmer, you should read the Javadoc of class Charset.
Many non-unicode charsets are subsets of unicode, while others use completely different mapping between a character and its code point.
Charset, CharsetEncoder/CharsetDecoder Java provides a Charset class representing supported charset, by which we can encode Java string into bytes or decode bytes into Java String.
Charset.defaultCharset(); // underlying OS encoding, you can modified it by System.setProperty(&amp;#34;file.encoding&amp;#34;, &amp;#34;your encoding here&amp;#34;)  The &amp;ldquo;file.encoding&amp;rdquo; property is not required by the J2SE platform specification; it&amp;rsquo;s an internal detail of Sun&amp;rsquo;s implementations and should not be examined or modified by user code. It&amp;rsquo;s also intended to be read-only; it&amp;rsquo;s technically impossible to support the setting of this property to arbitrary values on the command line or at any other time during program execution. Charset can get the CharsetEncoder and CharsetDecoder, by which you can control the entire encoding/decoding process.
 Charset.encode(..) and Charset.decode(..) are just the shortcut methods of using CharsetEncoder and CharsetDecoder.
Any place where you need to do byte-character conversion, you should specify the charset explicitly.
Some cases:
 String.getBytes() Stream file I/O  BOM (Byte Order Marker) The code point for BOM is U&#43;FEFF.
   Charset BOM byte sequence     UTF-8 ef bb bf   UTF-16BE fe ff   UTF-16LE ff fe   UTF-32BE 00 00 fe ff   UTF-32LE ff fe 00 00    Some encodings will automatically emit byte order marks on encode and read them on decode.
let&amp;rsquo;s test which charset insert BOM automatically:
public void testBOM() { // Encode this to get bytes  final String bomChar = &amp;#34;\u0041&amp;#34;; // Unicode encodings  String[] unicodeEncodings = {&amp;#34;UTF-16&amp;#34;, &amp;#34;UTF-8&amp;#34;, &amp;#34;UTF-16BE&amp;#34;, &amp;#34;UTF-16LE&amp;#34;, &amp;#34;UTF-32BE&amp;#34;, &amp;#34;UTF-32LE&amp;#34;}; // Print the byte order marks  for (String encName : unicodeEncodings) { Charset charset = Charset.forName(encName); byte[] byteOrderMark = bomChar.getBytes(charset); System.out.format(&amp;#34;%10s encoding: &amp;#34;, charset.toString()); for (byte b : byteOrderMark) { System.out.format(&amp;#34;%02x &amp;#34;, b); } System.out.println(); } } Output: UTF-16 encoding: fe ff 00 41 UTF-8 encoding: 41 UTF-16BE encoding: 00 41 UTF-16LE encoding: 41 00 UTF-32BE encoding: 00 00 00 41 UTF-32LE encoding: 41 00 00 00
You can see, UTF-16 encoding scheme inserts the UTF-16BE BOM automatically, while others don&amp;rsquo;t.
UTF-16 is also called UTF-16BE with BOM.
pitfalls of encoding and decoding - data corruption When decoding not on one go, the character may become corrupted as two halves.
When encoding incrementally, some problems may happen: the UTF-16 encoding scheme used adds a byte order mark to encoded data. Every time a string is written, another BOM is added, littering the content with unwanted data. When the data is decoded, extra characters end up in the text. All text would need to be concatenated and encoded in one go.
environments and boundaries JVM interacts with If all your code is just running in JVM, you are OK. Once your JVM starts to interact with outer environment through I/O or network, that&amp;rsquo;s the boundary place that character en/decoding will happen.
OS locale A locale is a set of parameters that defines the user&amp;rsquo;s language, country and any special variant preferences that the user wants to see in their user interface. Usually a locale identifier consists of at least a language identifier and a region identifier.
In Unix, Linux or like, the locale identifier is defined in this format: [language[_territory][.codeset][@modifier]]
The locale settings usually include the following display (output) format settings:
 Number format setting Character classification, case conversion settings Date-time format setting String collation setting Currency format setting Paper size setting other minor settings &amp;hellip; In Windows, &amp;hellip;&amp;hellip;  //TODO
File encoding We say file encoding meas its content&amp;rsquo;s encoding (if it&amp;rsquo;s a text file) or it&amp;rsquo;s regarded as a storage of binary bytes.
Actually, file has no knowledge about its content encoding. Some tools can guess the encoding.
When you store the file in an encoding, and then open to show or interpret it in another encoding, I&amp;rsquo;m sure you&amp;rsquo;ll be frustrated with the Mojibake.
HTML charset with meta There are two ways to specify the charset using HTML meta tag:
  These two are equivalent.  HTTP charset with Content-Type HTTP header Content-Type can be set as &amp;ldquo;text/html; charset=UTF-8&amp;rdquo;. This is an indicator for browsers. It tells browsers to render or interpret this response context as UTF-8 HTML text.
Servlet/JSP You tell the browser what encoding you are using, and you also need your server to produce the response of that encoding, whatever static html file, dynamic JSP or in-memory response stream.
JSP uses the directive:
&amp;lt;%@ page contentType=&amp;#34;text/html;charset=UTF-8&amp;#34; pageEncoding=&amp;#34;GBK&amp;#34; %&amp;gt; This means that this file is edited and stored using GBK encoding, but the server resonse as UTF-8 encoding.
So the pageEncoding attribute is for JVM to read the JSP source file content when run-time compiling.
For input data, you can use
request.setCharacterEncoding(&amp;#34;UTF-8&amp;#34;); database codepage/collation Some useful sites https://codepoints.net
</content>
    </entry>
    
     <entry>
        <title>finally execution in try-catch-finnally blocks</title>
        <url>http://yangchao.me/post/finally-execution-in-try-catch-finnally-blocks/</url>
        <categories>
          <category>Basics</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html"> The finally block will always execute, except for System.exit() is called first, or the thread has terminated or the JVM crashes. Anything that is returned in the finally block will actually override any exception or returned value that is inside the try/catch block.
public class Finally { //exception-free code, try-catch-finally blocks all have returns  private int scenario1() { int i = 0; try { System.out.println(&amp;#34;Inside try block of testMethod!&amp;#34;); i = 100; return i; } catch(Exception e){ System.out.println(&amp;#34;Inside catch block of testMethod!&amp;#34;); i = 200; return i; } finally{ System.out.println(&amp;#34;Inside finally block of testMethod!&amp;#34;); i = 300; return i; } } //try block throws exception, try-catch blocks all have returns  private int scenario2() { int i = 0; try { System.out.println(&amp;#34;Inside try block of testMethod!&amp;#34;); i = 100/0; return i; } catch(Exception e){ System.out.println(&amp;#34;Inside catch block of testMethod!&amp;#34;); i = 200; return i; } finally{ System.out.println(&amp;#34;Inside finally block of testMethod!&amp;#34;); i = 300; //return i;  } } //try-catch blocks throw exception, try-catch-finally blocks all have returns  private int scenario3() { int i = 0; try { System.out.println(&amp;#34;Inside try block of testMethod!&amp;#34;); i = 100/0; return i; } catch(Exception e){ System.out.println(&amp;#34;Inside catch block of testMethod!&amp;#34;); i = 200/0; return i; } finally{ System.out.println(&amp;#34;Inside finally block of testMethod!&amp;#34;); i = 300; return i; } } //try block throws exception, try-catch-finally blocks all have returns  private int scenario4() { int i = 0; try { System.out.println(&amp;#34;Inside try block of testMethod!&amp;#34;); i = 100/0; return i; } catch(Exception e){ System.out.println(&amp;#34;Inside catch block of testMethod!&amp;#34;); i = 200; return i; } finally{ System.out.println(&amp;#34;Inside finally block of testMethod!&amp;#34;); i = 300; return i; } } //try-catch blocks throw exception, try-catch blocks all have returns  private int scenario5() { int i = 0; try { System.out.println(&amp;#34;Inside try block of testMethod!&amp;#34;); i = 100/0; return i; } catch(Exception e){ System.out.println(&amp;#34;Inside catch block of testMethod!&amp;#34;); i = 200/0; return i; } finally{ System.out.println(&amp;#34;Inside finally block of testMethod!&amp;#34;); i = 300; //return i;  } } //try-catch-finally blocks throw exception, try-catch-finally blocks all have returns  private int scenario6() { int i = 0; try { System.out.println(&amp;#34;Inside try block of testMethod!&amp;#34;); i = 100/0; return i; } catch(Exception e) { System.out.println(&amp;#34;Inside catch block of testMethod!&amp;#34;); i = 200/0; return i; } finally{ System.out.println(&amp;#34;Inside finally block of testMethod!&amp;#34;); i = 300; return i/0; } } //try and catch both fine; finally throws exception  private int scenario7() { int i = 0; try { System.out.println(&amp;#34;Inside try block of testMethod!&amp;#34;); i = 100; return i; } catch(Exception e){ System.out.println(&amp;#34;Inside catch block of testMethod!&amp;#34;); i = 200; return i; } finally{ System.out.println(&amp;#34;Inside finally block of testMethod!&amp;#34;); i = 300; return i/0; } } //try and catch both fine; finally doesn&amp;#39;t have any return  private int scenario8() { int i = 0; try { System.out.println(&amp;#34;Inside try block of testMethod!&amp;#34;); i = 100; return i; } catch(Exception e){ System.out.println(&amp;#34;Inside catch block of testMethod!&amp;#34;); i = 200; return i; } finally{ System.out.println(&amp;#34;Inside finally block of testMethod!&amp;#34;); i = 300; //return i;  } } @Test public void testPlayWithFinally() { System.out.println(&amp;#34;\n-----------Senrio1------------------&amp;#34;); System.out.println(&amp;#34;Return value: &amp;#34; &#43; scenario1()); System.out.println(&amp;#34;\n-----------Senrio2------------------&amp;#34;); System.out.println(&amp;#34;Return value: &amp;#34; &#43; scenario2()); System.out.println(&amp;#34;\n-----------Senrio3------------------&amp;#34;); System.out.println(&amp;#34;Return value: &amp;#34; &#43; scenario3()); System.out.println(&amp;#34;\n-----------Senrio4------------------&amp;#34;); System.out.println(&amp;#34;Return value: &amp;#34; &#43; scenario4()); // System.out.println(&amp;#34;\n-----------Senrio5------------------&amp;#34;); // System.out.println(&amp;#34;Return value: &amp;#34; &#43; scenario5());  // System.out.println(&amp;#34;\n-----------Senrio6------------------&amp;#34;); // System.out.println(&amp;#34;Return value: &amp;#34; &#43; scenario6());  // System.out.println(&amp;#34;\n-----------Senrio7------------------&amp;#34;); // System.out.println(&amp;#34;Return value: &amp;#34; &#43; scenario7());  System.out.println(&amp;#34;\n-----------Senrio8------------------&amp;#34;); System.out.println(&amp;#34;Return value: &amp;#34; &#43; scenario8()); } } /* &amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;Senrio1&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash; Inside try block of testMethod! Inside finally block of testMethod! Return value: 300
&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;Senrio2&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash; Inside try block of testMethod! Inside catch block of testMethod! Inside finally block of testMethod! Return value: 200
&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;Senrio3&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash; Inside try block of testMethod! Inside catch block of testMethod! Inside finally block of testMethod! Return value: 300
&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;Senrio4&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash; Inside try block of testMethod! Inside catch block of testMethod! Inside finally block of testMethod! Return value: 300
&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;Senrio5&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash; Inside try block of testMethod! Inside catch block of testMethod! Inside finally block of testMethod!
java.lang.ArithmeticException: / by zero
&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;Senrio6&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash; Inside try block of testMethod! Inside catch block of testMethod! Inside finally block of testMethod!
java.lang.ArithmeticException: / by zero
&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;Senrio7&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash; Inside try block of testMethod! Inside finally block of testMethod!
java.lang.ArithmeticException: / by zero
&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;Senrio8&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash; Inside try block of testMethod! Inside finally block of testMethod! Return value: 100 */
</content>
    </entry>
    
     <entry>
        <title>Apache Maven 2</title>
        <url>http://yangchao.me/post/apache-maven-2/</url>
        <categories>
          <category>Building, Testing &amp;amp; CI</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html">  Although I have some experience about Maven 2, this is a simple summary. &amp;gt; Maven /ˈmeɪv_ə_n/
Artifact Vector  groupid:artifactid:packaging:version:scope such as: org.springframework:spring:jar:2.5.6:compile
org.mockito:mockito-core:jar:4.7:test Maven provides the following standard scope:   Scope Description   compile Needed for compilation, included in packages.   test Needed for unit tests, not included in packages.   provided Needed for compilation, but provided at runtime by the runtime container.   system Needed for compilation, given as absolute path on disk, and not included in packages.   import An inline inclusion of a POM-type artifact facilitating dependency-declaring POM snippets.   
 Lifecycles, Phases, Plugins, Goals Lifecycles represent a well-recognized flw of steps (Phases) used in software assembly. Each step in a lifecycle flow is called a phase. Zero or more plugin goals are bound to a phase. A plugin is a logical grouping and distribution (often a single JAR) of related goals, such as JARing. A goal, the most granular step in Maven, is a single executable task within a plugin. For example, discrete goals in the jar plugin include packaging the jar (jar:jar), signing the jar (jar:sign), and verifying the signature (jar:sign-verify).
Built-in lifecycles Maven provides 3 built-in lifecycles: clean, default, site.
The following lists all build phases and its default goals bound to them.
Clean Lifecycle   Phrase Default goal bindings Phase description   pre-clean  executes processes needed prior to the actual project cleaning   clean maven-clean-plugin:clean remove all files generated by the previous build   post-clean  executes processes needed to finalize the project cleaning    Default Lifecycle   Phase Default goal bindings Phase description   packaging ejb/ejb3/jar/par/rar/war packaging ear packaging maven-plugin packing pom   validate     validate the project is correct and all necessary information is available.   initialize     initialize build state, e.g. set properties or create directories.   generate-sources     generate any source code for inclusion in compilation.   process-sources     process the source code, for example to filter any values.   generate-resources  maven-ear-plugin:generate-application-xml maven-plugin-plugin:descriptor  generate resources for inclusion in the package.   process-resources maven-resources-plugin:resources maven-resources-plugin:resources maven-resources-plugin:resources  copy and process the resources into the destination directory, ready for packaging.   compile maven-compiler-plugin:compile  maven-compiler-plugin:compile  compile the source code of the project.   process-classes     post-process the generated files from compilation, for example to do bytecode enhancement on Java classes.   generate-test-sources     generate any test source code for inclusion in compilation.   process-test-sources     process the test source code, for example to filter any values.   generate-test-resources maven-resources-plugin:testResources  maven-resources-plugin:testResources  create resources for testing.   process-test-resources     copy and process the resources into the test destination directory.   test-compile maven-compiler-plugin:testCompile  maven-compiler-plugin:testCompile  compile the test source code into the test destination directory   process-test-classes     post-process the generated files from test compilation, for example to do bytecode enhancement on Java classes. For Maven 2.0.5 and above.   test maven-surefire-plugin:test  maven-surefire-plugin:test  run tests using a suitable unit testing framework. These tests should not require the code be packaged or deployed.   prepare-package     perform any operations necessary to prepare a package before the actual packaging. This often results in an unpacked, processed version of the package. (Maven 2.1 and above)   package maven-ejb-plugin:ejb / maven-ejb3-plugin:ejb3 / maven-jar-plugin:jar / maven-par-plugin:par / maven-rar-plugin:rar / maven-war-plugin:war maven-ear-plugin:ear maven-jar-plugin:jar maven-plugin-plugin:addPluginArtifact Metadata maven-site-plugin:attach-descriptor take the compiled code and package it in its distributable format, such as a JAR.   pre-integration-test     perform actions required before integration tests are executed. This may involve things such as setting up the required environment.   integration-test     process and deploy the package if necessary into an environment where integration tests can be run.   post-integration-test     perform actions required after integration tests have been executed. This may including cleaning up the environment.   verify     run any checks to verify the package is valid and meets quality criteria.   install maven-install-plugin:install maven-install-plugin:install maven-install-plugin:install maven-install-plugin:install install the package into the local repository, for use as a dependency in other projects locally.   deploy maven-deploy-plugin:deploy maven-deploy-plugin:deploy maven-deploy-plugin:deploy maven-deploy-plugin:deploy done in an integration or release environment, copies the final package to the remote repository for sharing with other developers and projects.    Site Lifecycle  Phase Default goal bindings Phase description  pre-site  executes processes needed prior to the actual project site generation  site maven-site-plugin:site generates the project&amp;rsquo;s site documentation  post-site  executes processes needed to finalize the site generation, and to prepare for site deployment  site-deploy maven-site-plugin:deploy deploys the generated site documentation to the specified web server   
Project packaging we set the packaging for your project via the equally named POM element &amp;lt;packaging&amp;gt;. Some of the valid packaging values are jar, war, ear and pom. If no packaging value has been specified, it will default to jar.
Phase and goal binding A goal may be bound to zero or more build phases. A goal not bound to any build phase could be executed outside of the build lifecycle by direct invocation.
Moreover, if a goal is bound to one or more build phases, that goal will be called in all those phases.
Furthermore, a build phase can also have zero or more goals bound to it. If a build phase has no goals bound to it, that build phase will not execute.
Usually, plugin bind its goals on default phases. That&amp;rsquo;s defined on plugin jar&amp;rsquo;s MATE-INF/maven/plugin.xml.
Let&amp;rsquo;s see the plugin.xml of maven-compiler-plugin.jar:
&amp;lt;plugin&amp;gt; &amp;lt;mojos&amp;gt; &amp;lt;mojo&amp;gt; &amp;lt;goal&amp;gt;compile&amp;lt;/goal&amp;gt; .... &amp;lt;phase&amp;gt;compile&amp;lt;/phase&amp;gt; .... &amp;lt;/mojo&amp;gt; &amp;lt;mojo&amp;gt; &amp;lt;goal&amp;gt;help&amp;lt;/goal&amp;gt; .... &amp;lt;/mojo&amp;gt; &amp;lt;mojo&amp;gt; &amp;lt;goal&amp;gt;testCompile&amp;lt;/goal&amp;gt; .... &amp;lt;phase&amp;gt;test-compile&amp;lt;/phase&amp;gt; .... &amp;lt;/mojo&amp;gt; &amp;lt;/mojos&amp;gt; &amp;lt;/plugin&amp;gt; maven-compiler-plugin defines 3 goals, and &amp;ldquo;compile&amp;rdquo; and &amp;ldquo;testCompiler&amp;rdquo; goals have the default phase, but &amp;ldquo;help&amp;rdquo; goal not.
&amp;nbsp;
But a goal can be bound on different phases which can be reconfigured by plugin configuration section.
... &amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;com.mycompany.example&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;display-maven-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.0&amp;lt;/version&amp;gt; &amp;lt;executions&amp;gt; &amp;lt;execution&amp;gt; &amp;lt;phase&amp;gt;process-test-resources&amp;lt;/phase&amp;gt; &amp;lt;goals&amp;gt; &amp;lt;goal&amp;gt;time&amp;lt;/goal&amp;gt; &amp;lt;/goals&amp;gt; &amp;lt;/execution&amp;gt; &amp;lt;execution&amp;gt; &amp;lt;phase&amp;gt;process-resources&amp;lt;/phase&amp;gt; &amp;lt;goals&amp;gt; &amp;lt;goal&amp;gt;anotherGoal&amp;lt;/goal&amp;gt; &amp;lt;goal&amp;gt;anotherGoalAgain&amp;lt;/goal&amp;gt; &amp;lt;/goals&amp;gt; &amp;lt;/execution&amp;gt; &amp;lt;/executions&amp;gt; &amp;lt;/plugin&amp;gt; ... Default goal The default goal codifis the author’s intended usage of the build script. Only one goal or lifecycle can be set as the default.
&amp;lt;project&amp;gt; [...] &amp;lt;build&amp;gt; &amp;lt;defaultGoal&amp;gt;install&amp;lt;/defaultGoal&amp;gt; &amp;lt;/build&amp;gt; [...] &amp;lt;/project&amp;gt; Execute a Phase or Goal If you ask Maven to run a specific goal, then only that goal is run.
For org.apache.maven:maven-***-plugin, you can run it using the plugin-prefix for short. &amp;gt; mvn &amp;lt;plugin-prefix&amp;gt;:&amp;lt;goal&amp;gt; or
For your customized plugins, run it: &amp;gt; mvn &amp;lt;plugin-group-id&amp;gt;:&amp;lt;plugin-artifact-id&amp;gt;[:&amp;lt;plugin-version&amp;gt;]:&amp;lt;goal&amp;gt; For example: &amp;gt; mvn compiler:compile jar:jar This example runs two plugin goals: compilation of code, then JARing the result, skipping over any intermediate steps.
mvn &amp;lt;phase-name&amp;gt;
Conversely, if you ask Maven to execute a phase, all phases and bound plugin goals up to that point in the lifecycle are also executed. This example requests the deploy lifecycle phase, which will also execute the verifiation, compilation, testing and packaging phases. &amp;gt; mvn deploy
Profiles Profies are a means to conditionally turn on portions of Maven confiuration, including plugins, pathing and confiuration. The most common uses of profies are for Windows/Unix platform-specifi variations and build-time customization of JAR dependencies based on the use of a specifi Weblogic, Websphere or JBoss J2EE vendor.
&amp;lt;project&amp;gt; ... &amp;lt;profiles&amp;gt; &amp;lt;profile&amp;gt; &amp;lt;id&amp;gt;YourProfile&amp;lt;/id&amp;gt; ...settings, build, plugins etc... &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.yourcompany&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;yourlib&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;/profile&amp;gt; &amp;lt;/profiles&amp;gt; ... &amp;lt;/project&amp;gt; Profile activation Profiles can be activated manually from the command line or through an activation rule (OS, fie existence, Maven version, etc.).
Profiles are primarily additive, so best practices suggest leaving most off by default, and activating based on specific conditions.
Manual Profie Activation &amp;gt; mvn –P YourProfie Automatic Profie Activation
&amp;lt;project&amp;gt; ... &amp;lt;profiles&amp;gt; &amp;lt;profile&amp;gt; &amp;lt;id&amp;gt;YourProfile&amp;lt;/id&amp;gt; ...settings, build, etc... &amp;lt;activation&amp;gt; &amp;lt;os&amp;gt; &amp;lt;name&amp;gt;Windows XP&amp;lt;/name&amp;gt; &amp;lt;family&amp;gt;Windows&amp;lt;/family&amp;gt; &amp;lt;arch&amp;gt;x86&amp;lt;/arch&amp;gt; &amp;lt;version&amp;gt;5.1.2600&amp;lt;/version&amp;gt; &amp;lt;/os&amp;gt; &amp;lt;fie&amp;gt; &amp;lt;missing&amp;gt;somefolder/somefie.txt&amp;lt;/missing&amp;gt; &amp;lt;/fie&amp;gt; &amp;lt;/activation&amp;gt; &amp;lt;/profile&amp;gt; &amp;lt;/profiles&amp;gt; ... &amp;lt;/project&amp;gt;</content>
    </entry>
    
     <entry>
        <title>Core Java Concurrency</title>
        <url>http://yangchao.me/post/core-java-concurrency/</url>
        <categories>
          <category>Multithreading</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html">  A birdview of core java concurrency Concepts ![table1](/media/table1.png) Procting shared data Java provides Lock-based concurrency control machanism. Locking **establishes the orderings** needed to satisfy the Java Memory Model and **guarantee the visibility** of changes to other threads.  #### Synchronized  Every object instance has a monitor that can be locked by one thread at a time. The _synchronized _keyword can be specifid on a method or in block form to lock the monitor. Modifying a field while synchronized on an object guarantees that subsequent reads from any other thread synchronized on the same object will see the updated value. It is important to note that writes outside synchronization or synchronized on a different object than the read are not necessarily ever visible to other threads. The _synchronized_ keyword can be specified on a method or in block form on a particular object instance. If specified on a non-static method, the _this_ reference is used as the instance. In a synchronized static method, the Class defining the method is used as the instance. Lock The java.util.concurrent.locks package has a standard Lock interface. The ReentrantLock implementation duplicates the functionality of the synchronized keyword but also provides additional functionality such as obtaining information about the state of the lock, non-blocking tryLock(), and interruptible locking.  Example of using a explicit ReentrantLock instance:  ```java public class Counter { private final Lock lock = new ReentrantLock(); private int value = 0; public int increment() { lock.lock(); try { return &#43;&#43;value; } finally { lock.unlock(); } } } ```  ReadWriteLock The java.util.concurrent.locks package also contains a ReadWriteLock interface (and ReentrantReadWriteLock implementation) which is defined by a pair of locks for reading and writing, typically allowing multiple concurrent readers but only one writer. Example of using an explicit ReentrantReadWriteLock to allow multiple concurrent readers:  ```java public class statistic { private final ReadWriteLock lock = new ReentrantReadWriteLock(); private int value; public void increment() { lock.writeLock().lock(); try { value&#43;&#43;; } finally { lock.writeLock().unlock(); } } public int current() { lock.readLock().lock(); try { return value; } finally { lock.readLock().unlock(); } } } ```  volatile The volatile modifier can be used to mark a field and indicate that changes to that field must be seen by all subsequent reads by other threads, regardless of synchronization. Thus, volatile provides visibility just like synchronization but scoped only to each read or write of the field. Before Java SE 5, the implementation of volatile was inconsitent between JVM implementations and architectures and could not be relied upon. The Java Memory Model now explicitly defines volatile&#39;s behavior.  An example of using volatile as a signaling flag:  ```java public class Processor implments Runnable { private volatile boolean stop; public void stopProcessing() { stop = true; } public void run() { while(!stop) { //.. do processing } } } ```  Hot Tip: Marking an array as volatile does not make entries in the array volatile! In this case volatile applies only to the array reference itself. Instead, use a class like AtomicIntegerArray to create an array with volatile-like entries. Atomic classes One shorcoming of volatile is that while it provides visibility guarantees, you cannot both check and update a volatile field in a single atomic call. The java.util.concurrent.atomic package contains a set of classes that support atomic compound actions on a single value in a lock-free manner similar to volatile.  ```java public class Counter { private AtomicInteger value = new AtomicInteger(); public int next() { return value.incrementAndGet(); } } ``` Atomic classes are provided for booleans, integers, longs and object references as well as arrays of integers, longs, and object references.   ThreadLocal One way to contain data within a thread and make locking unnecessary is to use ThreadLocal storage. Conceptually a ThreadLocal acts as if there is a variable with its own version in every Thread. ThreadLocals are commonly used for stashing per-Thread values like the &#34;current transaction&#34; or other resources. Also, they are used to maintain per-thread counters, statistics, or ID generators.  ```java public class TransactionManager { private static final ThreadLocal&amp;lt;Transaction&amp;gt; currentTransaction = new ThreadLocal&amp;lt;Transaction&amp;gt;() { @Override protected Transaction initialValue() { return new NullTransactin(); } } public Transaction currentTransaction() { Transaction current = currentTransaction.get(); if(current.isNull()) { current = new TransactionImpl(); currentTransaction.put(current); } return current; } } ```  Concurrent collections A key technique for properly protecting shared data is to encapsulate the synchronization mechanism with the calss holding the data. You can regard all plain objects as containers of its fields(data), but to get them thread-safe, you have to implement them one by one cautiously and seriously. Collections are the container facilities Java provides for holding data and we use nearly everywhere. This technique makes it impossible to improperly access the data as all usage must conform to the synchronization protocol. The java.util.concurrent package holds many data structures designed for concurrent use. Generally, the use of these data structures yields far better performance than using a synchronized wrapper around an unsynchronized collection.  Concurrent lists and sets  ![table-concurrent-lists-sets](/media/table-concurrent-lists-sets.png)![](file:///C:/Users/Administrator/Documents/My%20Knowledge/temp/5a59455f-283a-4866-8f6b-3dc0c08f7c6a.png) Concurrent maps The java.util.concurrent package contains an extension to the Map interface called ConcurrentMap, which provides some extra methods described in following table. All of these methods perform a set of actions in the scope of a single atomic action. Performing this set of actions outside the map would introduce race conditions due to making multiple (non-atomic) calls on the map.  ![table-concurrent-map-methods](/media/table-concurrent-map-methods.png)![](file:///C:/Users/Administrator/Documents/My%20Knowledge/temp/289ebe3f-9f50-4c78-bff7-2d9f1fbc287a.png) There are two ConcurrentMap implementations available as shown in following table. ![table-concurrent-map](/media/table-concurrent-map.png)![](file:///C:/Users/Administrator/Documents/My%20Knowledge/temp/5a4f4218-f143-409f-a1c0-98c707b9dcaa.png)  Queue Queues act as pipes between “producers” and “consumers”.Items are put in one end of the pipe and emerge from the other end of the pipe in the same “fist-in fist-out” (FIFO) order. The Queue interface was added to java.util in Java SE 5 and while it can be used in single-threaded scenarios, it is primarily used with multiple producers or one or more consumers, all writing and reading from the same queue. The BlockingQueue interface is in java.util.concurrent and extends Queue to provide additional choices of how to handle the scenario where a queue may be full (when a producer adds an item) or empty (when a consumer reads or removes an item). In these cases, BlockingQueue provides methods that either block forever or block for a specifid time period, waiting for the condition to change due to the actions of another thread. The following table demonstrates the Queue and BlockingQueue methods in terms of key operations and the strategy for dealing with these special conditions. ![table-concurrent-queue-methods](/media/table-concurrent-queue-methods.png)![](file:///C:/Users/Administrator/Documents/My%20Knowledge/temp/b374c6dd-f4ae-4fe3-96fb-80233b3e1299.png) Several Queue implementations are provided by the JDK and their relationships are discribed in the following table. ![table-concurrent-queue](/media/table-concurrent-queue.png) #### Deques A double-ended queue or Deque (pronounced “deck”) was added in Java SE 6\. Deques support not just adding from one end and removing from the other but adding and removing items from both ends. Similarly to BlockingQueue, there is a BlockingDeque interface that provides methods for blocking and timeout in the case of special conditions. Table 7 shows the Deque and BlockingDeque methods. Because Deque extends Queue and BlockingDeque extends lockingQueue, all of those methods are also available for use. ![](file:///C:/Users/Administrator/Documents/My%20Knowledge/temp/307ab1f8-64da-4916-a6a7-ef6b431af845.png)![table-concurrent-deu-methods](/media/table-concurrent-deu-methods.png) One special use case for a Deque is when add, remove, and examine operations all take place on only one end of the pipe. This special case is just a stack (fist-in-last-out retrieval order). The Deque interface actually provides methods that use the terminology of a stack: push() , pop() , and peek() . These methods map to addFirst() , removeFirst() , and peekFirst() methods in the Deque interface and allow you to use any Deque implementation as a stack. Table 8 describes the Deque and BlockingDeque implementations in the JDK. Note that Deque extends Queue and BlockingDeque extends BlockingQueue.  ![table-concurrent-deque](/media/table-concurrent-deque.png)![](file:///C:/Users/Administrator/Documents/My%20Knowledge/temp/31906fc7-031c-4660-89d5-406daac22202.png) Threads  In Java, the java.lang.Thread class is used to represent an application or JVM thread. Code is always being executed in the context of some Thread class (use Thread.currentThread() to obtain your own Thread).
Thread interference The most obvious way to communicate between threads is for one thread to directly call a method on another Thread object. Table 9 shows methods on Thread that can be used for direct interaction across threads. ![table-concurrent-thread](/media/table-concurrent-thread.png)  ![thread-inference](/media/thread-inference.png)  NOTE: In current Thread implementation, suspend(), resume(), stop() are all deprecated. I guess there is a principle here: _**once started until destroyed, thread SHOULD determine its own life, except that it&#39;s willing proactively to response the external interference: interruption, or some flag-base mechanics.**_   So sleep(), yield(), join() are all for the current thread itself instead of controlling others.  Interruptible points are some points that can be interrupted or intend to accept interruption signal. There are two ways to response interruption: 1) some methods are interruptible. These method can throw InterruptedException, such as wait(), await() of CyclicBarrier and CountdownLatch, acquire() of Semophore 2) some plain codes intend to handle interruption signal by using Thread.interrupted() to test interruption mark.  In current thread, the running code can do some actions to influence the current thread by sleep() or yield(). ![thread-current-context](/media/thread-current-context.png)![](file:///C:/Users/Administrator/Documents/My%20Knowledge/temp/159e3222-f1a3-4ba4-806e-a79d29896d45.png) Uncaught exception handling Threads can specify an UncaughtExceptionHandler that will receive notifiation of any uncaught exception that cause a thread to abruptly terminate.  ```java Thread t = new Thread(runnable); t.setUncaughtExceptionHandler(new Therad.UncaughtExceptionHandler() { void uncaughtException(Thread t, Throwable e) { // get Logger and log uncaught exception } }); t.start(); ```  Deadlock A deadlock occurs when there is more than one thread, each waiting for a resource held by another, such that a cycle of resources and acquiring threads is formed. The most obvious kind of resource is an object monitor but any resource that causes blocking (such as wait / notify) can qualify. Many recent JVMs can detect monitor deadlocks and will print deadlock information in thread dumps produced from a signal, jstack, or other thread dump tool. In addition to deadlock, some other threading situations are starvation and livelock. Starvation occurs when threads hold a lock for long periods such that some threads “starve” without making progress. Livelock occurs when threads spend all of their time negotiating access to a resource or detecting and avoiding deadlock such that no thread actually makes progress. ### Thread coordination  wait / notify The wait / notify idiom is appropriate whenever one thread needs to signal to another that a condition has been met, especially as an alternative to sleeping in a loop and polling the condition. For example, one thread might wait for a queue to contain an item to process. Another thread can signal the waiting threads when an item is added to the queue. The canonical usage pattern for wait and notify is as follows:    ```java public class Latch { private final Object lock = new Object(); private volatile boolean flag = false; public void waitTillChange() { synchronized(lock) { while(! flag) { try { lock.wait(); } catch (InterruptedException e) { } } } } public void change(0 { synchronized(lock) { flag = true; lock.notifyAll(); } } } ``` Some important things to note about this code:  • Always call wait, notify, and notifyAll inside a synchronized lock or an IllegalMonitorStateException will be thrown. • Always wait inside a loop that checks the condition being waited on – this addresses the timing issue if another thread satisfis the condition before the wait begins. Also, it protects your code from spurious wake-ups that can (and do) occur. • Always ensure that you satisfy the waiting condition before calling notify or notifyAll. Failing to do so will cause a notifiation but no thread will ever be able to escape its wait loop. Condition  In Java SE 5, a new java.util.concurrent.locks.Condition class was added. Condition implements the wait/notify semantics in an API but with several additional features such as the ability to create multiple Conditions per Lock, interruptible waiting, access to statistics, etc. Conditions are obtained from a Lock instance as follows: 
public class LatchCondition { private final Lock lock = new ReentrantLock(); private final Condition condition = lock.newCondition(); private volatile boolean flag = false; public void waitTillChange() { lock.lock(); try { while(! flag) { condition.await(); } } finally { lock.unlock(); } } public void change() { lock.lock(); try { flag = true; condition.signalAll(); } finally { lock.unlock(); } } } 
Coordination classes The java.util.concurrent package contains several classes pre-built for common forms of multi-thread communication. These coordination classes cover most common scenarios where wait/notify and Condition might be used and are strongly perferred for their safety and ease of use. **CyclicBarrier** The CyclicBarrier is initialized with a participant count. Participants call await() and block until the count is reached, at which point an optional barrier task is executed by the last arriving thread, and all threads are released. The barrier can be reused indefiitely. Used to coordinate the start and stop of groups of threads. 字面意思循环挡板，通过它可以实现让一组线程等待至某个状态之后再全部同时执行。称为循环是因为当所有等待线程都被释放以后，CyclicBarrier可以被重用 Allows N-1 treads to wait on await() method until N-th thread calls await() method and then they resume their execution. ![CyclicBarrier](/media/CyclicBarrier.png) As this illustration shows there is a barrier for 3 parties. When T1 and T2 come they wait. When T3 comes an optional TA handler is called and (after it completes?) T1,2,3 resume their work. You can reuse CyclicBarrier many times by calling reset() method. And the code example: ```java final CyclicBarrier cb = new CyclicBarrier(N); for (int i = 0; i &amp;lt; N; i&#43;&#43;) { final int idx = i; new Thread(new Runnable() { public void run() { System.out.println(&#34;T&#34; &#43; idx &#43; &#34;: await&#34;); try { cb.await(); } catch (InterruptedException ex) { System.out.println(&#34;T&#34; &#43; idx &#43; &#34;: interrupted&#34;); return; } catch (BrokenBarrierException ex) { System.out.println(&#34;T&#34; &#43; idx &#43; &#34;: broken&#34;); return; } System.out.println(&#34;T&#34; &#43; idx &#43; &#34;: continue&#34;); } }).start(); } ```    Console output: ```java T0: await T1: await T2: await T2: continue T1: continue T0: continue ``` Lines can &#34;jump&#34; a little bit because threads in these examples print out information to console concurrently. So you may have slightly different results. **CountDownLatch** The CountDownLatch is initialized with a count. Threads may call await() to wait for the count to reach 0\. Other threads (or same) may call countDown() to reduce count. Not reusable once the count has reached 0\. Used to trigger an unknown set of threads once some number of actions has occurred.   倒计时闩, 利用它可以实现类似计数器的功能。比如有一个任务A，它要等待其他4个任务执行完毕之后才能执行，此时就可以利用CountDownLatch来实现这种功能了 Works like a counter – allows one or more threads to wait on await() method for another N threads to callcountDown() method N times (total number of calls should be N). ![CountdownLatch](/media/CountdownLatch.png) As the illustration shows only TA is awaiting. T1,2,3 call countDown() and proceed their execution. When T3 callscountDown(), TA gets unlocked and can resume its work. “HelloWorld app” for CountdownLatch: ```java final CountDownLatch cdl = new CountDownLatch(N); new Thread(new Runnable() { public void run() { System.out.println(&#34;awaiting...&#34;); try { cdl.await(); } catch (InterruptedException ex) { System.out.println(&#34;await has been iterrupted&#34;); return; } System.out.println(&#34;ready&#34;); } }).start(); for (int i = 0; i &amp;lt; N; i&#43;&#43;) { final int idx = i; new Thread(new Runnable() { public void run() { System.out.println(&#34;T&#34; &#43; idx &#43; &#34;:countDown&#34;); cdl.countDown(); System.out.println(&#34;T&#34; &#43; idx &#43; &#34;:continue&#34;); } }).start(); } ``` Console output: awaiting... T1:countDown T0:countDown T0:continue T1:continue T2:countDown T2:continue ready ``` It is different from CyclicBarrier: 1) it cannot be reused, used only one time 2) it does not block these N threads when they call countDown() method. Only thread on await() method waits. **Semaphore** A Semaphore manages a set of “permits” that can be checked out with acquire() which will block until one is available. Threads call release() to return the permit. A semaphore with one permit is equivalent to a mutual exclusion block.   Maintains N permits which is shared between M threads. Each thread can acquire or release permits. If there are not enough permits thread blocks until other threads release necessary amount of permits. ![Semaphore](/media/Semaphore.png) Let&#39;s see what is happening on the illustration above. There are 2 permits and 4 threads. Each thread acquires/releases only 1 permit. T1 and T2 do this and proceed their execution without being blocked. T3 and T4block and wait for permits because there are no any permits available. T2 releases one permit and T4 proceeds its calculations(T3 is also might be chosen?). Next T4 releases its permit and T3 resumes. An finally T1 and T3 release their permits. Simple example: ```java public static void main(String args[]) { final Semaphore sem = new Semaphore(N); acquire(&#34;T1&#34;, sem); acquire(&#34;T2&#34;, sem); release(&#34;Ta&#34;, sem); release(&#34;Tb&#34;, sem); } private static void acquire(final String id, final Semaphore s){ new Thread(new Runnable() { public void run() { System.out.println(id &#43; &#34;: acquire&#34;); try { s.acquire(); } catch (InterruptedException ex) { System.out.println(id &#43; &#34;: acquire|interrupted&#34;); return; } System.out.println(id &#43; &#34;: acquire|ready&#34;); } }).start(); } private static void release(final String id, final Semaphore s){ new Thread(new Runnable() { public void run() { System.out.println(id &#43; &#34;: release&#34;); s.release(); System.out.println(id &#43; &#34;: release|ready&#34;); } }).start(); } ``` Console output: T2: acquire T2: acquire|ready Tb: release T1: acquire Ta: release Ta: release|ready Tb: release|ready T1: acquire|ready ``` **Exchanger** An Exchanger waits for threads to meet at the exchange() method and swap values atomically. This is similar to using a SynchronousQueue but data values pass in both directions.    下面对上面说的三个辅助类进行一个总结： 1）CountDownLatch和CyclicBarrier都能够实现线程之间的等待，只不过它们侧重点不同： CountDownLatch一般用于某个线程A等待若干个其他线程执行完任务之后，它才执行； 而CyclicBarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行； 另外，CountDownLatch是不能够重用的，而CyclicBarrier是可以重用的。 2）Semaphore其实和锁有点类似，它一般用于控制对某组资源的访问权限。  Task execution Many concurrent Java programs need a pool of workers executing tasks from a queue. The java.util.concurrent package provides a solid foundation for this style of work management. #### ExecutorService The Executor and more expansive ExecutorService interfaces defie the contract for a component that can execute tasks. Users of these interfaces can get a wide variety of implementation behaviors behind a common interface. The most generic Executor interface accepts jobs only in the form of Runnables: • void execute(Runnable command) The ExecutorService extends Executor to add methods that take both Runnable and Callable task and collections of tasks: • Future&amp;lt;?&amp;gt; submit(Runnable task) • Future&amp;lt;T&amp;gt; submit(Callable&amp;lt;T&amp;gt; task) • Future&amp;lt;T&amp;gt; submit(Runnable task, T result) • List&amp;lt;Future&amp;lt;T&amp;gt; invokeAll(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt; tasks) • List&amp;lt;Future&amp;lt;T&amp;gt; invokeAll(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt; tasks, long timeout, TimeUnit unit)  • T invokeAny(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt; tasks) •T invokeAny(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt; tasks, long timeout, TimeUnit unit) #### Callable and Future A Callable is like the familiar Runnable but can return a result and throw an exception: • V call() throws Exception; It is common in the executor framework to submit a Callable and receive a Future. A Future is a marker representing a result that will be available at some point in the future. The Future has methods that allow you to either poll or block while waiting for the result to be ready. You can also cancel the task before or while it’s executing through methods on Future. If you need the functionality of a Future where only Runnables are supported (as in Executor), you can use FutureTask as a bridge. FutureTask implements both Future and Runnable so that you can submit the task as a Runnable and use the task itself as a Future in the caller. #### ExecutorService implementations The primary implementation of ExecutorService is ThreadPoolExecutor. This implementation class provides a wide variety of confiurable features: • Thread pool – specify “core” thread count (optionally pre-started), and max thread count • Thread factory – generate threads with custom characteristics such as a custom name • Work queue – specify the queue implementation, which must be blocking, but can be bounded or unbounded • Rejected tasks – specify the policy for tasks that cannot be accepted due to a full input queue or unavailable worker • Lifecycle hooks – overridden to extend to override key points in the lifecycle like before or after task execution • Shutdown – stop incoming tasks and wait for executing tasks to complete ScheduledThreadPoolExecutor is an extension of ThreadPoolExecutor that provides the ability to schedule tasks for completion rather than using FIFO semantics. For cases where java.util.Timer is not sophisticated enough, the ScheduledThreadPoolExecutor often provides suffiient flxibility. The Executors class contains many static methods (see Table 10) for creating prepackaged ExecutorService and ScheduledExecutorService instances that will cover a wide variety of common use cases. ![](file:///C:/Users/Administrator/Documents/My%20Knowledge/temp/98fb8f57-8cfd-441a-b0be-850e7533aebe.png)[![table-concurrent-executor](/media/table-concurrent-executor.png)](/media/table-concurrent-executor.png)  The following example creates a fied thread pool and submits a long-running task to it:  ```java int processors = Runtime.getRuntime().availableProcessor(); ExecutorService excutor = Executors.newFixedThreadPool(processors); Future&amp;lt;Integer&amp;gt; futureResult = executor.submit(new Callable&amp;lt;Integer&amp;gt;() { public Integer call() { // long running computation that returns an integer } }); Integer result = futureResult.get(); //block for result ``` In this example the call that submits the task to the executor will not block but return immediately. The last line will block on the get() call until the result is available.   ExecutorService covers almost all situations where you would previously create Thread objects or thread pools. Any time your code is constructing a Thread directly, consider whether you could accomplish the same goal with an ExecutorService produced by one of the Executor factory methods; often this will be simpler and more flxible. #### CompletionService Beyond the common pattern of a pool of workers and an input queue, it is common for each task to produce a result that must be accumulated for further processing. The CompletionService interface allows a user to submit Callable and Runnable tasks but also to take or poll for results from the results queue: • Future&amp;lt;V&amp;gt; take() – take if available • Future&amp;lt;V&amp;gt; poll() – block until available • Future&amp;lt;V&amp;gt; poll(long timeout, TimeUnit unit) – block until timeout ends The ExecutorCompletionService is the standard implementation of CompletionService. It is constructed with an Executor that provides the input queue and worker thread pool.   &amp;nbsp; * * *  Some thread-safe questions: String -&amp;gt; immutable StringBuffer -&amp;gt; mutable, synchronized version StringBuilder -&amp;gt; mutable, unsynchronized version  HashMap -&amp;gt; unsynchronized HashTable -&amp;gt; synchronized  ArrayList -&amp;gt; unsynchronized Vector -&amp;gt; sysnchronized     </content>
    </entry>
    
     <entry>
        <title>PostgreSQL Concurrency with MVCC</title>
        <url>http://yangchao.me/post/postgresql-concurrency-with-mvcc/</url>
        <categories>
          <category>Databases</category><category>Transaction Management</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html">  https://devcenter.heroku.com/articles/postgresql-concurrency#disadvantages-of-mvcc
Table of Contents  How MVCC works Disadvantages of MVCC One of the big selling points of Postgres is how it handles concurrency. The promise is simple: reads never block writes and vice versa. Postgres achieves this via a mechanism called Multi Version Concurrency Control. This technique is not unique to Postgres: there are several databases that implement some form of MVCC including Oracle, Berkeley DB, CouchDB and many more. Understanding how MVCC is implemented in Postgres is important when designing highly concurrent apps on PostgreSQL. It’s actually a very elegant and simple solution to a hard problem.  How MVCC works Every transaction in postgres gets a transaction ID called XID. This includes single one statement transactions such as an insert, update or delete, as well as explicitely wrapping a group of statements together via BEGIN - COMMIT. When a transaction starts, Postgres increments an XID and assigns it to the current transaction. Postgres also stores transaction information on every row in the system, which is used to determine whether a row is visible to the transaction or not.
For example, when you insert a row, postgres will store the XID in the row and call it xmin. Every row that has been committed and has anxmin that is less than the current transaction’s XID is visible to the transaction. This means that you can start a transaction and insert a row, and until that transaction COMMITs that row will not be visible to other transactions. Once it commits and other transactions get created, they will be able to view the new row because they satisfy the xmin &amp;amp;lt; XID condition – and the transaction that created the row has completed.
A similar mechanism occurs for DELETEs and UPDATEs, only in these cases Postgres stores an xmax value on each row in order to determine visibility. This diagram shows two concurrent transactions inserting and reading rows, and how MVCC comes into play in terms of transaction isolation.
For the following charts, assume the following DDL: CREATE TABLE numbers (value int);
 &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; ![mvcc-1](/media/mvcc-1.png) While the `xmin` and `xmax` values are hidden from daily operations, you can actually just ask for them and Postgres will hapilly give them to you: &amp;lt;div class=&amp;quot;CodeRay&amp;quot;&amp;gt; &amp;lt;div class=&amp;quot;code&amp;quot;&amp;gt; &amp;lt;pre&amp;gt;&amp;lt;span class=&amp;quot;class&amp;quot;&amp;gt;SELECT&amp;lt;/span&amp;gt; *, xmin, xmax &amp;lt;span class=&amp;quot;keyword&amp;quot;&amp;gt;FROM&amp;lt;/span&amp;gt; numbers;    You can also get the XID for the current transaction pretty easily: SELECT txid_current(); ```
  Neat!
I know what you’re thinking though: what about a two transactions updating the same row at the same time? This is where transaction isolation levels come in. Postgres basically supports two models that allow you to control how this situation should be handled. The default,READ COMMITTED, reads the row after the inital transaction has completed and then executes the statement. It basically starts over if the row changed while it was waiting. For instance, if you issue an UPDATE with a WHERE clause, the WHERE clause will rerun after the initial transaction commits, and the UPDATE takes place if the WHERE clause is still satisfied. Here’s an example of two transactions modifying a row where the initialUPDATE causes the WHERE clause of the second transaction to return no rows. Therefore the second transaction does not update any rows at all:
If you need finer control over this behavior, you can set the transactionisolation level to SERIALIZABLE. With this strategy the above scenario will just fail, because it says “If the row I’m modifying has been modified by another transaction, don’t even try,” and Postgres will respond with the error message ERROR: could not serialize access due to concurrent update. It’s up to your app to handle that error and try again, or to give up if that’s what makes sense.
Disadvantages of MVCC Now that you know how MVCC and transaction isolation actualy works, you’ve added another tool for solving the kinds of problems where aSERIALIZABLE isolation level comes in handy. While the advantages of MVCC are clear it also has some disadvantages.
Because different transactions will have visibility to a different set of rows, Postgres needs to maintain potentially obsolete records. This is why an UPDATE actually creates a new row and why DELETE doesn’treally remove the row: it merely marks it as deleted and sets the XID values appropriately. As transactions complete, there will be rows in the database that cannot possibly be visible to any future transactions. These are called dead rows. Another problem that comes from MVCC is that transaction IDs can only ever grow so much – they are 32 bits and can “only” support around 4 billion transactions. When the XID reaches its max, it will wraparound and start back at zero. Suddenly _all_rows appear to be in future transactions, and no new transactions would have visibility into those rows.
Both dead rows and the transaction XID wraparound problem are solved with VACUUM. This should be routine maintenance, but thankfuly Postgres comes with an auto_vacuum daemon that will run at a configurable frequency. It’s important to keep an eye on this because different deployments will have different needs when it comes to vacuum frequency. You can read more about what VACUUM actually does on the Postgres docs and how Heroku handles it.
</content>
    </entry>
    
     <entry>
        <title>Inner thread communication: PipedInputStream/PipedOutputStream vs. BlockingQueue</title>
        <url>http://yangchao.me/post/inner-thread-communication-pipedinstreampipedoutstream-vs-blockingqueue/</url>
        <categories>
          <category>Multithreading</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html"> There are a lot of differences between the two.
For starters, what kind of data do you want to transport? Complex objects will be easier to transport between threads using a Queue, rather than a Pipe. With the Pipes you would have to serialize the objects or transform them in some way to get them through the Stream, then reverse the procedure on the receiving side. With Queues you just put the object in the Queue and pull it out on the consumer.
Another: A PipedInputStream (consumer) can only connect to a single PipedOutputStream (producer), and it wouldn&amp;rsquo;t be safe to share the PipedOutputStream with multiple threads without further synchronization. So on the consumer you would need 2 PipedInputStreams, one connecting to each producer&amp;rsquo;s PipedOutputStream. In your situation of 2 producers -&amp;gt; 1 consumer, a thread safe Queue implementation will be easier. Both producers and the consumer can use the same Queue. But that may not be exactly what you want.
A Queue may be easier for the general purpose but if you have pre-written code optimized around stream communication, then perhaps the Pipe connection would be easier to implement - specifically if the data is all primitives or Strings (where PipedReader/Writer could be used).
Which will be faster is hard to predict. If you can get both working safely the only way to make the speed comparison would be to test. My guess is that the performance factor will be not be worth comparing though. Either using Streams to communicate or using Queues to collate data will be the better design decision.
</content>
    </entry>
    
     <entry>
        <title>Cross-domain Browser Requests</title>
        <url>http://yangchao.me/post/cross-domain-browser-requests/</url>
        <categories>
          <category>Javascript</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html">  Problem origin Browsers prohibit scripts in a page from one domain to request some resources from another domain.
Take a scenario as an example:
A page named 1.html from http://dev.company.com/1.html has a script requesting a resource from another domain by use of url: http://sit.company.com/dosomething. This case is called Cross Domain Request. This is due to the browser&amp;rsquo;s Same-origin Policy.
This is only limited to Javascript request like AJAX, and not limited to normal resource references:
1. hypertext link by &amp;lt;a href=&amp;ldquo;&amp;hellip;&amp;rdquo;&amp;gt;
_2. image by &amp;lt;img src=&amp;ldquo;&amp;hellip;&amp;rdquo;&amp;gt;_
_3. external _css stylesheet link by &amp;lt;link type=&amp;ldquo;text/css&amp;rdquo; href=&amp;ldquo;&amp;hellip;&amp;rdquo;&amp;gt;
4. external javascript by &amp;lt;script type=&amp;ldquo;text/javascript&amp;rdquo; src=&amp;ldquo;&amp;hellip;&amp;rdquo;&amp;gt;
5. form action by_ &amp;lt;form action=&amp;ldquo;&amp;hellip;&amp;rdquo;&amp;gt;_
6. iframe by &amp;lt;iframe src=&amp;ldquo;&amp;hellip;&amp;rdquo;&amp;gt;
How to resolve this issue 1. JSONP JSONP, aka JSON with Padding. It actually makes use of the normal external javascript reference. a HTML &amp;amp;lt;script&amp;amp;gt; element specifies for its src attribute a URL that returns JSON.
For example, in the page of url http://localhost:8080/aes-gui/simple/poc/main/sum:
&amp;lt;script type=&amp;#34;text/javascript&amp;#34;&amp;gt; function callback_for_response(data) { // data is the response } &amp;lt;/script&amp;gt; &amp;lt;script type=&amp;#34;text/javascript&amp;#34; src=&amp;#34;http://DEV:8080/aes-gui/simple/poc/main/add?callback=callback_for_response&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; When the application on domain sit.company.com has received this request, and found the query parameter &amp;ldquo;callback&amp;rdquo;(this is a kind of contract, others also use &amp;ldquo;jsonp&amp;rdquo; or anything others), then it generates the response like this:
callback_for_response({a: 1, b: 2, c: &amp;#34;3&amp;#34;}) You see, the response JSON data {a:1, b:2, c:&amp;ldquo;3&amp;rdquo;} is surrounded/padded by the passed parameter &amp;ldquo;callback_for_response&amp;rdquo;, which is the origin of JSON with Padding.
JSONP has a number of limitations like, it supports only GET requests and not PUT, POST, DELETE, etc and it does not also send headers across.
2. Proxying Proxying is so simple that the client doesn&amp;rsquo;t need to know the cross domain requests. It accesses the urls all from the same domain. And the proxy server is responsible for the request to another domain.
In fact, it&amp;rsquo;s more like a solution of system integration.
3. CORS (Cross Origin Resource Sharing) CORS is an evolution of JSONP.
CORS stands for Cross Origin Resource Sharing, which allows you to share GET, POST, PUT, and DELETE requests and CORS is supported by the modern browsers.The CORS make use of 2 requests.
Request 1: “OPTIONS” request as part of the handshake to determine if cross domain is allowed by the server.
If server allows the request, it adds a response header - Access-Control-Allow-Origin: &amp;lsquo;*&amp;rsquo;
Request 2: GET, POST, PUT, or DELETE request that performs the actual operation on the server.
&amp;nbsp;
&amp;nbsp;
</content>
    </entry>
    
     <entry>
        <title>Get started with WebLogic</title>
        <url>http://yangchao.me/post/get-started-with-weblogic/</url>
        <categories>
          <category>Middlewares</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html">  Concepts: Domain, Admin Server, Managed Server, Node Manager   WebSphere WebLogic   Profile Domain   Node Agent Node Manager    Admin Server   Application Server Managed Server    WebSphere has standalone version and Network Deploy version (ND). In ND version, there is a central management node and another application nodes. And the node agent is a communication bridge among the management unit.
In WebLogic, the concepts are clearer and the management function is more intuitive.
&amp;nbsp;
This figure is a typical plan of a WebLogic domain. In it, all the node managers, managed servers, and admin server are seperated JVM processes. It&amp;rsquo;s worth noticing that machine 3 has two managed server processes.
As mentioned previously, node manager is also a process running on a physical or virtualised machine called Node for responding the management tasks from admin server.
A managed server is managed by admin server, and is a standard J2EE application server including many services and servlet / EJB container which you can deploy your enterprise or web application into.
Admin server provides all sorts of management and a web admin console. In a domain, there can be only one admin server.
</content>
    </entry>
    
     <entry>
        <title>Java Transaction - JDBC, JTA, JTS</title>
        <url>http://yangchao.me/post/javaee-java-transaction-jdbc-jta-jts/</url>
        <categories>
          <category>JDBC</category><category>JTA</category><category>Transaction Management</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html">  https://www.progress.com/products/datadirect-connect/jdbc-drivers/jdbc-developer-center/jdbc-tutorials/understanding-jta---the-java-transaction-api/accessing-databases
Concepts and implementation Where these come from? In transaction processing, there are several participants:
Resource Manager: like RDMS, JMS Providers(MQ), JCA Resources, transnational distributed systems
It is important to understand what constitutes a resource, in this context. For example, if you are using a JMS product, the JMS resource is the single running instance of the JMS product, not the individual queues and topics. Moreover, sometimes, what appears to be multiple resources might actually be a single resource, if the same underlying resource is accessed in different ways. For example, your application might access a relational database both directly (through JDBC) and indirectly (through an object-relational mapping tool like Hibernate). In this case, the same underlying transaction manager is involved, so it should be possible to enrol both of these code fragments in the same transaction.
Resource Adapters: JDBC drivers &amp;hellip;
Transaction Manager: the part of an application that is responsible for coordinating transactions across one or more resources.
J2EE servers: EJB containers..
&amp;nbsp;
Of these, transaction manager is the core role. Two categories of transaction manager:
Local transaction manager:
a transaction manager that can coordinate transactions over a single resource only. In this case, the implementation of the transaction manager is typically embedded in the resource itself.
For example, the Oracle database has a built-in transaction manager that supports demarcation operations (using SQL operations, BEGIN, COMMIT, ROLLBACK, or using a native Oracle API) and various levels of transaction isolation. Control over the Oracle transaction manager can be exported through JDBC, which is how Spring is able to abstract and wrap this kind of transaction manager as local transaction manager.
When we use resource local transaction in Java, we completely depend on database (a resource manager) to provide transaction support.
This is supported by JDBC API.
In the class Connection, there are several methods related to the resource local transaction:
setAutoCommit(boolean) commit() rollback() setTransactionIsolation() Global transaction manager:
A global transaction manager is a transaction manager that can coordinate transactions over multiple resources. In this case, you cannot rely on the transaction manager built into the resource itself. Instead, you require an external system, sometimes called a transaction processing monitor (TP monitor), that is capable of coordinating transactions across different resources.
So the transactions coordinated by global transaction manager are called global transaction. And the transactions related with single resource and not coordinated by global transaction manager are called local transaction.
&amp;nbsp;
Unlike the above general concepts, in implementation and standard level of Java transaction support:
XA transaction is a kind of global distributed transaction which allow across multiple X/Open XA resources.
JTA support XA transaction and the related classes: UserTransaction, TransactionManager, XADataSource, XAResource, XAConnection.
JTA transaction manager is also a kind of global transaction manager, which usually runs in application server as a process and communicates with transaction participants during the two-phase commit protocol. &amp;gt; XA Transaction and XA Data source &amp;gt; &amp;gt; &amp;gt; The JTA allows distributed transactions across multiple X/Open XA resources. XA stands for Extended Architecture which was developed by the X/Open Group to define a transaction which uses more than one back-end data store. The XA standard describes the interface between a global Transaction Manager &amp;trade; and a local resource manager. XA allows multiple resources, such as application servers, databases, caches, and message queues, to participate in the same transaction, while preserving atomicity of the transaction. &amp;gt; &amp;gt; &amp;gt; An XA datasource is a datasource which can participate in an XA global transaction. &amp;gt; &amp;gt; &amp;gt; 2-Phase Commit Protocol &amp;gt; &amp;gt; &amp;gt; The Two-phase commit protocol (2PC) refers to the typical pattern of a database transaction. &amp;gt; &amp;gt; Phase 1 &amp;gt; &amp;gt; In the first phase, the transaction participants notify the transaction manager whether they are able to commit the transaction or must roll back. &amp;gt; Phase 2 &amp;gt; &amp;gt; In the second phase, the transaction manager makes the decision about whether the overall transaction should commit or roll back. If any one of the participants cannot commit, the transaction must roll back. Otherwise, the transaction can commit. The manager directs the transactions about what to do, and they notify the manager when they have done it. At that point, the transaction is finished.  Because JTA transaction is not distributed across multiple application servers, and cannot be nested, when we need to cross multiple J2EE containers, JTS is for this purpose.
Java Transaction Service (JTS) is a mechanism for supporting Java Transaction API (JTA) transactions when participants of the transactions reside in multiple J2EE containers (application servers). In JTS transactions, the Transaction Coordinator manages interactions between transaction managers on different servers.
From an application standpoint, a JTS transaction behaves in the same ways as a JTA transaction. The difference is that transaction participants and datasources reside in different containers.
How JTA is supported? The Java Transaction API consists of three elements: a high-level application transaction demarcation interface, a high-level transaction manager interface intended for an application server, and a standard Java mapping of the X/Open XA protocol intended for a transactional resource manager.
[javax.transaction.UserTransaction](http://docs.oracle.com/javaee/7/api/javax/transaction/UserTransaction.html), that is used by general client code such as a servlet or an EJB to manage the transactions, but it is usually acquired by JNDI reference (it should be available under java:comp/UserTransaction), and is usually injected into EJB when you use Container-Managed Transaction(CMT).
[javax.transaction.TransactionManager](http://docs.oracle.com/javaee/7/api/javax/transaction/TransactionManager.html), that is implemented by the application server itself to begin, commit and rollback the transactions.
[javax.transaction.xa.XAResource](http://docs.oracle.com/javaee/7/api/javax/transaction/xa/XAResource.html) interface is required to implement by each resource manager in order to be managed by the TP monitor. Each resource will have its own specific API, for instance:
 relational databases use JDBC (XADataSource, XAConnection are implemented by XA JDBC driver) messaging services use JMS generalized EIS (Enterprise Information System) resources use JCA (Java EE Connector API). &amp;gt; _If you are interested in how to implement a simple/naive transaction manager just like it&amp;rsquo;done in application server, please refer to:_http://blog.csdn.net/liu78778/article/details/4805308  How can we use them in traditional J2EE enviorment? UserTransaction support in servlet :
import javax.transaction.*； import javax.naming.*； // ... InitialContext ctx = new InitialContext()； Object txObj = ctx.lookup(&amp;#34;java:comp/UserTransaction&amp;#34;；)； UserTransaction utx = (UserTransaction) txObj； utx.begin(); // ... DataSource ds = obtainXADataSource(); Connection conn = ds.getConnection(); pstmt = conn.prepareStatement(&amp;#34;UPDATE MOVIES ...&amp;#34;); pstmt.setString(1, &amp;#34;Spinal Tap&amp;#34;); pstmt.executeUpdate(); // ... utx.commit(); UserTransaction support in EJB: 
@Stateless @TransactionManagement(BEAN) public class ExampleBean { @Resource private UserTransaction utx; public void foo() { // start a transaction  utx.begin(); // Do work  // Commit it  utx.commit(); } } For more details, you need to refer to the EJB transaction management(CMT).
Spring transaction management abstraction Spring intends to abstract these transaction management technology, and integrate them into a unified API.
PlatformTransactionManager is a service provider interface Spring provides. (NOTE, it&amp;rsquo;s not the subclass of javax.transaction.TransactionManager).
Currently, there are the following implementations: Table 1 summarizes the local transaction manager implementations provided by the Spring framework. These transaction managers are distinguished by the fact that they support a single resource only.
Table 1. Local Transaction Managers     Transaction Manager Description     JmsTransactionManager A transaction manager implementation that is capable of managing a single JMS resource. That is, you can connect to any number of queues or topics, but only if they belong to the same underlying JMS messaging product instance. Moreover, you cannot enlist any other types of resource in a transaction.For example, using this transaction manager, it would not be possible to enlist both a SonicMQ resource and an Apache ActiveMQ resource in the same transaction. But see Table 2.   DataSourceTransactionManager A transaction manager implementation that is capable of managing a single JDBC database resource. That is, you can update any number of different database tables, but only if they belong to the same underlying database instance.   HibernateTransactionManager A transaction manager implementation that is capable of managing a Hibernate resource. It is not possible, however, to simultaneously enlist any other kind of resource in a transaction.   JdoTransactionManager A transaction manager implementation that is capable of managing a Java Data Objects (JDO) resource. It is not possible, however, to simultaneously enlist any other kind of resource in a transaction.   JpaTransactionManager A transaction manager implementation that is capable of managing a Java Persistence API (JPA) resource. It is not possible, however, to simultaneously enlist any other kind of resource in a transaction.   CciLocalTransactionManager A transaction manager implementation that is capable of managing a Java Connection Architecture (JCA) resource. It is not possible, however, to simultaneously enlist any other kind of resource in a transaction.       Table 2 summarizes the global transaction manager implementations provided by the Spring framework. These transaction managers are distinguished by the fact that they can support multiple resources.
Table 2. Global Transaction Managers     Transaction Manager Description     JtaTransactionManager If you require a transaction manager that is capable of enlisting more than one resource in a transaction, use the JTA transaction manager, which is capable of supporting the XA transaction API. You must deploy your application inside either an OSGi container or a J2EE server to use this transaction manager.   OC4JJtaTransactionManagner A specialization of the JtaTransactionManager to work with Oracle&amp;rsquo;s OC4J. The advantage of this implementation is that it makes Spring-driven transactions visible in OC4J&amp;rsquo;s transaction monitor   WebLogicJtaTransactionManager A specialization of the JtaTransactionManager to work with the BEA WebLogic container. Makes certain advanced transaction features available: transaction names, per-transaction isolation levels, and proper suspension/resumption of transactions.   WebSphereUowTransactionManager A specialization of the JtaTransactionManager to work with the IBM WebSphere container. Enables proper suspension/resumption of transactions.      
</content>
    </entry>
    
     <entry>
        <title>JPA - runtime</title>
        <url>http://yangchao.me/post/jpa-runtime/</url>
        <categories>
          <category>JPA</category><category>Transaction Management</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html">  Core concepts   org.hibernate javax.persistence 说明     cfg.Configuration PersistenceUnit 读取配置信息   SessionFactory EntityManagerFactory 用于创建会话/实体管理器的工厂类   Session EntityManager 提供实体操作API，管理事务，创建查询   Transaction EntityTransaction 管理事务   Query Query 执行查询Here&#39;s a quick cheat sheet of the JPA world:     A Cache is a copy of data, copy meaning pulled from but living outside the database. Flushing a Cache is the act of putting modified data back into the database. A PersistenceContext is essentially a Cache. It also tends to have it&amp;rsquo;s own non-shared database connection. An EntityManager represents a PersistenceContext (and therefore a Cache) An EntityManagerFactory creates an EntityManager (and therefore a PersistenceContext/Cache) &amp;gt; Cache == PersistenceContext  Entity Manager A persistence unit is a named configuration of entity classes.
A persistence context is a managed set of entity instances.
An EntityManager instance is associated with a persistence context.
Saying that an entity is managed meas that it&amp;rsquo;s contained within a persistence context and it can be acted upon by an entity manager.
 An EntityManagerFactory is an expensive-to-create, threadsafe object intended to be shared by all application threads. An EntityManager is an inexpensive, non-threadsafe object that should be used once, for a single business process, a single unit of work, and then discarded  Container-managed entity manager @PersistenceContext(unitName=&amp;#34;EmployeeService&amp;#34;) private EntityManager em; It can be injected by using the @PersistenceContext, and you don&amp;rsquo;t create or manage the lifecycle of the entity manager. This type of entity manager is typically used in Java EE environment. &amp;gt; NOTICE: if you use Spring-orm for JPA integration, this @PersistenceContext is also supported by Spring bean context. A container-managed entity manger requires the use of a JTA transaction.
a. Transaction-scoped It depends on JTA transaction, it use the transaction to trace persistence context. Every time when an operation is invoked on entity manager, the proxy of the persitence manager checks to see whether a persistence is associated with the container JTA transaction. If yes, just use it. If not, it creates a new persistence context and associates it with the transaction. When the transaction ends, the persistence context goes away.
b. Extended Specially designed for stateful bean, the persistence context of extended persistence manager lasts until the end of conversation instead of transaction.
Application-managed entity manager EntityManagerFactory emf = Persistence.createEntityManagerFactory(&amp;#34;EmployeeService&amp;#34;); EntityManager em = emf.createEntityManager(); You can control the entity manager in your application, including its creating, closing, transaction etc. This type of entity manager is typically used in J2SE or some non-EJB Java EE environment.
The best way to create an entity manager is to use the @PersistenceUnit
@PersistenceUnit(unitName=&amp;#34;EmpoyeeService&amp;#34;) private EntityManagerFactory emf; When the application-managed entity manager is created, it creates its own private persistence context that lasts until the entity manager is closed.
 An application managed entity manager can be either involved in the current JTA transaction (a JTA entity manager), or the transaction may be controlled through the EntityTransaction API (a resource-local entity manager).
Entity states and operations Transaction management two transaction management types:
1) resource-local: using the native transaction of the JDBC driver
2) JTA: Jave EE server, supporting multiple participating resources, transaction lifecycle management, and distributed XA transactions. Also know as global transaction.
Query Language </content>
    </entry>
    
     <entry>
        <title>JPA - mapping</title>
        <url>http://yangchao.me/post/jpa-mapping/</url>
        <categories>
          <category>JPA</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html">  Table mapping @Entity @Table(name=&amp;#34;EMP&amp;#34;, schema=&amp;#34;scott&amp;#34;) Basic mapping   Java type Database type   String (char, char[]) VARCHAR (CHAR, VARCHAR2, CLOB, TEXT)   Number (BigDecimal, BigInteger, Integer, Double, Long, Float, Short, Byte) NUMERIC (NUMBER, INT, LONG, FLOAT, DOUBLE)   int, long, float, double, short, byte NUMERIC (NUMBER, INT, LONG, FLOAT, DOUBLE)   byte[] VARBINARY (BINARY, BLOB)   boolean (Boolean) BOOLEAN (BIT, SMALLINT, INT, NUMBER)   java.util.Date TIMESTAMP (DATE, DATETIME)   java.sql.Date DATE (TIMESTAMP, DATETIME)   java.sql.Time TIME (TIMESTAMP, DATETIME)   java.sql.Timestamp TIMESTAMP (DATETIME, DATE)   java.util.Calendar TIMESTAMP (DATETIME, DATE)   java.lang.Enum NUMERIC (VARCHAR, CHAR)   java.util.Serializable VARBINARY (BINARY, BLOB)    @Basic annotation is optional. Any attributes that have no other annotations and do not reference other entities will be automatically mapped as basic, and even serialized if not a basic type. This is auto-mapping.
customize the default mapping
lazy fetching @Basic can specify the lazy fetching mode.
@Basic(fetch=FetchType.LAZY) specify the column name - @Column @Column(name=&amp;#34;ADDR&amp;#34;) large object - @Lob @Lob temporal types for java.util.Date and java.util.Calendar - @Temporal If you just want to map DATE, TIME, TIMESTAMP to java.sql.Date, java.sql.Time, java.sql.Timestamp, the basic mapping is just OK.
@Temporal(TemporalType.DATE) private Calendar dob; transient state - @Transient transit private String s; @Transient private String s; enums - @Enumerated @Basic @Enumerated(EnumType.STRING) private Gender gender; primary Key  primitive type: byte, int, short, long, char, (float, double) wrapper classes of primitives: Byte, Integer, Short, Long, Character, (Float, Double) string: String large numeric type: java.math.BigInteger, (java.math.BigDecimal) temporal type: java.sql.Date, java.util.Date WARNING: using floating types for primary keys is risky endevour and is not recommended.  there are 4 types of identity generation.
Automatic @Id @GeneratedValue(strategy=GenerationType.AUTO) private long id; The provider can choose table-based strategy or sequence-based strategy. This strategy may need schema generation and is a choice for development or prototyping. It&amp;rsquo;s not recommended for other cases. You should always specify the other three strategies.
Table @Id @GeneratedValue(stategy=GenerationType.TABLE) private long id; This will use the default table assumed by the provider. So it&amp;rsquo;s better to declare more detailed generator by giving the specified table.
@TableGenerator(name=&amp;#34;Emp_Gen&amp;#34;, table=&amp;#34;ID_GEN&amp;#34;, pkColumnName=&amp;#34;GEN_NAME&amp;#34;, valueColumnName=&amp;#34;GEN_VAL&amp;#34;, pkColumnValue=&amp;#34;Emp_Gen&amp;#34;, initialValue=1000, allocationSize=100000) @Id @GeneratedValue(generator=&amp;#34;Emp_Gen&amp;#34;) private long id; Sequence @Id @GeneratedValue(strategy=GenerationType.SEQUENCE) private long id; This will also use the default sequence assumed by the provider. But a problem is that this default sequence will be shared by different entity.
@SequenceGenerator(name=&amp;#34;Emp_Gen&amp;#34;, sequenceName=&amp;#34;Emp_Seq&amp;#34;, initialValue=1, allocationSize=10000) @Id @GeneratedValue(generator=&amp;#34;Emp_Gen&amp;#34;) private long id; It depends on whether you enable the schema generation. If no, the sequence must already exist; If yes, the SQL to create the sequence is run by the provider.
Identity @Id @GeneratedValue(strategy=GenerationType.IDENTITY) private long id; Identity column is supported by some databases. Using this mode means the identifier is not available until after commit time.
Relationship   Relationship Owning-Side Inverse-Side     one-to-one @OneToOne @OneToOne(mappedBy=&amp;ldquo;othersideName&amp;rdquo;)   one-to-many / many-to-one @ManyToOne @OneToMany(mappedBy=&amp;ldquo;othersideName&amp;rdquo;)   many-to-many @ManyToMany @ManyToMany(mappedBy =&amp;ldquo;xxx&amp;rdquo;)    For many-to-many mapping, you can using join table to declare the many-to-many relationship
@ManyToMany @JoinTable(name = &amp;#34;BOOK_AUTHOR&amp;#34;, joinColumns = { @JoinColumn(name = &amp;#34;BOOK_ID&amp;#34;, referencedColumnName = &amp;#34;id&amp;#34;) }, inverseJoinColumns = { @JoinColumn(name = &amp;#34;AUTHORID&amp;#34;, referencedColumnName = &amp;#34;id&amp;#34;) }) The three relationships can use fetch=FetchType.LAZY.
Inheritance JPA通过在父类增加@Inheritance(strategy=InheritanceType.xxx)来声明继承关系。A支持3种继承策略：
 单表继承（InheritanceType.SINGLETABLE），所有继承树上的类共用一张表，在父类指定（@DiscriminatorColumn）声明并在每个类指定@DiscriminatorValue来区分类型。 类表继承（InheritanceType.JOINED），父子类共同的部分公用一张表，其余部分保存到各自的表，通过join进行关联。 具体表继承（InheritanceType.TABLEPERCLASS)，每个具体类映射到自己的表。 其中1和2能够支持多态，但是1需要允许字段为NULL，2需要多个JOIN关系；3最适合关系数据库，对多态支持不好。具体应用时根据需要取舍。  Embeddables Advanced mapping element collection </content>
    </entry>
    
     <entry>
        <title>Get started with Oracle 11g</title>
        <url>http://yangchao.me/post/oracle-a-short-jouney/</url>
        <categories>
          <category>Databases</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html"> </content>
    </entry>
    
     <entry>
        <title>output - pre-increment and post-increment</title>
        <url>http://yangchao.me/post/output-pre-increment-and-post-increment/</url>
        <categories>
          <category>Basics</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html"> public static void main(String [] args) { int x= 0; int y= 0; for (int z = 0; z &amp;lt; 5; z&#43;&#43;) { if (( x&#43;&#43; &amp;gt; 2 ) || (y&#43;&#43; &amp;gt; 2)) { x&#43;&#43;; } } System.out.println(x &#43; &amp;#34; &amp;#34; &#43; y); } Output is: 7 3
public static void main(String [] args) { int x= 0; int y= 0; for (int z = 0; z &amp;lt; 5; z&#43;&#43;) { if (( &#43;&#43;x &amp;gt; 2 ) || (&#43;&#43;y &amp;gt; 2)) { x&#43;&#43;; } } System.out.println(x &#43; &amp;#34; &amp;#34; &#43; y); } Output is: 8 2
Two things you should notice: 1) defference between pre-increment and post-increment 2) boolean expression: a. for logic add, if the former condition is false, the following conditions won&amp;rsquo;t be evaluated b. for logic or, if the former condition is true, the following conditions won&amp;rsquo;t be evaluated
</content>
    </entry>
    
     <entry>
        <title>scriptless JSP - EL, JSTL and taglibs</title>
        <url>http://yangchao.me/post/javaee-scriptless-jsp-el-jstl-and-taglibs/</url>
        <categories>
          <category>Servlet / JSP</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html">  EL (Expression Language) for non-Java programmer or designers email: &amp;lt;%= application.getAttribute(&amp;ldquo;email&amp;rdquo;) %&amp;gt;
email: ${applicationScope.email}
Implicit objects in EL:  pageContext: The context for the JSP page. NOTE: you cannot directly get the objects: application, session, request, response, page, but you can get them through pageContext.  In addition, several implicit objects are available that allow easy access to the following objects:
 param: Maps a request parameter name to a single value paramValues: Maps a request parameter name to an array of values header: Maps a request header name to a single value headerValues: Maps a request header name to an array of values cookie: Maps a cookie name to a single cookie initParam: Maps a context initialization parameter name to a single value Finally, there are objects that allow access to the various scoped variables.
 pageScope: Maps page-scoped variable names to their values
 requestScope: Maps request-scoped variable names to their values
 sessionScope: Maps session-scoped variable names to their values
 applicationScope: Maps application-scoped variable names to their values
  </content>
    </entry>
    
     <entry>
        <title>JSP basics</title>
        <url>http://yangchao.me/post/jsp-basics/</url>
        <categories>
          <category>Servlet / JSP</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html">  How JSP work Syntax scriptlet &amp;lt;% int count=0; out.println(&amp;#34;This is a scriptlet&amp;#34;); %&amp;gt; This block is placed in the body of method _jspService(request, response)
derective &amp;lt;%@ page import=&amp;#34;java.util.*,java.xml.*&amp;#34; %&amp;gt;&amp;lt;%@ include file=&amp;#34;xxx&amp;#34; %&amp;gt;&amp;lt;%@ taglib tagdir=&amp;#34;/WEB-INF/tags/xxx&amp;#34; prefix=&amp;#34;xxx&amp;#34; %&amp;gt; expression &amp;lt;%= &amp;#34;This is a expression argument&amp;#34; %&amp;gt; declaration &amp;lt;%! int count=0 %&amp;gt;&amp;lt;%! int doubleCount() { count = count*2; return count; } %&amp;gt; This is equivlant with the member field and member method of the generated servlet.
comment &amp;lt;!-- HTML Comments --&amp;gt; &amp;lt;%-- JSP Comments --%&amp;gt; The first is called output comments, while the second is called hidden comments.
implicit Objects in scriptlets and expressions   Type implicit variable   JspWriter out   HttpServletRequest request   HttpServletResponse response   HttpSession session   ServletContext application   ServletConfig config   Throwable exception   PageContext pageContext   HttpJspPage page    about the generated servlet it&amp;rsquo;s a subclass of HttpJspPage, which inherited JspPage
In JSP, you can get its reference by a implicit object named page.
The methods of JspPage:
jspInit() jspDestroy() The methods of HttpJspPage
_jspService() You can override the jspInit() and jspDestroy() methods, but not for _jspService() method.
about the PageContext PageContext is a subclass of JspContext. about the configuration 1. config jsp for global in deployment descriptor
&amp;lt;web-app ...&amp;gt; ... &amp;lt;jsp-config&amp;gt; &amp;lt;jsp-property-group&amp;gt; &amp;lt;url-pattern&amp;gt;*.jsp&amp;lt;/url-pattern&amp;gt; &amp;lt;el-ignored&amp;gt;true&amp;lt;/el-ignored&amp;gt; &amp;lt;scripting-invalid&amp;gt;true&amp;lt;/scripting-invalid&amp;gt; &amp;lt;/jsp-property-group&amp;gt; ... &amp;lt;/web-app&amp;gt; 2. config jsp in the page directive
&amp;lt;%@ page isELIgnored=&amp;#34;true&amp;#34; isScriptingEnabled=&amp;#34;false&amp;#34; .... %&amp;gt; &amp;nbsp;
</content>
    </entry>
    
     <entry>
        <title>JMM, Atomicity,  Visibility and Reordering</title>
        <url>http://yangchao.me/post/java-memory-model-atomicity-visibility-and-reordering/</url>
        <categories>
          <category>Concurrency</category><category>Multithreading</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html">  Memory that can be shared between threads is called shared memory or heap memory. The term variable as used in this section refers to both fields and array elements. Variables that are shared between threads are referred to as shared variables. All instance fields, static fields, and array elements are shared variables and are stored in heap memory. Local variables, formal method parameters, and exception handler parameters are never shared between threads and are unaffected by the memory model.
In modern shared-memory multiprocessor architectures, each processor has one or more levels of cache that are periodically reconciled with main memory as shown in the following figure:
Visibility The visibility of writes to shared variables can be problematic because the value of a shared variable may be cached; writing its value to main memory may be delayed. Consequently, another thread may read a stale value of the variable.
Cause:
 memory caching compiler optimizations &amp;nbsp;  </content>
    </entry>
    
     <entry>
        <title>Thread Synchronization</title>
        <url>http://yangchao.me/post/thread-synchronization/</url>
        <categories>
          <category>Concurrency</category><category>Multithreading</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html">  Two questions about synchronized  mutual exclusion - shared data access among multiple threads - coordinating activities Some of the Java virtual machine&amp;rsquo;s runtime data areas are shared by all threads, others are private to individual threads.   The heap and method area are shared by all threads, Java programs need to coordinate multi-threaded access to two kinds of data:
 b. class variables, which are stored in the method area
 a. instance variables, which are stored on the heap
 Programs never need to coordinate access to local variables, which reside on Java stacks, because data on the Java stack is private to the thread to which the Java stack belongs.
  Monitors The mechanism that Java uses to support synchronization is the monitor, which supports two kinds of thread synchronization: mutual exclusion and cooperation.
Mutual exclusion, which is supported in the Java virtual machine via object locks, enables multiple threads to independently work on shared data without interfering with each other. Cooperation, which is supported in the Java virtual machine via the wait and notify methods of class Object, enables threads to work together towards a common goal.
A monitor is like a building that contains one special room that can be occupied by only one thread at a time. The room usually contains some data. From the time a thread enters this room to the time it leaves, it has exclusive access to any data in the room. Entering the monitor building is called &amp;ldquo;entering the monitor.&amp;rdquo; Entering the special room inside the building is called &amp;ldquo;acquiring the monitor.&amp;rdquo; Occupying the room is called &amp;ldquo;owning the monitor,&amp;rdquo; and leaving the room is called &amp;ldquo;releasing the monitor.&amp;rdquo; Leaving the entire building is called &amp;ldquo;exiting the monitor.&amp;rdquo;
In addition to being associated with a bit of data, a monitor is associated with one or more bits of code, which in this book will be called monitor regions.
http://www.artima.com/insidejvm/ed2/threadsynch.html
In this figure, number 2 and number 4 acquiring monitor is unpredictable, which is scheduled by JVM and implementation-dependent. Number 3 releasing monitor can be done by invoking wait() method.
Because sleep() have no change with the monitor, so this can explain why sleep is the class method of Thread instead of Object.
How to understand?
An object has a monitor to protect its data (instance variables or class variables).
When applying sychronized, it basically declare two things.
 specify the lock associated with the synchronized object using as privilege mark the code (aka. monitor region) to be monitored by that monitor associated with the synchronized object  Object locking by _intrinsic lock _or monitor lock (The API specification often refers to this lock entity simply as a &amp;ldquo;monitor.&amp;rdquo;)
In the Java virtual machine, every object and class is logically associated with a monitor. For objects, the associated monitor protects the object&amp;rsquo;s instance variables. For classes, the monitor protects the class&amp;rsquo;s class variables. If an object has no instance variables, or a class has no class variables, the associated monitor protects no data.
To implement the mutual exclusion capability of monitors, the Java virtual machine associates a lock (sometimes called a mutex) with each object and class. A lock is like a privilege that only one thread can &amp;ldquo;own&amp;rdquo; at any one time. Threads need not obtain a lock to access instance or class variables. If a thread does obtain a lock, however, no other thread can obtain a lock on the same data until the thread that owns the lock releases it. (To &amp;ldquo;lock an object&amp;rdquo; is to acquire the monitor associated with that object.)
Note that as a Java programmer, you never explicitly lock an object. Object locks are internal to the Java virtual machine. In your Java programs, you identify the monitor regions of your program by writing synchronized statements and methods. As the Java virtual machine runs your program, it automatically locks an object or class every time it encounters a monitor region.
Reentrant A single thread is allowed to lock the same object multiple times. For each object, the Java virtual machine maintains a count of the number of times the object has been locked. An unlocked object has a count of zero. When a thread acquires the lock for the first time, the count is again incremented to one. Each time the thread acquires a lock on the same object, the count is again incremented. (Only the thread that already owns an object&amp;rsquo;s lock is allowed to lock it again. As mentioned previously, no other thread can lock the object until the owning thread releases the lock.) Each time the thread releases the lock, the count is decremented. When the count reaches zero, the lock is released and made available to other threads.
volatile  //TODO
&amp;ldquo;Wait and Notify&amp;rdquo; monitor (aka. &amp;rdquo;Signal and Continue&amp;rdquo; monitor) In this kind of monitor, a thread that currently owns the monitor can suspend itself inside the monitor by executing a wait command. When a thread executes a wait, it releases the monitor and enters a wait set. The thread will stay suspended in the wait set until some time after another thread executes a notify command inside the monitor. When a thread executes a notify, it continues to own the monitor until it releases the monitor of its own accord, either by executing a wait or by completing the monitor region. After the notifying thread has released the monitor, the waiting thread will be resurrected and will reacquire the monitor.
a. When a thread has acquired the monitor and invoke wait() on this object, this thread release its acquired monitors, and enter the waiting set. b. When another thread has acquired the monitor and invoke notify() or notifyAll() on the same object, then the waiting state of one thread or all threads in the waiting area ends and the thread starts attempting to regain all the monitors. At one time there may be several threads trying to regain (or maybe gain for the first time) their monitors. If more than one threads attempt to acquire the monitor of a particular object then only one thread (selected by the JVM scheduler) is granted the monitor and all other threads are put into BLOCKED state.
The following pictures demonstrate the lock and wait/notify mechanism: &amp;gt; Legend: Blue - BLOCKED Green - RUNNABLE (running) White - WAITING &amp;gt; &amp;gt; &amp;gt; Threads in waiting state can be interrupted, but cannot in blocked state. [caption id=&amp;ldquo;attachment_209&amp;rdquo; align=&amp;ldquo;alignleft&amp;rdquo; width=&amp;ldquo;235&amp;rdquo;]Thread 1 acquires the lock and starts running; other threads cannot acquire the lock, so they are BLOCKED[/caption]
[caption id=&amp;ldquo;attachment_202&amp;rdquo; align=&amp;ldquo;alignleft&amp;rdquo; width=&amp;ldquo;235&amp;rdquo;]Thread 1 invokes wait(), releases the lock and gets await; thread 4 acquires the lock and starts running[/caption]
[caption id=&amp;ldquo;attachment_203&amp;rdquo; align=&amp;ldquo;alignleft&amp;rdquo; width=&amp;ldquo;235&amp;rdquo;]Thread 4 also invokes wait() ; thread 3 acquire the released lock and starts running[/caption]
[caption id=&amp;ldquo;attachment_204&amp;rdquo; align=&amp;ldquo;alignleft&amp;rdquo; width=&amp;ldquo;235&amp;rdquo;]Thread 4 exits; thread 2 acquires the lock and starts running[/caption]
[caption id=&amp;ldquo;attachment_206&amp;rdquo; align=&amp;ldquo;alignleft&amp;rdquo; width=&amp;ldquo;235&amp;rdquo;]Thread 2 exits; thread 4 reacquires the lock and gets running[/caption]
[caption id=&amp;ldquo;attachment_207&amp;rdquo; align=&amp;ldquo;alignleft&amp;rdquo; width=&amp;ldquo;235&amp;rdquo;]Thread 4 exits; thread 1 reacquires the lock and goes running once again.[/caption]
Examples 1. A typical scenario is that there is a customer account which can be deposited and fetched at the same time.
public class ATM { final static CyclicBarrier cyclicBarrier = new CyclicBarrier(4); public static void main(String[] args) throws InterruptedException { final Account account = new Account(); ThreadGroup group = new ThreadGroup(&amp;#34;group&amp;#34;); for(int i = 11; i &amp;lt; 13; &#43;&#43;i) { new Thread(&amp;#34;D #&amp;#34; &#43; i) { public void run() { try { cyclicBarrier.await(); } catch (InterruptedException e) { e.printStackTrace(); } catch (BrokenBarrierException e) { e.printStackTrace(); } account.deposit(amount()); } }.start(); new Thread(&amp;#34;W #&amp;#34; &#43; i) { public void run() { try { cyclicBarrier.await(); } catch (InterruptedException e) { e.printStackTrace(); } catch (BrokenBarrierException e) { e.printStackTrace(); } account.withdraw(amount()); } }.start(); } } private static int amount() { return (int)(Math.random() * 100); } } class Account { private String id; private String customerName; private int balance = 0; public synchronized void deposit(int amount) { int oldBalance = balance; balance &#43;= amount; print(&amp;#34;Balance: ￥%d &#43; ￥%d =&amp;gt; ￥%d&amp;#34;, oldBalance, amount, balance); notifyAll(); } public synchronized void withdraw(int amount) { while(balance &amp;lt; amount) { try { print(&amp;#34;Balance: ￥%d - ￥%d =&amp;gt; FAIL&amp;#34;, balance, amount); wait(); } catch (InterruptedException e) { e.printStackTrace(); } } int oldBalance = balance; balance -= amount; print(&amp;#34;Balance: ￥%d - ￥%d =&amp;gt; ￥%d&amp;#34;, oldBalance, amount, balance); } private void print(String message, Object...args) { PrintStream ps = System.out; ps.format(&amp;#34;%s: &amp;#34;, Thread.currentThread().getName()); ps.format(message, args); ps.println(); } } One output is: W #11: Balance: ￥0 - ￥5 =&amp;gt; FAIL W #12: Balance: ￥0 - ￥23 =&amp;gt; FAIL D #12: Balance: ￥0 &#43; ￥30 =&amp;gt; ￥30 D #11: Balance: ￥30 &#43; ￥90 =&amp;gt; ￥120 W #12: Balance: ￥120 - ￥23 =&amp;gt; ￥97 W #11: Balance: ￥97 - ￥5 =&amp;gt; ￥92
Another output which will be await always: W #11: Balance: ￥0 - ￥54 =&amp;gt; FAIL W #12: Balance: ￥0 - ￥93 =&amp;gt; FAIL D #12: Balance: ￥0 &#43; ￥89 =&amp;gt; ￥89 D #11: Balance: ￥89 &#43; ￥28 =&amp;gt; ￥117 W #12: Balance: ￥117 - ￥93 =&amp;gt; ￥24 W #11: Balance: ￥24 - ￥54 =&amp;gt; FAIL ..(waiting here)..
</content>
    </entry>
    
     <entry>
        <title>Java Thread Management</title>
        <url>http://yangchao.me/post/topic-serial-threads/</url>
        <categories>
          <category>Multithreading</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html">  About thread:
1. Single-thread and multi-thread A single-thread program has a single entry point (the main() method) and a single exit point. A multi-thread program has an initial entry point (the main() method), followed by many entry and exit points, which are run concurrently with the main(). 2. Lifecycle In Java, there are only 6 states when invoking_ getState()_: NEW RUNNABLE BLOCKED WAITING TIMED_WAITING TERMINATED
In reality, we cannot differentiate the running or runnable but not running.
a. A thread is alive when it is started but has not died. We can check it by isAlive() b. A daemon thread or a user thread mark is useful when JVM determine if it should exit. JVM exits when the only threads running are all daemon threads.
3. Control through the lifecycle In the following writing, I will use &amp;ldquo;control thread&amp;rdquo; as the source thread which instantiate, operate the new produced thread, and the latter is &amp;ldquo;target thread&amp;rdquo;.
1) create a thread in control thread (execution context) We create a thread instance (a real thread representation in Java) by using new keyword. 
So some properties can be provided in constructors: a. ThreadGroup b. Runnable target (define what will be run) c. thread name d. stack size
Apart from these, there are the following perperties: e. daemon thread or user thread? f. priority g. id
Other important things:
a. stack trace (TODO)
getStackTrace() dumpStack() Thread.getAllStackTraces() b. uncaught exception handler (TODO)
getUncaughtExceptionHandler() setUncaughtExceptionHandler(UncaughtExceptionHandler) Thread.getDefaultUncaughtExceptionHandler() Thread.setDefaultUncaughtExceptionHandler(UncaughtExceptionHandler) c.context class loader (TODO)
getContextClassLoader() setContextClassLoader(ClassLoader) 2) start a thread in control thread public synchronized void start() Other methods like:
public final void stop(); public final synchronized void stop(Throwable obj); public void destroy(); public final void suspend(); public final void resume(); are all deprecated, as as they are inherently deadlock-prone.
3) interrupt When we need to interrupt a target thread? a. the target thread is waiting in an invocation of method which can response the interruption by throwing an InterruptedException; these methods include wait(), notify(), notifyAll(), Thread.sleep() b. you don&amp;rsquo;t wish the target thread to execute continually (may be a infinite loop or need spending too much time)
When control thread invokes a interrupt in the target thread instance, the target thread has two ways to response, if possible for interruption: a. catch the InterruptedException b. check the interrupted status by interrupted() method (once invoked, the interrupted status is cleared)
The following scenarios can produce the InterruptedException: a. sleep(long) b. wait(), wait(long), wait(long, int) c. join(), join(long), join(long, wait) d. interruption channel and selector &amp;gt; NOTICE: current thread cannot interrupt itself.
Thread thread = new Thread(new Runnable() { @Override public void run() { while(true) { System.out.println(&amp;amp;quot;I&amp;#39;m running&amp;amp;quot;); int a = 1; try { Thread.sleep(10); } catch (InterruptedException e) { System.out.println(&amp;amp;quot;Interruption received, now I exit&amp;amp;quot;); break; } a = a &#43; 2; } } }); thread.start(); doHardWork(); thread.interrupt(); If we don&amp;rsquo;t interrupt it, the thread will be running forever.
Thread thread = new Thread(new Runnable() { @Override public void run() { while(true) { if(Thread.interrupted()) { System.out.println(&amp;#34;Interruption received, now I exit&amp;#34;); break; } System.out.println(&amp;#34;I&amp;#39;m running&amp;#34;); double d = 0.0; for (int i = 0; i &amp;lt; 900000; i&#43;&#43;) { d = d &#43; (Math.PI &#43; Math.E) / d; } } } }); thread.start(); doHardWork(); System.out.println(&amp;#34;prepare to interrupt&amp;#34;); thread.interrupt(); By using interrupted(), we don&amp;rsquo;t depend on InterruptedException to notify interruption, we check it by my own proactively.
4) join Sometimes, the control thread does something strictly after the target thread died. If the target thread has not terminated, the control thread must be blocked. &amp;gt; NOTICE: current thread can join itself, but it makes no sense because it will wait forever.
Thread thread = new Thread(new Runnable() { @Override public void run() { for(int i=0; i &amp;lt; 10; &#43;&#43;i) { System.out.println(&amp;#34;I&amp;#39;m running&amp;#34;); double d = 0.0; for (int j = 0; j &amp;lt; 900000; j&#43;&#43;) { d = d &#43; (Math.PI &#43; Math.E) / d; } } } }); thread.start(); doHardWork(); System.out.println(&amp;#34;do my work&amp;#34;); System.in.read(); //just make the main thread not exit In this example, the &amp;ldquo;do my work&amp;rdquo; happens in uninsured point, like this in one run: I&amp;rsquo;m running I&amp;rsquo;m running I&amp;rsquo;m running I&amp;rsquo;m running I&amp;rsquo;m running I&amp;rsquo;m running I&amp;rsquo;m running I&amp;rsquo;m running do my work I&amp;rsquo;m running I&amp;rsquo;m running
Now, we use join() and see the result:
Thread thread = new Thread(new Runnable() { @Override public void run() { for(int i=0; i &amp;lt; 10; &#43;&#43;i) { System.out.println(&amp;#34;I&amp;#39;m running&amp;#34;); double d = 0.0; for (int j = 0; j &amp;lt; 900000; j&#43;&#43;) { d = d &#43; (Math.PI &#43; Math.E) / d; } } } }); thread.start(); doHardWork(); thread.join(); System.out.println(&amp;#34;do my work&amp;#34;); System.in.read(); //just make the main thread not exit Now, the output is definitely:
I&amp;rsquo;m running I&amp;rsquo;m running I&amp;rsquo;m running I&amp;rsquo;m running I&amp;rsquo;m running I&amp;rsquo;m running I&amp;rsquo;m running I&amp;rsquo;m running I&amp;rsquo;m running I&amp;rsquo;m running do my work
It can ensure that the code behind the join() must be executed after the target thread died. &amp;gt; WARNING: All the above examples, don&amp;rsquo;t use JUnit for testing, becaust JUnit terminate the program once the main thread terminate, regardless of the running/waiting spawn threads.
5) Operations on current thread When code is executed in a thread context, it always knows the current thread object which represents the current execution thread context.
Thread.currentThread(); Thread.sleep(long); Thread.sleep(long, int); Thread.yield(); Thread.interrupted(); // Please differentiate Thread.interrupted() and thread.isInterrupted() Thread.holdsLock() Some convenient methods from ThreadGroup:
Thread.activeCount() Thread.enumurate()</content>
    </entry>
    
     <entry>
        <title>Java Exceptions</title>
        <url>http://yangchao.me/post/topic-serial-exceptions/</url>
        <categories>
          <category>Coding &amp;amp; Debuging</category><category>Exception</category><category>Exception Handling</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html">  An exception is said to be thrown from the point where it occurred and is said to be caught at the point to which control is transferred.
exception family tree 
All exceptions are inherited from Throwable.
All run-time exception classes and error classes are unchecked exception classes, and the rest are checked exception classes.
That is, the checked exception classes are all subclasses of Throwable other than RuntimeException and its subclasses and Error and its subclasses.
play with finally block If you put a finally block after a try and its associated catch blocks, then once execution enters the try block, the code in that finally block will definitely be executed except in the following circumstances:
 An exception arising in the finally block itself. The death of the thread. The use of System.exit() Turning off the power to the CPU. finally block is always executed before the try-catch blocks exit, including:  1) return
void foo() { try { return; } finally { System.out.println(&amp;#34;finally executed&amp;#34;); // execute before return  } } 2) no exception, execute sequentially
void foo() { try { // some code  } finally { System.out.println(&amp;#34;finally executed&amp;#34;); // execute before try block ends  } } 3) has exception, but no catch
void foo() { try { throw new Exception(&amp;#34;11&amp;#34;); // some code  } finally { System.out.println(&amp;#34;finally executed&amp;#34;); // execute before throwing the exception  } } 4) has exception, but caught successfully
void foo() { try { throw new Exception(&amp;#34;11&amp;#34;); // some code  } catch(Exception e) { // some code  } finally { System.out.println(&amp;#34;finally executed&amp;#34;); // execute before the catch block ends  } } 5) has exception, try to catch but failed
void foo() { try { throw new Exception(&amp;#34;11&amp;#34;); // some code  } catch(RuntimeException e) { // some code  } finally { System.out.println(&amp;#34;finally executed&amp;#34;); // execute before throwing the exception  } } For more details about finally behavior, please refer to finally execution in try-catch-finnally blocks
exception catch order If class BaseException is the super class of class DerivedException, and you write the catch clause of BaseException ahead of DerivedException, then a compilation error will show.
try { int x = 0; int y = 5 / x; } catch (Exception e) { System.out.println(&amp;#34;Exception&amp;#34;); } catch (ArithmeticException ae) // compiler error: Exception &amp;#34;java.lang.ArithmeticException&amp;#34; has already been caught { System.out.println(&amp;#34; Arithmetic Exception&amp;#34;); } System.out.println(&amp;#34;finished&amp;#34;);</content>
    </entry>
    
     <entry>
        <title>Override - some requirements</title>
        <url>http://yangchao.me/post/override/</url>
        <categories>
          <category>OOP</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html">  1. Override methods must have the identical method signature as the methods overridden Return type doesn&amp;rsquo;t belong to the method signature, but Java supports covariant return type for overriding.
Identical signature means: 1) the number of formal arguments must be equal. 2) the type of relevant argument must be the same. The subtype of the methond argument cannot be considered as identical.
2. Override methods can less restricted in access control class AA { protected void foo() {} } class BB extends AA { @Override public void foo() { } } We make the foo() method accessible from weaker privilege &amp;ldquo;protected&amp;rdquo; to less restricted specifier &amp;ldquo;public&amp;rdquo;.
3. Override methods and throw clause More precisely, suppose that B is a class or interface, and A is a superclass or superinterface of B, and a method declaration n in B overrides or hides a method declaration m in A. Then:
If n has a throws clause that mentions any checked exception types, then m must have a throws clause, or a compile-time error occurs.
For every checked exception type listed in the throws clause of n, that same exception class or one of its supertypes must occur in the erasure (§4.6) of the throws clause of m; otherwise, a compile-time error occurs.
class AA { protected void foo() throws IOException {} } class BB extends AA { //This is naturally OK // @Override // public void foo() throws IOException { // }  //This is also OK, since EOFException is a subtype of IOException // @Override // public void foo() throws EOFException { // }  //This is also OK, since we don&amp;#39;t increase new checked Exception // @Override // public void foo() { // }  //This is OK, since RuntimeException is unchecked exception, which is not requested // @Override // public void foo() throws RuntimeException { // }  //This is OK, since IllegalArgumentException is a subtype of RuntimeException // @Override // public void foo() throws IllegalArgumentException { // }  //This is OK, since Error is unchecked exception, which is not requested // @Override // public void foo() throws Error { // }  //This is OK, since AssertionError is a subtype of Error // @Override // public void foo() throws AssertionError { // }  // Compile error: class AA don&amp;#39;t have AccessControlException declaration // public void foo() throws AccessControlException { // }  // Compile error: Throwable is also a checked exception class AA don&amp;#39;t have Throwable declaration // public void foo() throws Throwable { // } }</content>
    </entry>
    
     <entry>
        <title>unreachable statements</title>
        <url>http://yangchao.me/post/unreachable-statements/</url>
        <categories>
          <category>Language, Compiler</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html"> Sometimes, we will meet this compiler error: unreachable statements.
See the following examples:
public void javapapers() { System.out.println(&amp;#34;java&amp;#34;); return; System.out.println(&amp;#34;papers&amp;#34;); // compile error }public void javapapers() { System.out.println(&amp;#34;java&amp;#34;); if(true) { return; } System.out.println(&amp;#34;papers&amp;#34;); } //This code compiled successfullypublic void javapapers() { System.out.println(&amp;#34;java&amp;#34;); while(true) { return; } System.out.println(&amp;#34;papers&amp;#34;); // compile error } Wait, but what is strange here?
From Java Language Specification:   &amp;gt; ## 14.21. Unreachable Statements    &amp;gt; It is a compile-time error if a statement cannot be executed because it is unreachable. &amp;gt; &amp;gt; This section is devoted to a precise explanation of the word &amp;ldquo;reachable.&amp;rdquo; The idea is that there must be some possible execution path from the beginning of the constructor, method, instance initializer, or static initializer that contains the statement to the statement itself. The analysis takes into account the structure of statements. Except for the special treatment of while, do, and for statements whose condition expression has the constant value true, the values of expressions are not taken into account in the flow analysis. &amp;gt; &amp;gt; &amp;gt; &amp;gt; &amp;gt; For example, a Java compiler will accept the code: &amp;gt; &amp;gt; ``` java { &amp;gt; &amp;gt; int n = 5; &amp;gt; &amp;gt; while (n &amp;gt; 7) k = 2; &amp;gt; &amp;gt; } &amp;gt; &amp;gt;
 &amp;gt; &amp;gt; &amp;gt; even though the value of `n` is known at compile time and in principle it can be known at compile time that the assignment to `k` can never be executed. &amp;gt; &amp;gt; &amp;lt;/div&amp;gt; &amp;gt; &amp;gt; &amp;gt; &amp;lt;a name=&amp;quot;jls-14.21-200&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;The rules in this section define two technical terms: &amp;gt; &amp;gt; &amp;lt;div class=&amp;quot;norm&amp;quot;&amp;gt; &amp;gt; &amp;gt; &amp;gt; * &amp;lt;a name=&amp;quot;jls-14.21-200-A&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;whether a statement is &amp;lt;span class=&amp;quot;emphasis&amp;quot;&amp;gt;_reachable_&amp;lt;/span&amp;gt; &amp;gt; &amp;gt; * &amp;lt;a name=&amp;quot;jls-14.21-200-B&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;whether a statement &amp;lt;span class=&amp;quot;emphasis&amp;quot;&amp;gt;_can complete normally_&amp;lt;/span&amp;gt; &amp;gt; &amp;gt; &amp;lt;/div&amp;gt; &amp;gt; &amp;gt; &amp;gt; &amp;lt;a name=&amp;quot;jls-14.21-210&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;The definitions here allow a statement to complete normally only if it is reachable. &amp;gt; &amp;gt; &amp;lt;a name=&amp;quot;jls-14.21-220&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;To shorten the description of the rules, the customary abbreviation &amp;quot;iff&amp;quot; is used to mean &amp;quot;if and only if.&amp;quot; &amp;gt; &amp;gt; &amp;lt;a name=&amp;quot;jls-14.21-230&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;A reachable `break` statement &amp;lt;span class=&amp;quot;emphasis&amp;quot;&amp;gt;_exits a statement_&amp;lt;/span&amp;gt; if, within the break target, either there are no `try` statements whose `try` blocks contain the`break` statement, or there are `try` statements whose `try` blocks contain the `break` statement and all `finally` clauses of those `try`statements can complete normally. &amp;gt; &amp;gt; This definition is based on the logic around &amp;quot;attempts to transfer control&amp;quot; in [§14.15](http://docs.oracle.com/javase/specs/jls/se7/html/jls-14.html#jls-14.15 &amp;quot;14.15. The break Statement&amp;quot;). &amp;gt; &amp;gt; &amp;lt;a name=&amp;quot;jls-14.21-240&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;A `continue` statement &amp;lt;span class=&amp;quot;emphasis&amp;quot;&amp;gt;_continues a `do` statement_&amp;lt;/span&amp;gt; if, within the `do` statement, either there are no `try` statements whose `try` blocks contain the`continue` statement, or there are `try` statements whose `try` blocks contain the `continue` statement and all `finally` clauses of those `try`statements can complete normally. &amp;gt; &amp;gt; &amp;lt;a name=&amp;quot;jls-14.21-300&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;The rules are as follows: &amp;gt; &amp;gt; &amp;lt;div class=&amp;quot;norm&amp;quot;&amp;gt; &amp;gt; &amp;gt; &amp;gt; * &amp;lt;a name=&amp;quot;jls-14.21-300-A&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;The block that is the body of a constructor, method, instance initializer, or static initializer is reachable. &amp;gt; &amp;gt; * &amp;lt;a name=&amp;quot;jls-14.21-300-B&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;An empty block that is not a switch block can complete normally iff it is reachable. &amp;gt; &amp;gt; &amp;lt;a name=&amp;quot;jls-14.21-300-B.1&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;A non-empty block that is not a switch block can complete normally iff the last statement in it can complete normally. &amp;gt; &amp;gt; &amp;lt;a name=&amp;quot;jls-14.21-300-B.2&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;The first statement in a non-empty block that is not a switch block is reachable iff the block is reachable. &amp;gt; &amp;gt; &amp;lt;a name=&amp;quot;jls-14.21-300-B.3&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;Every other statement `S` in a non-empty block that is not a switch block is reachable iff the statement preceding `S` can complete normally. &amp;gt; &amp;gt; * &amp;lt;a name=&amp;quot;jls-14.21-300-C&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;A local class declaration statement can complete normally iff it is reachable. &amp;gt; &amp;gt; * &amp;lt;a name=&amp;quot;jls-14.21-300-D&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;A local variable declaration statement can complete normally iff it is reachable. &amp;gt; &amp;gt; * &amp;lt;a name=&amp;quot;jls-14.21-300-E&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;An empty statement can complete normally iff it is reachable. &amp;gt; &amp;gt; * &amp;lt;a name=&amp;quot;jls-14.21-300-F&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;A labeled statement can complete normally if at least one of the following is true: &amp;gt; &amp;gt; &amp;lt;div class=&amp;quot;norm&amp;quot;&amp;gt; &amp;gt; &amp;gt; &amp;gt; * &amp;lt;a name=&amp;quot;jls-14.21-300-F-1&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;The contained statement can complete normally. &amp;gt; &amp;gt; * &amp;lt;a name=&amp;quot;jls-14.21-300-F-2&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;There is a reachable `break` statement that exits the labeled statement. &amp;gt; &amp;gt; &amp;lt;/div&amp;gt; &amp;gt; &amp;gt; &amp;gt; &amp;lt;a name=&amp;quot;jls-14.21-300-F.1&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;The contained statement is reachable iff the labeled statement is reachable. &amp;gt; &amp;gt; * &amp;lt;a name=&amp;quot;jls-14.21-300-G&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;An expression statement can complete normally iff it is reachable. &amp;gt; &amp;gt; * &amp;lt;a name=&amp;quot;jls-14.21-300-H-1&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;An `if-then` statement can complete normally iff it is reachable. &amp;gt; &amp;gt; &amp;lt;a name=&amp;quot;jls-14.21-300-H-2&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;The `then`-statement is reachable iff the `if-then` statement is reachable. &amp;gt; &amp;gt; &amp;lt;a name=&amp;quot;jls-14.21-300-H-3&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;An `if-then-else` statement can complete normally iff the `then`-statement can complete normally or the `else`-statement can complete normally. &amp;gt; &amp;gt; &amp;lt;a name=&amp;quot;jls-14.21-300-H-4&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;The `then`-statement is reachable iff the `if-then-else` statement is reachable. &amp;gt; &amp;gt; &amp;lt;a name=&amp;quot;jls-14.21-300-H-5&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;The `else`-statement is reachable iff the `if-then-else` statement is reachable. &amp;gt; &amp;gt; This handling of an `if` statement, whether or not it has an `else` part, is rather unusual. The rationale is given at the end of this section. &amp;gt; &amp;gt; * &amp;lt;a name=&amp;quot;jls-14.21-300-I&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;An `assert` statement can complete normally iff it is reachable. &amp;gt; &amp;gt; * &amp;lt;a name=&amp;quot;jls-14.21-300-J&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;A `switch` statement can complete normally iff at least one of the following is true: &amp;gt; &amp;gt; &amp;lt;div class=&amp;quot;norm&amp;quot;&amp;gt; &amp;gt; &amp;gt; &amp;gt; * &amp;lt;a name=&amp;quot;jls-14.21-300-J-1&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;The switch block is empty or contains only switch labels. &amp;gt; &amp;gt; * &amp;lt;a name=&amp;quot;jls-14.21-300-J-2&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;The last statement in the switch block can complete normally. &amp;gt; &amp;gt; * &amp;lt;a name=&amp;quot;jls-14.21-300-J-3&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;There is at least one switch label after the last switch block statement group. &amp;gt; &amp;gt; * &amp;lt;a name=&amp;quot;jls-14.21-300-J-4&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;The switch block does not contain a `default` label. &amp;gt; &amp;gt; * &amp;lt;a name=&amp;quot;jls-14.21-300-J-5&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;There is a reachable `break` statement that exits the `switch` statement. &amp;gt; &amp;gt; &amp;lt;/div&amp;gt; &amp;gt; * &amp;lt;a name=&amp;quot;jls-14.21-300-K&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;A switch block is reachable iff its `switch` statement is reachable. &amp;gt; &amp;gt; * &amp;lt;a name=&amp;quot;jls-14.21-300-L&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;A statement in a switch block is reachable iff its `switch` statement is reachable and at least one of the following is true: &amp;gt; &amp;gt; &amp;lt;div class=&amp;quot;norm&amp;quot;&amp;gt; &amp;gt; &amp;gt; &amp;gt; * &amp;lt;a name=&amp;quot;jls-14.21-300-L-1&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;It bears a `case` or `default` label. &amp;gt; &amp;gt; * &amp;lt;a name=&amp;quot;jls-14.21-300-L-2&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;There is a statement preceding it in the switch block and that preceding statement can complete normally. &amp;gt; &amp;gt; &amp;lt;/div&amp;gt; &amp;gt; * &amp;lt;a name=&amp;quot;jls-14.21-300-M&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;A `while` statement can complete normally iff at least one of the following is true: &amp;gt; &amp;gt; &amp;lt;div class=&amp;quot;norm&amp;quot;&amp;gt; &amp;gt; &amp;gt; &amp;gt; * &amp;lt;a name=&amp;quot;jls-14.21-300-M-1&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;The `while` statement is reachable and the condition expression is not a constant expression ([§15.28](http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.28 &amp;quot;15.28. Constant Expressions&amp;quot;)) with value `true`. &amp;gt; &amp;gt; * &amp;lt;a name=&amp;quot;jls-14.21-300-M-2&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;There is a reachable `break` statement that exits the `while` statement. &amp;gt; &amp;gt; &amp;lt;/div&amp;gt; &amp;gt; &amp;gt; &amp;gt; &amp;lt;a name=&amp;quot;jls-14.21-300-M.1&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;The contained statement is reachable iff the `while` statement is reachable and the condition expression is not a constant expression whose value is `false`. &amp;gt; &amp;gt; * &amp;lt;a name=&amp;quot;jls-14.21-300-N&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;A `do` statement can complete normally iff at least one of the following is true: &amp;gt; &amp;gt; &amp;lt;div class=&amp;quot;norm&amp;quot;&amp;gt; &amp;gt; &amp;gt; &amp;gt; * &amp;lt;a name=&amp;quot;jls-14.21-300-N-1&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;The contained statement can complete normally and the condition expression is not a constant expression ([§15.28](http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.28 &amp;quot;15.28. Constant Expressions&amp;quot;)) with value`true`. &amp;gt; &amp;gt; * &amp;lt;a name=&amp;quot;jls-14.21-300-N-2&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;The `do` statement contains a reachable `continue` statement with no label, and the `do` statement is the innermost `while`, `do`, or `for`statement that contains that `continue` statement, and the `continue` statement continues that `do` statement, and the condition expression is not a constant expression with value `true`. &amp;gt; &amp;gt; * &amp;lt;a name=&amp;quot;jls-14.21-300-N-3&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;The `do` statement contains a reachable `continue` statement with a label `L`, and the `do` statement has label `L`, and the `continue`statement continues that `do` statement, and the condition expression is not a constant expression with value `true`. &amp;gt; &amp;gt; * &amp;lt;a name=&amp;quot;jls-14.21-300-N-4&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;There is a reachable `break` statement that exits the `do` statement. &amp;gt; &amp;gt; &amp;lt;/div&amp;gt; &amp;gt; &amp;gt; &amp;gt; &amp;lt;a name=&amp;quot;jls-14.21-300-N.1&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;The contained statement is reachable iff the `do` statement is reachable. &amp;gt; &amp;gt; * &amp;lt;a name=&amp;quot;jls-14.21-300-O&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;A basic `for` statement can complete normally iff at least one of the following is true: &amp;gt; &amp;gt; &amp;lt;div class=&amp;quot;norm&amp;quot;&amp;gt; &amp;gt; &amp;gt; &amp;gt; * &amp;lt;a name=&amp;quot;jls-14.21-300-O-1&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;The `for` statement is reachable, there is a condition expression, and the condition expression is not a constant expression ([§15.28](http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.28 &amp;quot;15.28. Constant Expressions&amp;quot;)) with value `true`. &amp;gt; &amp;gt; * &amp;lt;a name=&amp;quot;jls-14.21-300-O-2&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;There is a reachable `break` statement that exits the `for` statement. &amp;gt; &amp;gt; &amp;lt;/div&amp;gt; &amp;gt; &amp;gt; &amp;gt; &amp;lt;a name=&amp;quot;jls-14.21-300-O.1&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;The contained statement is reachable iff the `for` statement is reachable and the condition expression is not a constant expression whose value is `false`. &amp;gt; &amp;gt; * &amp;lt;a name=&amp;quot;jls-14.21-300-P&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;An enhanced `for` statement can complete normally iff it is reachable. &amp;gt; &amp;gt; * &amp;lt;a name=&amp;quot;jls-14.21-300-Q&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;A `break`, `continue`, `return`, or `throw` statement cannot complete normally. &amp;gt; &amp;gt; * &amp;lt;a name=&amp;quot;jls-14.21-300-R&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;A `synchronized` statement can complete normally iff the contained statement can complete normally. &amp;gt; &amp;gt; &amp;lt;a name=&amp;quot;jls-14.21-300-R.1&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;The contained statement is reachable iff the `synchronized` statement is reachable. &amp;gt; &amp;gt; * &amp;lt;a name=&amp;quot;jls-14.21-300-S&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;A `try` statement can complete normally iff both of the following are true: &amp;gt; &amp;gt; &amp;lt;div class=&amp;quot;norm&amp;quot;&amp;gt; &amp;gt; &amp;gt; &amp;gt; * &amp;lt;a name=&amp;quot;jls-14.21-300-S-1&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;The `try` block can complete normally or any `catch` block can complete normally. &amp;gt; &amp;gt; * &amp;lt;a name=&amp;quot;jls-14.21-300-S-2&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;If the `try` statement has a `finally` block, then the `finally` block can complete normally. &amp;gt; &amp;gt; &amp;lt;/div&amp;gt; &amp;gt; * &amp;lt;a name=&amp;quot;jls-14.21-300-T&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;The `try` block is reachable iff the `try` statement is reachable. &amp;gt; &amp;gt; * &amp;lt;a name=&amp;quot;jls-14.21-300-U&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;A `catch` block `C` is reachable iff both of the following are true: &amp;gt; &amp;gt; &amp;lt;div class=&amp;quot;norm&amp;quot;&amp;gt; &amp;gt; &amp;gt; &amp;gt; * &amp;lt;a name=&amp;quot;jls-14.21-300-U-1&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;Either the type of `C`&#39;s parameter is an unchecked exception type or `Throwable`; or some expression or `throw` statement in the `try`block is reachable and can throw a checked exception whose type is assignable to the parameter of the `catch` clause `C`. &amp;gt; &amp;gt; &amp;lt;a name=&amp;quot;jls-14.21-300-U-1.1&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;An expression is reachable iff the innermost statement containing it is reachable. &amp;gt; &amp;gt; See [§15.6](http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.6 &amp;quot;15.6. Normal and Abrupt Completion of Evaluation&amp;quot;) for normal and abrupt completion of expressions. &amp;gt; &amp;gt; * &amp;lt;a name=&amp;quot;jls-14.21-300-U-2&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;There is no earlier `catch` block `A` in the `try` statement such that the type of `C`&#39;s parameter is the same as or a subclass of the type of`A`&#39;s parameter. &amp;gt; &amp;gt; &amp;lt;/div&amp;gt; &amp;gt; * &amp;lt;a name=&amp;quot;jls-14.21-300-V&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;The &amp;lt;span class=&amp;quot;emphasis&amp;quot;&amp;gt;_Block_&amp;lt;/span&amp;gt; of a `catch` block is reachable iff the `catch` block is reachable. &amp;gt; &amp;gt; * &amp;lt;a name=&amp;quot;jls-14.21-300-W&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;If a `finally` block is present, it is reachable iff the `try` statement is reachable. &amp;gt; &amp;gt; &amp;lt;/div&amp;gt; &amp;gt; &amp;gt; &amp;gt; One &amp;lt;span class=&amp;quot;emphasis&amp;quot;&amp;gt;_might expect_&amp;lt;/span&amp;gt; the `if` statement to be handled in the following manner: &amp;gt; &amp;gt; &amp;lt;div class=&amp;quot;note&amp;quot;&amp;gt; &amp;gt; &amp;gt; &amp;gt; * An `if-then` statement can complete normally iff at least one of the following is true: &amp;gt; &amp;gt; &amp;lt;div class=&amp;quot;note&amp;quot;&amp;gt; &amp;gt; &amp;gt; &amp;gt; * The `if-then` statement is reachable and the condition expression is not a constant expression whose value is `true`. &amp;gt; &amp;gt; * The `then`-statement can complete normally. &amp;gt; &amp;gt; &amp;lt;/div&amp;gt; &amp;gt; &amp;gt; &amp;gt; The `then`-statement is reachable iff the `if-then` statement is reachable and the condition expression is not a constant expression whose value is `false`. &amp;gt; &amp;gt; * An `if-then-else` statement can complete normally iff the `then`-statement can complete normally or the `else`-statement can complete normally. &amp;gt; &amp;gt; The `then`-statement is reachable iff the `if-then-else` statement is reachable and the condition expression is not a constant expression whose value is`false`. &amp;gt; &amp;gt; The `else`-statement is reachable iff the `if-then-else` statement is reachable and the condition expression is not a constant expression whose value is `true`. &amp;gt; &amp;gt; &amp;lt;/div&amp;gt; &amp;gt; &amp;gt; &amp;gt; This approach would be consistent with the treatment of other control structures. However, in order to allow the if statement to be used conveniently for &amp;quot;conditional compilation&amp;quot; purposes, the actual rules differ. &amp;gt; &amp;gt; As an example, the following statement results in a compile-time error: &amp;gt; &amp;gt; ``` java while (false) { x=3; } &amp;gt; &amp;gt;   because the statement x=3; is not reachable; but the superficially similar case:
if (false) { x=3; } &amp;gt; &amp;gt;  does not result in a compile-time error. An optimizing compiler may realize that the statement x=3; will never be executed and may choose to omit the code for that statement from the generated class file, but the statement x=3; is not regarded as &amp;ldquo;unreachable&amp;rdquo; in the technical sense specified here.
The rationale for this differing treatment is to allow programmers to define &amp;ldquo;flag variables&amp;rdquo; such as:
static final boolean DEBUG = false; &amp;gt; &amp;gt;  and then write code such as:
if (DEBUG) { x=3; } &amp;gt; &amp;gt;  The idea is that it should be possible to change the value of DEBUG from false to true or from true to false and then compile the code correctly with no other changes to the program text.
This ability to &amp;ldquo;conditionally compile&amp;rdquo; has a significant impact on, and relationship to, binary compatibility (§13). If a set of classes that use such a &amp;ldquo;flag&amp;rdquo; variable are compiled and conditional code is omitted, it does not suffice later to distribute just a new version of the class or interface that contains the definition of the flag. A change to the value of a flag is, therefore, not binary compatible with pre-existing binaries (§13.4.9). (There are other reasons for such incompatibility as well, such as the use of constants in case labels in switch statements; see §13.4.9.)
 </content>
    </entry>
    
     <entry>
        <title>Assertion</title>
        <url>http://yangchao.me/post/assertion/</url>
        <categories>
          <category>Basics</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html">  Java have an &amp;ldquo;assert&amp;rdquo; keyword since java 1.4
Usage There are two kinds of syntax:
1) assert expression1
2) assert expression1 : expression2
expression1 must be evaluated as boolean ( true or false) while expression2 can be primitive, object, or array.
expression2 is passed into the constructor of AssertionError as an argument.

So if expression2 is evaluated as void, it&amp;rsquo;s not allowed.
void foo() {} assert true : foo(); // cannot be compiled How to enable or disable assertion Assert statements will be evaluated only if assertion is enabled.
1) through command options (aka. VM options)   Options Example Description   -ea java -ea open assertion in all user classes   -da java -da close assertion in all user classes   -ea:&amp;lt;classname&amp;gt; java -ea:MyClass1 open assertion in class MyClass1   -da:&amp;lt;classname&amp;gt; java -da: MyClass1 close assertion in class MyClass1   -ea:&amp;lt;packagename&amp;gt; java -ea:pkg1 open assertion in package pkg1   -da:&amp;lt;packagename&amp;gt; java -da:pkg1 close assertion in package pkg1   -ea:&amp;hellip; java -ea:&amp;hellip; open assertion in default(no name) package   -da:&amp;hellip; java -da:&amp;hellip; close assertion in default(no name) package   -ea:&amp;lt;packagename&amp;gt;&amp;hellip; java -ea:pkg1&amp;hellip; open assertion in package pkg1 and its subpackage   -da:&amp;lt;packagename&amp;gt;&amp;hellip; java -da:pkg1&amp;hellip; close assertion in package pkg1 and its subpackage   -esa java -esa open assertion in system classes   -dsa java -dsa close assertion in system classes   use class and package together java -da:MyClass1:pkg1 close assertion in class MyClass1 and package pkg1   use -ea and -da together java -da:MyClass1 -ea:MyClass java interprets its options from left to right    2) through ClassLoader at runtime
ClassLoader class has some methods related to assertion setting: 
Some restrictions and pitfalls 1) assertion and inheritance
The following is an example:
class Derived extends Base { public void derivedMethod() { assert false : &amp;#34;Assertion failed:This is derive&amp;#34;;//assertion always fails  System.out.println(&amp;#34;Derived Method&amp;#34;); } public static void main(String[] args) { try { Derived derived = new Derived(); derived.baseMethod(); derived.derivedMethod(); } catch (AssertionError ae) { System.out.println(ae); } } } Now we use all kinds of command options and see the output results:   Command options Description Output   Java Derived close all assertions(default) Base Method Derived Method   Java -ea Derived open all assertions Java.lang.AssertionError:Assertion Failed:This is base   Java -da Derived close all assertions Base Method Derived Method   Java -ea:Base Derived open the assertion in Base class Java.lang.AssertionError:Assertion Failed:This is base   Java -ea:Derived Derived close the assertion in Derived class Base Method Java.lang.AssertionError:Assertion Failed:This is derived    Conclusion: assertion setting cannot be inherited. Just enabling the assertion of derived class will not necessarily take effect for the assertions in the inherited methods and other methods of its base class.
Best/bad usage scenarios 1) it&amp;rsquo;s preferable to assert the arguments of private method.
You should not use assertions to check arguments in public methods because it would otherwise throw runtime exceptions: IllegalArgumentException, NullPointerException, and so forth.
2) it&amp;rsquo;s BAD flavour that assertion has some side effects
private int a = 1; private String foo() { a = 4; return &amp;#34;sss&amp;#34;; } private void assertSomething() { assert false : a&#43;&#43;; // This has a side effect  assert false: foo(); // This also has a side effect } As assertion can be disabled, so there will be something strange to happen if you do something depending on assertion fails.
In the above example, if assertion is disabled, then the variable will be unchanged.
3) in if-then-else and swith-case flow-control statements, you can add &amp;ldquo;assert false;&amp;ldquo; in unexpected branch of control.
switch(x) { case 1: …; case 2: …; case 3: …default: assert false : &amp;#34;x value is invalid: &amp;#34; &#43; x; } if(a==1) { // some codes here } else if { // some codes here } else { assert false : &amp;#34;Normally, it cannot be here&amp;#34;; } This is a defensive technology when you do some test. We can generalize this good style into other similar cases, for example, when you think some place in your code will never be reached. In these cases, the assertion is very useful, because once the assertion fails, there will be something critical logic errors or some programming faults.
4) You should not use assertions to validate your business logic and avoid using assertions to check or validate method arguments.
</content>
    </entry>
    
     <entry>
        <title>Inner Classes</title>
        <url>http://yangchao.me/post/inner-classes/</url>
        <categories>
          <category>Basics</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html">  There are 4 kinds of inner classes:
 Member classes (non-static inner classes) Local classes Anonymous classes Nested top-level classes and interfaces (static inner classes) The former three kinds are called inner classes.  The last kind is called nested class.
&amp;nbsp;
Member interface is implicitly static, so it&amp;rsquo;s never considered as inner class.
Member classes What is a member class?
A member class is a class that is defined inside the definition of another class, _(without the use of the static modifier as is the case with a nested top-level class). _
An object of the member class must be internally linked to an object of the enclosing class, (which is not the case with a nested top-level class).
Thus, a member class is truly an inner class. (An object of the member class cannot exist in the absence of an object of the enclosing class.)
What about a member interface?
Interfaces defined within classes are implicitly static. This means that they are always _top-level._ There is no such thing as a member interface, a local interface, or an anonymous interface.
不存在member interface！！
Why use member classes?
Probably the most important benefit of member classes has to do with accessing the other members of enclosing classes. The methods of a member class have direct access to all the members of the enclosing classes, including private members. Thus the use of member classes can eliminate the requirement to connect objects together via constructor parameters.
This is particularly useful in those cases where there is no reason for an object of a member class to exist in the absence of an object of the enclosing class, and where the methods of the object of the member class need access to members of the object of the enclosing class.
 _
&amp;ldquo;A class defined as a member (non-static) of another. Each instance has an enclosing instance, and can use its members. New syntax for this, new, and super. Cannot have **static **members. Cannot have same name as containing class.&amp;rdquo;_ The main features of member classes are:
  Every instance of a member class is internally associated with an instance of the class that defines or contains the member class. The methods of a member class can implicitly refer to the fields defined within the member class, as well as those defined by any enclosing class, including **private **fields of the enclosing class. 1) Because the object of that inner class has a reference to the object of the enclosing object, so it can access the members of the enclosing object.  public class Sequence { private Object[] items; private int next = 0; public Sequence(int size) { items = new Object[size]; } public void add(Object x) { if(next &amp;lt; items.length) items[next&#43;&#43;] = x; } private class SequenceSelector implements Selector { private int i = 0; public boolean end() { return i == items.length; } public Object current() { return items[i]; } public void next() { if(i &amp;lt; items.length) i&#43;&#43;; } } public Selector selector() { return new SequenceSelector(); } public static void main(String[] args) { Sequence sequence = new Sequence(10); for(int i = 0; i &amp;lt; 10; i&#43;&#43;) sequence.add(Integer.toString(i)); Selector selector = sequence.selector(); while(!selector.end()) { System.out.print(selector.current() &#43; &amp;#34; &amp;#34;); selector.next(); } } } 2) To construct a object of the inner class, you should use the .new syntax
class AAA { class BBB {} } class CCC { public static void main(String[] args) { AAA aaa = new AAA(); AAA.BBB bbb = aaa.new BBB(); } } 3) To get the reference of the out-class object, you should use the .this syntax
public class DotThis { void f() { System.out.println(&amp;#34;DotThis.f()&amp;#34;); } public class Inner { public DotThis outer() { return DotThis.this; // A plain &amp;#34;this&amp;#34; would be Inner’s &amp;#34;this&amp;#34;  } } public Inner inner() { return new Inner(); } public static void main(String[] args) { DotThis dt = new DotThis(); DotThis.Inner dti = dt.inner(); dti.outer().f(); } } 4) Member classes can be private or protected (also public, package), but non-inner (top level) classes can be only public or package. So if you expose some inner class types to client programmer, they may have no access to these type.
class Dog { private class DogTail {} public DogTail showYourTail() { return new DogTail(); } } class ClientProgrammer { public void main(String[] args) { Dog dog = new Dog(); // compiler error: Dog.DogTail has private access in &amp;#34;Dog&amp;#34;  // Dog.DogTail dogTail = dog.showYourTail();  } } Although the definition of Dog class can be compiled normally, the user of this class cannot be compiled when they want to get the return type of showYourTail() method.
In this case, a good fixture is to upcast the inner class to a public base class/interface like the following code:
class Tail {} class Dog { private class DogTail extends Tail {} public Tail showYourTail() { return new DogTail(); } } class ClientProgrammer { public void main(String[] args) { Dog dog = new Dog(); Tail dogTail = dog.showYourTail(); } } 5) Member classes cannot have static members
&amp;lt;pre&amp;gt;class AAAAA { class BBBBB { //static int a =1; // Cannot compile  //static void foo() {} // Cannot compile  } } 5) Member classes cannot have the same name as its enclosing class
class AAAAA { class AAAAA { // Cannot compile: Duplicate class  } } What does compiler do?
Every class definition in a Java program, including nested top-level classes, member classes, local classes, and anonymous classes, produces a class file when the program is compiled. According to Flanagan, &amp;gt; &amp;ldquo;The Java Virtual Machine knows nothing about nested top-level classes and interfaces or the various types of inner classes. Therefore, the Java compiler must convert these new types into standard non-nested class files that the Java interpreter can understand. This is done through source code transformations that insert $ characters into nested class names. These source code transformations may also insert hidden fields, methods, and constructor arguments into the affected classes.&amp;rdquo; A reference to the containing object
For example, the compiler automatically inserts a private instance variable in the member class to hold a reference to the containing object. It also inserts a hidden argument in all constructors for the member class, and passes the containing object&amp;rsquo;s reference to the constructor for the member class. The modified constructor saves that reference in the private instance variable of the object of the member class. Thus each object instantiated from the member class contains a private reference to the containing object.
Accessing private members
In those cases where it is necessary for an object of the member class to access private members of the containing object, the compiler automatically creates and uses accessor methods that make such access possible.
http://www.developer.com/java/other/article.php/3085271/The-Essence-of-OOP-using-Java-Member-Classes.htm#Complete_program_listing
Local classes What is a local class?
A local class is a class that is defined within a block of Java code. While local classes are probably most frequently defined within methods and constructors, they can also be defined inside static initializer blocks and instance initializers.
As is the case for an object of a member class (discussed in the previous lesson), an object of a local class must be internally linked to an object of the enclosing class. I will often refer to that object as the containing object, and make comments about the containment hierarchy.
Thus, a local class is truly an inner class, because an object of the local class cannot exist in the absence of an object of the enclosing class.
What about a local interface?
Interfaces defined within classes are implicitly static. This means that they are always _top-level._ There is no such thing as a member interface, a local interface, or an anonymous interface.
Why use local classes?
Objects instantiated from local classes share many of the characteristics of objects instantiated from member classes. However, in some cases, a local class can be defined closer to its point of use than would be possible with a member class, leading to improved code readability.
Probably the most important benefit of local classes has to do with accessing the members of enclosing classes. Just like with member classes, methods of a local class have direct access to all the members of the enclosing classes, including private members. Thus the use of local classes can sometimes eliminate the requirement to connect objects together via constructor parameters.
Can be particularly useful when &amp;hellip;
A local class can be particularly useful in those cases where
 There is no reason for an object of the local class to exist in the absence of an object of the enclosing class There is no reason for an object of the local class to exist outside a method of the enclosing class Methods of the object of the local class need access to members of the object of the enclosing class Methods of the object of the local class need access to final local variables and method parameters belonging to the method in which the local class is defined Local classes versus member classes  A local class has approximately the same relationship to a member class that a local variable in a method has to an instance variable of the class containing the method.
The scope of a local class
As is the case with local variables, the name of a local class is visible and usable only within the block of code in which it is defined _(and blocks nested within that block)._ Further, the name of the local class is visible and usable only to code following the class definition within that block.
The methods of a local class can use any final local variables or method parameters that are visible from the scope in which the local class is defined.
Similar to member classes
As mentioned earlier, local classes have many characteristics in common with member classes. This includes access to private fields and methods in the containing class. The thing that separates local classes from member classes is the fact that local classes have access to local variables in the scope in which the local class is defined.
A big restriction
There is a big restriction, however, on the ability of methods of the local class to access local variables and method parameters. The methods in a local class can access local variables and method parameters only if they are declared final.
 &amp;rdquo; the methods in a local class don&amp;rsquo;t really have access to local variables and method parameters. Rather, when an object of the local class is instantiated, copies of the final local variables and method parameters referred to by the object&amp;rsquo;s methods are stored as instance variables in the object. The methods in the object of the local class really access those hidden instance variables. &amp;ldquo; Thus, the local variables and method parameters accessed by the methods of the local class must be declared final to prevent their values from changing after the object is instantiated.
 Restrictions on local classes
As with member classes, local classes cannot contain static members.
As with local variables, local classes cannot be declared public,** protected, private, **or static.
A local class cannot have the same name as any of its enclosing classes.
What does compiler do? &amp;gt; &amp;ldquo;The Java Virtual Machine knows nothing about nested top-level classes and interfaces or the various types of inner classes. Therefore, the Java compiler must convert these new types into standard non-nested class files that the Java interpreter can understand. This is done through source code transformations that insert $ characters into nested class names. These source code transformations may also insert hidden fields, methods, and constructor arguments into the affected classes.&amp;rdquo; A reference to the containing object
For example, the compiler automatically inserts a private instance variable in the local class to hold a reference to the containing object. It also inserts a hidden argument in all constructors for the local class, and passes the containing object&amp;rsquo;s reference to the constructor for the local class. The modified constructor saves that reference in the private instance variable of the object of the local class. Thus each object instantiated from the local class contains a private reference to the containing object.
Accessing private members
In those cases where it is necessary for an object of the local class to access private members of the containing object, the compiler automatically creates and uses accessor methods that make such access possible.
1) A class defined within a method
class Tail {} class Dog { public Tail showYourTail() { class DogTail extends Tail {} return new DogTail(); } } Because DogTail is defined in method showYourTail(), it cannot be accessed outside of showYourTail(). Any specifier is not allowed, like public/private/protected, static etc.
2) A class defined within a scope inside a method
class Tail {} class Dog { public Tail showYourTail(boolean flag) { Tail tail = null; if(flag) { class DogTail extends Tail {} tail = new DogTail(); } // Can’t use it here! Out of scope:  // DogTail dt = new DogTail();  return tail; } } http://www.developer.com/java/other/article.php/3107181/The-Essence-of-OOP-using-Java-Local-Classes.htm
&amp;nbsp;
Anonymous classes What is an anonymous class?
I&amp;rsquo;m going to begin my discussion with a quotation from one of my favorite authors, David Flanagan, author of Java in a Nutshell. &amp;gt; &amp;ldquo;An anonymous class is essentially a local class without a name.&amp;rdquo; If you have read the previous lesson, you should know quite a lot about local classes at this point in time. Continuing with Flanagan&amp;rsquo;s words, &amp;gt; &amp;ldquo;Instead of defining a local class and then instantiating it, you can often use an anonymous class to combine these two steps&amp;hellip; an anonymous class is defined by a Java expression, not a Java statement. This means that an anonymous class definition can be included within a larger Java expression&amp;hellip;&amp;rdquo; As you will see from the sample program in this lesson, anonymous class definitions are often included as arguments to method calls.
As is the case for an object of a member class or a local class (discussed in previous lessons), an object of an anonymous class must be internally linked to an object of the enclosing class.
Thus, an anonymous class is truly an inner class, because an object of the anonymous class cannot exist in the absence of an object of the enclosing class.
What about an anonymous interface?
Interfaces defined within classes are implicitly static. This means that they are always _top-level._ There is no such thing as a member interface, a local interface, or an anonymous interface.
Why use anonymous classes?
As with local classes, objects instantiated from anonymous classes share many of the characteristics of objects instantiated from member classes. However, in some cases, an anonymous class can be defined closer to its point of use than would be possible with a member class or a local class. Once you become accustomed to the somewhat cryptic syntax used with anonymous classes, this can often lead to improved code readability.
Probably the most important benefit of anonymous classes has to do with accessing the members of enclosing classes. Just like with member classes and local classes, methods of an anonymous class have direct access to all the members of the enclosing classes, including private members. Thus the use of anonymous classes can often eliminate the requirement to connect objects together via constructor parameters.
In addition, although not demonstrated in this lesson, as with local classes, objects of anonymous classes have access to final local variables that are declared within the scope of the anonymous class.
Can be particularly useful when &amp;hellip;
An anonymous class can be particularly useful in those cases where
 There is no reason for an object of the anonymous class to exist in the absence of an object of the enclosing class. There is no reason for an object of the anonymous class to exist outside a method of the enclosing class. Methods of the object of the anonymous class need access to members of the object of the enclosing class. Methods of the object of the anonymous class need access to **final **local variables and method parameters belonging to the method in which the anonymous class is defined. Only one instance of the anonymous class is needed. There is no need for the class to have a name that is accessible elsewhere in the program. Anonymous classes versus local classes &amp;gt; &amp;rdquo;&amp;hellip;an anonymous class behaves just like a local class, and is distinguished from a local class merely in the syntax used to define and instantiate it.&amp;rdquo; Unlike a local class, however, an anonymous class cannot define a constructor. An anonymous class can define an instance initializer, which can provide some of the benefits of a constructor.  Restrictions on the use of anonymous classes
Because an anonymous class has no name, and the definition and instantiation of the class appear in a single expression, only one instance of each anonymous class can be created. If you need more than one instance of the class, you should probably use a local class, a member class, or a top-level class instead.
As mentioned above, it is not possible to define constructors for anonymous classes. If you need to use a constructor when you instantiate the class, you should probably use a local class, a member class, or a top-level class instead.
As with member classes and local classes, anonymous classes cannot contain static members.
As with local variables and local classes, anonymous classes cannot be declared public,** protected,private, **or static. In fact, no modifiers can be specified in the definition of an anonymous class.
What does compiler do?
The methods in an anonymous class don&amp;rsquo;t really have access to local variables and method parameters. Rather, when an object of the anonymous class is instantiated, copies of the final local variables and method parameters referred to by the object&amp;rsquo;s methods are stored as instance variables in the object. The methods in the object of the anonymous class really access those hidden instance variables.
Thus, the local variables and method parameters accessed by the methods of the local class must be declared final to prevent their values from changing after the object is instantiated.
Generally speaking, this involves the automatic generation of code to cause things to behave as they do. The good news is that you don&amp;rsquo;t have to write that extra code, and you don&amp;rsquo;t have to maintain it. The extra code is written for you, and if you modify your class structure, the extra code is automatically modified accordingly.
1) An anonymous class extending a class that has a default constructor
class Tail {} class Dog { public Tail showYourTail() { return new Tail() { // blabla  }; } } 2) An anonymous class extending a class that has a non-default constructor
class Tail { Tail(int x) {} } class Dog { public Tail showYourTail(int x) { return new Tail(x) { // blabla  }; } } 3) An anonymous class that performs field initialization
class Dog { public Tail showYourTail() { final String dest = &amp;#34;1&amp;#34;; return new Tail() { private String label = dest; // blabla  }; } } In this example, the dest must be &amp;ldquo;final&amp;rdquo;, but why?
// TODO
4) An anonymous class that performs construction using instance initialization (anonymous inner classes cannot have constructors)
If simply assigning a field is not enough, how can you perform some constructor activity? You can’t have a named constructor in an anonymous class (since there’s no name!), but with instance initialization, you can, in effect, create a constructor for an anonymous inner class, like this:
class Dog { public Tail showYourTail() { final String dest = &amp;#34;1&amp;#34;; return new Tail() { private String label = dest; private boolean flag; { if(&amp;#34;1&amp;#34;.equals(label)) flag = false; System.out.println(&amp;#34;instance initialisation&amp;#34;); } // blabla  }; } } Nested top-level classes and interfaces (static inner classes) What is a nested top-level class or interface? &amp;gt; &amp;ldquo;A nested top-level class or interface is defined as a static member of an enclosing top-level class or interface. The definition of a nested top-level class uses the static modifier &amp;hellip; Nested interfaces are implicitly static &amp;hellip; and so are always top-level. A nested top-level class or interface behaves just like a &amp;lsquo;normal&amp;rsquo; class or interface &amp;hellip; The difference is that the name of a nested top-level class or interface includes the name of the class in which it is defined.&amp;rdquo; Why use nested top-level classes or interfaces? &amp;gt; &amp;ldquo;Nested top-level classes and interfaces are typically used as a convenient way to group related classes.&amp;rdquo; Can be particularly useful when &amp;hellip;
A particularly useful implementation of top-level classes occurs when the nested classes extend the enclosing class and override methods that are declared or defined in the enclosing class. This makes it very convenient to construct a hierarchical API, which exhibits very useful polymorphic behavior, and which cannot easily be expanded.
What does compiler do?
&amp;ldquo;The Java Virtual Machine knows nothing about nested top-level classes and interfaces or the various types of inner classes. Therefore, the Java compiler must convert these new types into standard non-nested class files that the Java interpreter can understand. This is done through source code transformations that insert $ characters into nested class names. These source code transformations may also insert hidden fields, methods, and constructor arguments into the affected classes.&amp;rdquo;
http://www.developer.com/java/other/article.php/3358491/The-Essence-of-OOP-using-Java-Nested-Top-Level-Classes.htm
&amp;nbsp;
&amp;nbsp;
</content>
    </entry>
    
     <entry>
        <title>interfaces</title>
        <url>http://yangchao.me/post/interfaces/</url>
        <categories>
          <category>OOP</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html"> Before Java 8, interfaces are not allowed to have static method.
interface SS { static void bar(); // Cannot be compiled  static void foo() {} // Cannot be compiled } The compiler complains: Extension methods are not supported at this language level.
But what are Extension methods? That&amp;rsquo;s a term defined in Java 8.
&amp;nbsp;
As for interfaces, all elements in its definition body are public:
1) all fields are public, final and static implicitly.
2) all methods are public and abstract implicitly.
3) all nested classes, interfaces are public and static implicitly, cannot be private!
interface Intfa{ // this is public and static nested class implicitly  class nestedClass {} // this is public and static nested interface implicitly  interface nestedInterface {} } 4) static methods are not allowed. member classes or interfaces are not allowed (and has no way to declare).
An appropriate guideline is to prefer classes to interfaces. Start with classes, and if it becomes clear that interfaces are necessary, then refactor.
</content>
    </entry>
    
     <entry>
        <title>CS interview experience</title>
        <url>http://yangchao.me/post/cs-interview-experience/</url>
        <categories>
          <category>Uncategorized</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html"> 本人CS硕士名校非牛人,一年前去了一家中型软件公司做SD,不喜欢,刚刚跳去一家小HF.面试 的过程好像西游记一样,路途遥遥,艰险不断,怪物层出不穷,自己的本领也日渐增长,2年来承蒙 版上各路豪杰照顾分享,今日也算有个结果;特此拿出小弟所见所闻共勉,纪念找工作的艰辛,愿 大家早日心想试成,取到真经!
/*********************** 小测验 ***********************/
首先来个小测验,看你能看懂多少 1.array,list,BST,Hashtable,queue,stack,suffix tree,collection&amp;hellip; 2.BFS,DFS,DP,D&amp;amp;C,Greedy,Dijkstra,tree traversal,recursion,quick sort&amp;hellip; 3.A,F,G,L,M,O,T,Y&amp;hellip; 4.OOP,GC,Polymorphism,interface,abstract class,singleton&amp;hellip; 5.bar raiser,white board programming,lunch interview&amp;hellip;
如果以上任何概念不能熟练给出详细解答,请在往下面看之后抓紧复习1.数据结构(这个如果一 个没看懂可以按后退关窗口了)2.算法3.公司背景4.面向对象编程5.onsite流程.全看懂了也别 骄傲,这其实只是很简单的小测验,拿笔每行接着写10项.
/*********************** 公司面试心得 ***********************/
下面按照公司我大概讲讲面试题的注意事项,由于有不少是1年前的题目,记得不太清楚,我以框 架为主,后面主要讨论复习要点和经验教训:
A:phone interview会问到关于OOD的概念和设计,onsite有问过题:数组找定和,Hash table溢出, isBST,Rome letter,GC设计,byte[] getIP(int),deadlock,优化搜索速 度.数组求定和是最最常见的问题,基本每两个interview就有一个问这个,后面还会说到,一定不 要陷入固定思维,自己多想想不同的condition下的解答.听说最近在狂面人,可以在linkedin上 面直接找到HR要面试.
F:现在已经很难进了,主页能找到一些puzzle,很多很tricky,不过也还算不难,觉得普通面 试题缺乏挑战的童鞋可以拿做当onsite前热手,phone里面主要是基础题目,只记得链表反转,以 OOP为主,没有onsite过. http://www.facebook.com/careers/puzzles.php
G:被问到都是非主流问题和设计,什么&amp;rdquo;估算躺在地上硬币总价值&amp;rdquo;,无语.设计也都是开放性 的,没啥参考价值,可能天生相克吧.
L:很注重java的概念,例如hash原理,多态,继承,gc等的深层概念和implementation,对于 概念有点要求的过严了,但是还算是让人向往的公司吧
M:注重flawless的编程,pointer的操作(能用array/bitwise不要用hashtable),DP, dictionary/index,recursion.最近狠狠的涨了一下工资,让人很眼红的说
O:基本只看GPA3.8以上或者内荐,面试主要是algorithm,SQL
其实我大公司的面试经历不算多,也只能这样点到为止,但是还有一些公司,招人规模不及以上, 但是我也稍微点评一下.
Bloomberg:变态的测试,据说除了c的测试外其他没有过的记录.面试也是集中与算法和数据 结构,以c/c&#43;&#43;为主要背景,压力大工作辛苦薪水高,一但进黑名单貌似是永远不会考虑了
ebay:招人不是很给力,最好内荐,OOP为主,一流的流量一流的薪水二流的软件,我的意思不是 说ebay不好,而是说其实他家软件,尤其比起A来,还有很大上升空间,其实趁着软件还不够好参 与开发是种机会,你懂的
rapleaf:漫天广告,实际上没啥诚意,现在市场转好,建议不要考虑
D.E.shawn/two sigma/citadel:面试门槛很高,但是效率也很高,舍得花钱,就是录取 率不高,建议阅读相应金融知识,并且有相关实习经验或者大公司背景,new grad很有难度
laserfiche:坑爹专业户,如果你从没onsite经历可以去一下,否则就是浪费时间,薪水超 低(尤其以LA为背景)
ning:新兴social network,100人不大但也还算不错的startup,不过他们manager很对 不起我,估计我这辈子是不考虑了,推荐想做social network但是去不了F,L,T的
quantcast:强烈推荐,感觉非常棒,但是codetest也很难,时间很紧张,2个小时测试,到点 的时候只写出2/7个答案,4小时写出完美程序,大概200行的样子,加上10个testcase,然后 就悲剧了,估计就是嫌我慢
addepar:很个性的公司,先一轮phone,然后做蚂蚁大战,时间不限, http://addepar.com/challenge.php,要是我在学校可能还有心情测一测 根本不太可能静心给他做这个,若是能达到400-600turn过关,那么可以拿到下轮面试,你要 是觉得自己很牛没有题做,试试这个
epic:狂招人,面试比较简单,需要准备presentation,有性格测试
cisco/emc/ibm/adobe:感觉对local看的很重,不太招外州的人
yahoo/SAP:没落中,需求量越来越小
apple:对SDE需求不大,有些ee的职位,手机卖这么好,没听有招人(店面不算)
GS/UBS/Citi/boa:看重GPA,如果你喜欢做纯技术,去了会后悔的;如果想做金融软件,但是 达不到bloomberg和hf标准,是个不错的跳板
fiverings:很小的HF,10几个人吧,问一下brain teaser和古怪的程序,有兴趣可以试一下, 老板是从jane street出来自己做的
其实还有数不完的公司,不过本人主要经历也就这些.
/*********************** 复习清单 ***********************/
我只列出关键字和一些特别注意的要点,其实一个词可能包含无数知识点: Array(pointer) list(reverse,loop,ring) tree(traversal,search) sort queue/stack(BFS,DFS) hash table string(suffix tree) recursion graph/greedy divide and conquer dynamic programming bitwise OOD(GC,serialization,exception,UML,singleton) regular expression deadlock/multi-thread I/O,memory,buffer testing(unit test,white box,black box,development cycle) Network(TCP/IP,socket) SQL(index,bcnf,3nf,optimization) Scale(distributed system) Security(buffer overflow,protocol) Machine learning/AI probability(bayes) Web programming 最后是behavior(strength,weakness,goals)
参考书和网站: crack the technical interview(强烈推荐) programming interviews exposed(强烈推荐) 编程之美 data structures with java algorithm design database management system computer networking thinking in java thinking in c&#43;&#43; software testing java how to program http://www.mitbbs.com/bbsdoc/JobHunting.html (还用多说么) http://www.careercup.com (会上面的题不代表就能过面试!) http://www.glassdoor.com http://www.dice.com http://www.javacertificate.net/core_java_iqns.htm http://www.techinterviews.com/core-java-interview-questions http://javaquestion.tripod.com/InterviewWithAnswer.html http://www.freejavaguide.com/java-interview-questions.html http://www.roseindia.net/interviewquestions/ http://www.geekinterview.com/Interview-Questions/J2EE/Core-Java http://javaquestion.tripod.com/InterviewWithAnswer.html http://www.indiabix.com/technical/core-java/
这里小小感慨一下阿三的团结,咱们怎么没有更多像印度玫瑰这样的网站呢&amp;hellip;
/*********************** 经验教训 ***********************/
最后一部分,琐碎的经验教训
1.对方电话里问你下周能不能来,一定要问清楚他们急不急用人,急得话要当机立断,我因此疏 忽本想拖延一下面试避免时间紧张,结果一周后被告知不用去了,四大皆空,干脆悲剧
2.地区是一个很重要的因素,如果你还没开始h1b或者绿卡,在找工作受阻的情况下可以考虑申 请opt然后搬去加州或者纽约,在local找,很多公司为了省phone的多回合和onsite的开销, 只找local或者优先在local找.至于有些在职的人想辞职裸奔挂语言学校,也是个办法.
3.不要背题.迄今为止我还没见到过一模一样的面试题,优秀的面试官一定不会只准备所谓经典 的面试题,一定有改动和引伸.举个例子,数组找定和很简单吧,怎么不用hash table照样 O(n),找3数定和?4数(有O(n^2)解)?负数?已排序数列?写白板!再举个例子hash table大 家都知道,让你用数组实现?hash function?碰撞处理?碰撞处理方法的利弊比较?equal和 hashcode的关系?写白板!希望大家准备的时候能够多问自己问题,写程序也不要只完成题目,多 想想如果哪个要求换了应该怎么改.
4.练习口语.比起阿三,老美不见得喜欢中国的口音,很多人的发音和语法不正确,自己从来没用 心改正过.这里推荐一款iphone的免费app-dragon, http://itunes.apple.com/us/app/dragon-dictation/id341446764?mt= 是一语音识别软件,你找一篇新闻,认真读看看老美的软件能听懂你多少,反复训练,更上一层楼. 说话的时候尽量嘴巴变化明显一点,试着拉长放慢大声和夸张的读每个单词,尤其是字母lnr的 卷舌鼻音
5.实习经历还是很重要的,重要程度多过绝大部分in class project,争取毕业前能在美国 公司里面有过实习经历.
6.linkedin其实是一个很好的平台,很多recruiter在上面搜罗人才,你要表现的活跃一些, 完善自己的资料.另外如果通过朋友等渠道,你可以找到recruiter的邮箱,一定要主动自报家 门,我干过无数回了,直接email给recruiter,附上简历,说明背景,百试不爽,基本每次都有 面试
7.搞好和同学前辈的关系,最大化争取referral(朋友的朋友也行),有面试什么都能靠你自 己,没面试你自己再牛也不行
8.白板练习很必要.为了面试我用eclipse至少写了60个函数的题目,但是换成白板/白纸,还 是无法每次写出flawless的程序,这个必须多加练习,而且尽量找一些自己没听过的题目或者 变形的题目
9.准备好所有工作经历包括实习的描述,控制好时间,另外着重准备1-2个对你来说重要的 project/design,一定要做到拿起来就能说,而且说的简洁明了重点突出,让不很懂的人也能 听明白
10.behavior question要花时间准备,准备过的话一问就能问出来,说话要简洁,用多个简 短的句子回答,不要用冗长的从句.给面试官一个好的印象.
11.屡试不行的童鞋请考虑 i.改简历 ii.monk interview iii不同type的职位.原则上 找能给你反馈的人的意见,反馈可以说是非常难得到的,是指引你进步的关键.monk interview要涉及技术和behavior,而且面试人要认真准备,问题要有深度,当场要卡时间写 白板,不要觉得认识面试人就跳过诸如自我介绍,project描述等环节.
12.木桶原理,找到自己的不足,尽量提高综合能力,不要让任何不足拖你后腿.举个不一定合适 的例子,如果你是路痴,面试前多查查map要不就打出来,留一个紧急求助电话像是tax或者HR 的电话,一定要保证按时到达.路痴不能怪你,不守时那就是你的责任.现在公司招人,基本上都 是找综合能力强并且有亮点的人,弥补你的短板往往能更加有效的留下好印象.
13.列个表或者找个日历,合理安排面试顺序和集中程度,确保面试前对公司有所了解,尤其是要 看至少一遍job description,知道他们的需求是什么.这里废话一句,对于dream company,最好不要放在面试经历少或者时间仓促的时候,如果你从来没去过onsite或者很久 没去过onsite,用其他公司热身是有必要的.一般一年左右的黑名单还是很难熬的,况且有些像 F这样的公司,2年前和现在的口气明显就不一样,现在连要个面试都很难.
14.学会换位思考,从面试官公司角度考虑他究竟在考察你什么.如果可以,你甚至也可以给别 人做interview,你会体会良多.crack technical interview里面说的比较夸张,面试官其 实在找&amp;rdquo;Would I have a beer with this guy?&amp;ldquo;的答案,但是你不可否认的是,他们如果觉 得和你在一起不舒服,随便找个借口就可以把你打发了.
15.面试过程中很多东西是无形的,面试前题目,公司招人的主要原因,老板性格态度,职位竞争 的激烈程度,面试评价标准等等,所以要尽可能的把握自己看的见的,技术要点,措辞态度,白板 编程等等.未知因素不由得你,不要老想着哪里有窍门哪里有小道消息来投机取巧;超越自己,把 握自己才是真正的提高.
16.这里再废话一段,面过这么多公司,感觉中国人还是比较受压迫,比起阿三,中国人在软件 公司中层的人数明显少,很少人接触到核心技术和做决策.准备面试的时候,要多与朋友交流 互相帮助,阿三老美的优点要尽量学来,以后职场做的久了,也要多帮助后生.我们的爷爷辈受 尽别人压迫欺负,父辈受自己人欺负,能提供机会我们出来,很不容易.我们这一代其实是肩负 着历史使命的,而在美国的各路精英应该是民族复兴的领军人,希望有朝一日中国能有更多的 AFGM为世界贡献优秀的软件.
话说到这里也差不多了,以上的话也都是小弟自己的体会,有不到位的地方也希望和大家讨论 切磋.关于详细的每家的面试题,还有比本版(尤其是精华贴)更好的地方么.最后用一句话与 大家共勉,机会青睐有准备的头脑,还等什么,继续打怪升级吧!
</content>
    </entry>
    
     <entry>
        <title>static method and hiding</title>
        <url>http://yangchao.me/post/static-final-method/</url>
        <categories>
          <category>OOP</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html"> Class method can be invoked by Class or by instance.
When it is invoked by instance, it uses the type of the instance, to figure out, at compile time, which class method to invoke. So the polymorphism would not happen as you think. For static methods, when the static method of the subclasses has the same signature as their superclass, we call it Hiding.
In Java, private / final / static methods can do hiding by static binding.
Other methods are virtual, and can do overriding by dynamic binding.
1. hiding by class methods
class Super { static String greeting() { return &amp;#34;Goodnight&amp;#34;; } String name() { return &amp;#34;Richard&amp;#34;; } } class Sub extends Super { static String greeting() { return &amp;#34;Hello&amp;#34;; } String name() { return &amp;#34;Dick&amp;#34;; } } class Test { public static void main(String[] args) { Super s = new Sub(); System.out.println(s.greeting() &#43; &amp;#34;, &amp;#34; &#43; s.name()); } } // Output: Goodnight Dick
2. static final method
class A { static final void m1(){} } class B extends A { static void m1(){} } A method can be declared final to prevent subclasses from overriding or hiding it.
</content>
    </entry>
    
     <entry>
        <title>NZ company collection</title>
        <url>http://yangchao.me/post/nz-company-collection/</url>
        <categories>
          <category>Job Seeking</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html">   New Zealand Post http://jobs.nzpost.co.nz/   Sovereign https://careers.asbgroup.co.nz/sovereign/home   Child, Youth &amp;amp; Family https://msdcareers.msd.govt.nz/home   AA http://www.aa.co.nz/about/work-or-partner-with-us/careers/   Kiwibank https://workforus.kiwibank.co.nz/search   Telnet http://callcentrepeople.co.nz/jobs/candidate-resources/   iiNet http://careers.iinet.net.au/caw/en/listing/   Great Outcomes    Tower Insurance https://careers.tower.co.nz/home   Dunedin City Council http://www.dcc.jobs/   Coca Cola    Ezibuy https://ezibuy.careercentre.net.nz/   Datacraft (Dimension Data) http://www.dimensiondata.com/en-nz/aboutus/careerportal   BNZ http://www.bnzcareers.co.nz/   ANZ (include National Bank) https://www.anz.com/about-us/careers/   ASB https://careers.asbgroup.co.nz/   Contact Energy http://www.contactenergy.co.nz/aboutus/workwithus/careers/homepage   Ministry of Health https://jobs.health.govt.nz/   Massey University http://www.massey.ac.nz/massey/about-massey/careers.cfm   LIC http://careers.lic.co.nz/home   Amway http://www.amway.co.nz/Content/Article?PageCode=careersWorkingAtAmway&amp;amp;c=EN-NZ   Fonterra Brands https://www.fonterra.com/nz/en/Hub&#43;Sites/Careers   ADT http://www.tyco.com/careers   Cerebos Gregg’s http://jobs.seek.co.nz/users/jobsearch.asp?jobsearch=true&amp;amp;AdList=true&amp;amp;AdvertiserID=19607904   Chrisco    Electoral Enrolment Centre    North Shore City Council https://careers.aucklandcouncil.govt.nz/home   Manpower http://www.manpower.com/   Warehouse Stationery https://www.warehousestationerycareers.co.nz/home   Mitsubishi Customer Care Centre    Quitline http://www.quit.org.nz/54/about-us/job-vacancies   Air NZ Holidays    Wellington City Council https://careers.wellington.govt.nz/home   AUT http://careers.aut.ac.nz/   Air NZ Global    RESTAURANT BRANDS https://www.servingupthefuture.co.nz/home   Auckland Regional Council    TrustPower https://trustpowercareers.silkroad.com/   Work &amp;amp; Income http://www.workandincome.govt.nz/individuals/looking-for-work/index.html   South Taranaki District Council http://southtaranaki.recruitmenthub.co.nz/Vacancies/   Sitel New Zealand    Genesis Energy https://www.genesisenergy.co.nz/careers   ACC https://careers.acc.co.nz/home   American Express https://careers.americanexpress.com/?inav=nz_sitefooter_careers   Christchurch Polytechnic http://www.cpit.ac.nz/about-us/work-at-cpit/current-vacancies   Department of Labour http://www.dol.govt.nz/about/careers/index.asp   Dick Smith http://dicksmithholdings.com.au/work-with-us/       ECL (CourierPost / Pace) http://www.expresscouriers.co.nz/careers/   Environment Waikato (Waikato Regional Council)    Farmers  http://farmerscareers.co.nz/   Goodman Fielder https://careers.goodmanfielder.com.au/jobtools/JnCustomLogin.Login?in_organid=17226   Greater Wellington Regional Council https://careers.gw.govt.nz   Griffins    Guthrie Bowron    Heinz Watties    Johnson&amp;amp;Johnson    Kaikoura District Council    Kellogg&amp;rsquo;s Ltd    Kraft    Land Transport NZ    Lion Nathan    Meridian Energy    Ministry for the Environment    Ministry of Agriculture and Forestry    Lion Nathan    Meridian Energy    Ministry for the Environment    Ministry of Agriculture and Forestry    Ministry of Economic Development    Ministry of Education    Ministry of Social Development    Ministry of Tourism    NewZealand Trade And Enterprise (NZTE)    MITO Motor Industry Training Organisation    Nestle    New Zealand Police    New Zealand Post    NZ Army    PGG Wrightson    Procter &amp;amp; Gamble    PSIS    Quit    Resturant Brandsn (Pizza Hut)    Retirement Commission    Fly Buys    Rotorua District Council    SC Johnson    Scenic Circle Hotels        Shell    Ravensdown    Sky TV        Smiths City    Southern Cross Healthcare    The Families Commission    The Warehouse    Tip Top    Tourism Holdings    Transpower    Turner Auctions    Unilever    Unison Networks Limited    Unitec NZ    University of Waikato    Upper Hutt City Council    Wellington City Council    Winstone Wallboards Ltd    Zespri    Waiariki Institute of Technology    Avis    Hertz    Budget rent a car    Torpedo 7    Intercity Group    Interislander    Southern Cross Health Insurance    Air New Zealand    AMI Insurance    Postie Plus    House of Travel    WorldVision         Goverment jobs: http://jobs.govt.nz
Telecommunication: Vodafone, Telecom, Gen-i
These are New Zealand&amp;rsquo;s top 100 companies/orgnizations ranked by number of employees.
1 Fonterra Co-Operative Group Ltd 2 Progressive Enterprises Ltd 3 Fletcher Building Limited 4 Spotless Services (NZ) Limited 5 New Zealand Defence Force 6 New Zealand Police 7 Carter Holt Harvey Limited 8 Air New Zealand Limited 9 ANZ National Bank Limited 10 Auckland District Health Board 11 New Zealand Post Limited 12 Canterbury District Health Board 13 Restaurant Brands New Zealand Limited 14 Telecom Corporation of New Zealand Ltd 15 Ministry of Social Development: 16 McDonald&amp;rsquo;s Restaurants (New Zealand) Ltd 17 Department of Corrections 18 Bank of New Zealand Limited 19 The Warehouse Group Limited 20 Silver Fern Farms Ltd 21 Westpac New Zealand Ltd 22 Inland Revenue Department 23 Alliance Group Limited 24 Downer EDI Ltd 25 Healthcare of New Zealand Ltd 26 ISS Facility Services Ltd 27 Waikato District Health Board 28 Waitemata District Health Board 29 Capital &amp;amp; Coast District Health Board 30 The University of Auckland 31 Counties Manukau District Health Board 32 Tyco Fire &amp;amp; Security - New Zealand 33 SKYCITY Entertainment Group Limited 34 Bupa Care Services 35 University of Otago 36 ASB Bank Limited 37 Massey University 38 Farmers 39 APN New Zealand Ltd 40 Datacom Group Ltd 41 Goodman Fielder New Zealand Ltd 42 KiwiRail Holdings Limited 43 Northland District Health Board 44 OCS New Zealand 45 Radius Health Group Ltd 46 Victoria University of Wellington 47 Ministry of Justice 48 Royal New Zealand Navy 49 Fulton Hogan Ltd 50 Fairfax New Zealand Ltd 51 PGG Wrightson Limited 52 Ministry of Education 53 Gen-i Limited 54 Anzco Foods Limited 55 Bayleys Realty Group Limited 56 Repco Ltd 57 The Salvation Army 58 Toll Tranz Link 59 Transfield Services (New Zealand) Ltd 60 Beca Group Ltd 61 Bunnings Ltd 62 Otago District Health Board 63 Accident Compensation Corporation 64 Christchurch City Council 65 Department of Child, Youth and Family 66 Oceania Group NZ Ltd 67 MidCentral District Health Board 68 New Zealand Fire Service 69 Auckland City Council 70 IAG New Zealand Ltd 71 Antares Restaurant Group Ltd 72 Compass Group Ltd 73 Fletcher Construction Company Limited 74 Hutt Valley District Health Board 75 Millennium &amp;amp; Copthorne Hotels New Zealand Ltd 76 New Zealand Steel Ltd 77 Nurse Maude Association 78 NZ BuS 79 Placemakers 80 Sanford Ltd 81 Department of Labour 82 Harcourts Group Ltd 83 University of Canterbury 84 Bay of Plenty District Health Board 85 Fisher &amp;amp; Paykel Healthcare Corporation Ltd 86 Hawkes Bay District Health Board 87 Opus International Consultants Ltd 88 AUT University 89 AsureQuality Limited 90 BP Oil New Zealand Ltd 91 University of Waikato 92 Nelson Marlborough District Health Board 93 Briscoe Group Ltd 94 Fisher &amp;amp; Paykel Appliances Holdings Limited 95 Department of Conservation 96 Ministry of Agriculture and Forestry 97 Barfoot &amp;amp; Thompson Ltd 98 Heinz Wattie&amp;rsquo;s Ltd 99 Presbyterian Support Central 100 Royal New Zealand Air Force (RNZAF)
&amp;nbsp;
</content>
    </entry>
    
     <entry>
        <title>override:  covariant return types</title>
        <url>http://yangchao.me/post/override-covariant-return-types/</url>
        <categories>
          <category>OOP</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html"> class AA { void foo(CharSequence a) {} CharSequence bar() { return &amp;#34;1&amp;#34;; } } class BB extends AA { void foo(String a) {} @Override String bar() { return &amp;#34;2&amp;#34;; } } It&amp;rsquo;s obvious that method &amp;ldquo;bar&amp;rdquo; overrides successfully.
Java多态时，允许协变的返回类型，但是形式参数列表必须一模一样(不支持协变参数类型)！
</content>
    </entry>
    
     <entry>
        <title>Behavior of polymorphic methods inside constructors</title>
        <url>http://yangchao.me/post/behavior-of-polymorphic-methods-inside-constructors/</url>
        <categories>
          <category>OOP</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html"> class Glyph { void draw() { System.out.println(&amp;#34;Glyph.draw()&amp;#34;); } Glyph() { System.out.println(&amp;#34;Glyph() before draw()&amp;#34;); draw(); System.out.println(&amp;#34;Glyph() after draw()&amp;#34;); } } class RoundGlyph extends Glyph { private int radius = 1; RoundGlyph(int r) { radius = r; System.out.println(&amp;#34;RoundGlyph.RoundGlyph(), radius = &amp;#34; &#43; radius); } void draw() { System.out.println(&amp;#34;RoundGlyph.draw(), radius = &amp;#34; &#43; radius); } public static void main(String[] args) { new RoundGlyph(5); } } Output: &amp;gt; Glyph() before draw() &amp;gt; &amp;gt; RoundGlyph.draw(), radius = 0 &amp;gt; &amp;gt; Glyph() after draw() &amp;gt; &amp;gt; RoundGlyph.RoundGlyph(), radius = 5
在构造器中调用多态方法，虽然对象没有完全构造好，但是多态也会发生！!
</content>
    </entry>
    
     <entry>
        <title>JAX-RS as the one Java web framework to rule them all?</title>
        <url>http://yangchao.me/post/jax-rs-as-the-one-java-web-framework-to-rule-them-all/</url>
        <categories>
          <category>JAX-RS</category>
        </categories>
        <tags>
          <tag>JAX-RS</tag><tag>Jersey</tag><tag>Quoted</tag>
        </tags>
        <content type="html"> One of the things about Java that sometimes gets made fun of is the huge number of Java based web frameworks. There certainly are many, of all shapes and sizes! I suppose there are quite a lot of different shapes and sizes of web applications out there but it sometimes seems like there&amp;rsquo;s a 1-1 mapping between applications and frameworks :).
Picking the right web framework is probably a managers nightmare (Which one to pick? Pick the wrong one and we might end up using a duff dead framework that few developers know etc?). But it has lead to a ton of innovation in the web framework space. On balance I think competition and innovation are good things.
I&amp;rsquo;m a big Rails fan, I think its a stunning piece of work and one of the most impressive open source frameworks created in the last 10 years which together with Ruby, Erb and Rake is a good alternative to Servlets &#43; JSP &#43; JSTL &#43; Spring &#43; Hibernate &#43; WebFrameworkOfYourChoice &#43; SiteMesh/Tiles &#43; Ant/Maven &#43; a few other bits all in a surpringly small and easy to grok codebase.
JAX-RS came along initially as a way of writing RESTful services on the Java platform; using annotations and loose coupling to bind resource beans and their public methods to URIs, HTTP methods and MIME content type negotiation. I&amp;rsquo;ve said before I think its awesome, one of the most impressive JSRs we&amp;rsquo;ve had.
From the perspective of the controller layer I actually prefer JAX-RS to Rails routes.rb &amp;amp; controllers as
 the URI bindings are local to the resource beans which can be arbitrarily nested which makes refactoring much easier and avoids the complex routes.rb file with regex switches (I try and avoid regex whenever I can :) the loose coupling between the objects returned by the resource methods and the actual entity providers is clean; helping the application programmer focus on returning DTOs and letting the framework deal with the XML / JSON /Atom / multi-part-form marshalling &amp;amp; data binding stuff really helps. e.g. its easy to drop in support for new representations in a DRY way without changing the code of your resource beans (controllers), you can just modify an annotation static typing can be a handy thing when binding URIs and parameters to your controller. e.g. having String, integer, Date fields and parameters helps you having to explicitly convert things in your controller There&amp;rsquo;s lots of other stuff thats great in Rails though :-) but this post isn&amp;rsquo;t a JAX-RS versus Rails post really - its focussing on the world of Java web frameworks for Java developers and the impact of JAX-RS.  So whats interesting is - if you want to build a web application with RESTful services (e.g. a human facing website with computer facing XML/JSON APIs) why would you use JAX-RS andanother web framework? Why not just use JAX-RS as the web framework? So recently I&amp;rsquo;ve been musing, could JAX-RS be the one Java web framework to rule them all?
JAX-RS works well with dependency injection frameworks such as Spring, Guice,GuiceyFruit or JBossMC - you can basically pick whichever one you prefer. It also does all the heavily lifting of binding URIs and HTTP methods to resource beans and their methods along with supporting content type negotiation, headers and etags elegantly. For implementing great RESTful services in Java I&amp;rsquo;ve never seen anything close to touching it. The main question is what features are missing from JAX-RS being the main web framework?
Incidentally in this post I&amp;rsquo;m ignoring the server-side UI type frameworks like Wicket, Tapestry, JSF et al. I&amp;rsquo;m focussing on web frameworks that spend most of their time rendering HTML / XML / JSON and not building complex server side UI stuff and treating the browser as a kinda dumb terminal with the real UI work being done on the server side. Having had a horrid time using Tapestry and Hibernate together on some projects in the past, I&amp;rsquo;m kinda over the whole concept of server side UI web frameworks personally (I&amp;rsquo;m putting my flame-proof suite on now). I kinda think if you want to do complex rich web UIs, use wizards or complex flows, just use GWT or JavaScript on the client (or Flex/Flash for video or crazy highly graphical widgets) and keep the server side fairly simple and very RESTful. (But lets leave that discussion for another day&amp;hellip; :)
In this post I&amp;rsquo;m only really considering frameworks like Struts, Stripes, SpringMVC etc.Thankfully WebWork and Struts merged together so at least there&amp;rsquo;s been someconsolidation in the space - and certainly Struts and Stripes are now kinda similar (and not too disimilar from SpringMVC). I wonder if JAX-RS will lead to further consolidation with web frameworks adding themselves as JAX-RS extensions?
So whats is missing from JAX-RS to be able to use just it for your entire web app and set of RESTful services and not have to use it with Struts/Stripes/SpringMVC and have to map some URIs into the web framework and some to JAX-RS?
Right now today there are definitely some holes; though currently I don&amp;rsquo;t think there&amp;rsquo;s thatmuch missing. Here&amp;rsquo;s my list of things I think are missing and how we could add them - I&amp;rsquo;m very interested in hearing if there&amp;rsquo;s anything you&amp;rsquo;d particularly miss from Struts/Stripes/SpringMVC/whatever; please blog about it or post a comment and I&amp;rsquo;ll do a follow up post!
Implict &amp;amp; Explicit Views One great feature of Jersey is the support for Implicit and Explicit Views. Update: here&amp;rsquo;s alink describing implict/explicit views. It basically allows the controller to delegate to the view layer (JSP/Velocity/Freemarker/GXP or whatever) using a default naming convention to find the template files in a directory named after the resource bean&amp;rsquo;s class name and if required - the URI being requested. So a given Resource bean could have an index.jsp and edit.jsp templates for example - and referring to ${it.foo} inside the template would extract the foo property of the resource bean (you can override what &amp;lsquo;it&amp;rsquo; is if you like but the resource bean is a very reasonable default).
Maybe the easiest way to understand implicit/explicit views is to look at the bookstoreexample in the Jersey distro; its basically the glue between JAX-RS resources and templates.
However there are some issues (which are being addressed particularly by the helpful folks on the Jersey list, particularly Marc and Paul) which basically revolve around having implicit/explicit views and (say) XML/JSON representations on the same resource bean using the same URIs and getting JAX-RS to pick the right one.
For example the URI &amp;ldquo;/customers&amp;rdquo; might return a HTML page for most web browsers but return XML/JSON if folks want to specify those MIME types in their Accept header. Right now Jersey tends to favour returning XML/JSON (long story but basically more specific URI paths are preferred over implicit views).
I&amp;rsquo;m pretty sure some kind of @ImplicitProduces annotation to allow implicit views to be associated to MIME types along with a higher priority/quality ranking specified in the next feature would solve pretty much all the issues with implicit/explicit views though am sure folks can think of other improvements&amp;hellip;
Better Content Negotiation Support It would be nice to see these issues resolved to be able to use RFC 2296 to be able to raise and lower the priorities (or quality) of the different representations.
e.g. you might want to prefer to return HTML over XML/JSON so unless folks ask specifically just for XML or JSON you return HTML.
Bizarrely Safari uses an Accept header of &amp;gt; text/xml,application/xml,application/xhtml&#43;xml,text/html;q=0.9,text/plain;q=0.8,image/png,/;q=0.5 which kinda means it prefers to render XML over HTML (despite rendering XML as plain text! Truly bizarre - what was Steve smoking that day :). Most web apps I know of would rather return HTML by default :)
So you might want to specify something like this on a resource to declare that you want to return HTML by default for most users&amp;hellip; &amp;gt; @ImplicitProduces(&amp;ldquo;text/html;q=1.0&amp;rdquo;) &amp;gt; &amp;gt; @Produces(&amp;ldquo;text/xml;q=0.5, application/xml;q=0.5; application/json;q=0.5&amp;rdquo;) &amp;gt; &amp;gt; public class MyResource { &amp;gt; &amp;gt; &amp;hellip; &amp;gt; &amp;gt; } Those MIME Strings could be static final constants BTW to keep things DRY and not have to repeat a ton of MIME expressions throughout your resource beans and making it real easy to add a new MIME type to your code without changing your controller methods.
You could argue the out of the box rankings for HTML should be 1.0 and XML/JSON something lower, say 0.9 or 0.5 as thats what most folks would want.
Dealing with static content The Servlet spec is a tad smelly in this area (and even in servlet 3.0) of not easily allowing you to mark URI patterns as being handled by the container (e.g. for static content or for JSP files etc) and mapping all of the rest to your default servlet. Hopefully as Paul suggestswe can get around this using servlet filters in Jersey; but it&amp;rsquo;d be nicer if there was a better fix for this. (Rails wins here hands down with using regex to map URIs to controllers). But this is more a servlet issue than JAX-RS / web framework.
Multipart support Having support for Struts style form beans; binding a multipart to a bean is very handy.MrStruts himself has contributed jersey-multipart which goes most of the way there. Allowing direct binding with any bean to avoid having to use the MultiPart class directly would certainly help.
Standard JAX-RS client API like Jersey&amp;rsquo;s While not that relevant directly to web applications; being able to implement a REST service by invoking other RESTful services - or being able to test easily any RESTful service using an API like Jersey&amp;rsquo;s client - while reusing the cool entity providers on both client and server side - would rock.
GWT and JAX-RS client integration If you&amp;rsquo;re building JAX-RS services and want a rich web client then GWT is a great solution; you can reuse all your Java code on the client and server side and its very easy to debug the whole application in a single JVM in your Java IDE.
GWT ships with its own RPC mechanism and there are various REST libraries for GWT such as gwt-rest it&amp;rsquo;d be nice if there was an easy way to reuse the same DTOs used on the server side like you can with Jersey&amp;rsquo;s client library from inside GWT. Using JAXB inside GWT is probably non-feasaible :) but it should be pretty easy to just use GWT serialization and then support it as an entity provider in the JAX-RS runtime. (Is there a MIME type for GWT serialisation I wonder :).
Basically as an application developer it should be trivial to be able to reuse RESTful resources in JAX-RS inside the GWT client reusing all those DTOs if you want to.
Update: some other suggestions Julio Faerman mentioned on the Jersey list mentioned the need for better validation. So maybe we could integrate the validation layer from Struts/Stripes into JAX-RS? Or use the the Bean Validation API (JSR 303)?
Also Julio and Jon in the comments mentioned the need for managing conversational state so integrating Web Beans (JSR 299) as an option for bijection of conversational state on resource beans sounds a good possibility.
What else? Those are the things I can think of so far. Can you think of any others? What are there features in your favourite Struts/Stripes/SpringMVC/whatever framework on the server that you really can&amp;rsquo;t live without?
I&amp;rsquo;d love to hear others thoughts; do you think I&amp;rsquo;m smoking crack or do you agree? :)
</content>
    </entry>
    
     <entry>
        <title>Enumeration types</title>
        <url>http://yangchao.me/post/enumeration-types/</url>
        <categories>
          <category>Basics</category><category>Java 5</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html">  enum&amp;rsquo;s underlying implementation Define enumerated types by using enum keyword.
enum MetaColor { RED, YELLOW, BLUE } Now, MetaColor class has three final static members all of which are of MetaColor class: RED, YELLOW and BLUE
MetaColor has 2 static methods: values(), valueOf(..) and other instance methods: name(), ordinal() and toString(), hashCode(), equals().
You can override the toString(), but hashCode() and equals() are final which cannot be override. Actually, enum maintains a singleton for ever enum object, so overriding hashCode() and equals() is not required.
Although enums appear to be a new data type, the keyword only produces some compiler behavior while generating a class for the enum, so in many ways you can treat an **enum **as if it were any other class.
The following is the equivalent one like compiler generates:
class MetaColor extends Enum&amp;lt;MetaColor&amp;gt; { public final static MetaColor RED = new MetaColor(&amp;#34;RED&amp;#34;, 0); public final static MetaColor GREEN= new MetaColor(&amp;#34;GREEN&amp;#34;, 1); public final static MetaColor BLUE= new MetaColor(&amp;#34;BLUE&amp;#34;, 2); private MetaColor() {} } But if you really extend Enum class, the compiler will complain and the code cannot be compiled.
adding your own method, including constructor In fact, enums _are _classes and can have their own methods.
Of course, you can associate the enum instance with an inherit value or something.
enum MetaColor { RED(1), YELLOW(2), BLUE(3); private int value; // public MetaColor(int value) { // not permit  // protected MetaColor(int value) { // not permit  // private MetaColor(int value) { // permit  MetaColor(int value) { //permit  this.value = value; } public int value() { return this.value; } } some constraints In the above code, the constractor of MetaColor cannot be applied public or protected modifier.
And also you cannot instantiate the enum class by yourself.
go further: abstract enum public enum Season { WINTER(&amp;#34;WT&amp;#34;) { @Override public void execute( ) { System.out.println(&amp;#34;Winter...&amp;#34;); } }, SPRING(&amp;#34;SP&amp;#34;) { @Override public void execute( ) { System.out.println(&amp;#34;Spring....&amp;#34;); } }, SUMMER(&amp;#34;SM&amp;#34;) { @Override public void execute( ) { System.out.println(&amp;#34;Summer...&amp;#34;); } }, FALL(&amp;#34;FL&amp;#34;) { @Override public void execute( ) { System.out.println(&amp;#34;Fall...&amp;#34;); } }; //template method  public abstract void execute(); } &amp;nbsp;
immutable? No, enum object is not immutable on its own. But enum class limits the number and order of its instances, as we cannot initialize a new instance of the enum class.
That is the essential of enumerable class.
enum vs. static final variables What are the advantages of enums if compared with the traditional final static fields of a class?
 Enum class does the correct thing of what it can do and it&amp;rsquo;s designed just for the enumeration objects. Enum is just normal class, so the extensibility is far more than that of plain final static variables. Enum can be really self-descriptive.  </content>
    </entry>
    
     <entry>
        <title>variable argument list: a pitfall</title>
        <url>http://yangchao.me/post/variable-argument-list-a-pitfall/</url>
        <categories>
          <category>Basics</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html"> We usually define a method with a variable argument list like this:
void bar(String...args) { //blablab } But there is a pitfall in this place. Can you ensure args is always an array, even its length is 0 when it&amp;rsquo;s empty?
Yes, most of time.
obj.bar(); // here, args is a zero-length array BUT, things are not always like that.
You can see this:
obj.bar(null); Guess what? Here the args is also null. That&amp;rsquo;s it.
This is a pretty weird behavior! Naturally, we expect an array with one element the value of which should be null. But in reality, the reference to the array is null. Instead, we use the following solution for our intention:
obj.bar(new String[]{ null }); And what if I pass the null to more than 1 variable argument list?
obj.bar(null, &amp;#34;1&amp;#34;); Yes, it is obvious and expected that args is an array with two elements the values of which are null and &amp;ldquo;1&amp;rdquo; respectively. Alternatively, the following style is also the same:
obj.bar(new String[]{null, &amp;#34;1&amp;#34;}); To summarize, variable argument list is really of no secret.
It&amp;rsquo;s a sort of syntax sugar. 1) when only one actual parameter passes, 1.a if it is null, the argument array is null 1.b if it is of the type of element, then the argument array is a one-element array and the only element is the passed parameter 1.c if it is an array with the type of declared argument, then the argument array is just the passed array parameter.
2) when more than one actual parameters pass, then the argument array is a non-empty array and its elements are the passed parameters.
</content>
    </entry>
    
     <entry>
        <title>Default constructor (no-args constructor)</title>
        <url>http://yangchao.me/post/default-constructor-no-args-constructor/</url>
        <categories>
          <category>OOP</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html"> Default constructor is just synthesized by the compiler when you don&amp;rsquo;t define any constructor.
Once you define a constructor, the compiler won&amp;rsquo;t make one for you.
class C { public C(int a) { } public static void main(String[] args) { new C(); // so compiler will issue an error message here  } } &amp;nbsp;
</content>
    </entry>
    
     <entry>
        <title>Distinguish overloaded methods</title>
        <url>http://yangchao.me/post/distinguish-overloaded-methods/</url>
        <categories>
          <category>OOP</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html"> Each overloaded method must have a unique list of argument types.
This means that there are the following possible cases:
 argument count are different  void foo(int a) {} void foo(int a, String b) {}  argument types are different  void foo(int a) {} void foo(String b) {}  argument types are different, even if inheritance  void foo(List a) {} void foo(ArrayList a) {}  return types are different  void foo(int a) {} int foo(int b) { return 0; } NO!! This will have a compiler error.
When overloaded methods are invoked, compiler choose the best matched method by using the declared types of passing arguments.
So:
public static void main(String[] args) { List a = new ArrayList(); o.foo(a) // This will invoke the &amp;#34;void foo(List a) {}&amp;#34; method } because overloading is a static binding behavior and only occurs in compile time.
When considering which overloaded method will be invoked, you should always regard yourself as the compiler.
When it comes to the primitives, please see the following example:
class Demotion { void f1(char x) { System.out.println(&amp;#34;f1(ch&amp;lt;wbr /&amp;gt;ar)&amp;#34;); } void f1(byte x) { System.out.println(&amp;#34;f1(byte)&amp;#34;); } void f1(short x) { System.out.println(&amp;#34;f1(short)&amp;#34;); } void f1(int x) { System.out.println(&amp;#34;f1(int)&amp;#34;); } void f1(long x) { System.out.println(&amp;#34;f1(long)&amp;#34;); } void f1(float x) { System.out.println(&amp;#34;f1(float)&amp;#34;); } void f1(double x) { System.out.println(&amp;#34;f1(double)&amp;#34;); } void f2(char x) { System.out.println(&amp;#34;f2(char)&amp;#34;); } void f2(byte x) { System.out.println(&amp;#34;f2(byte)&amp;#34;); } void f2(short x) { System.out.println(&amp;#34;f2(short)&amp;#34;); } void f2(int x) { System.out.println(&amp;#34;f2(int)&amp;#34;); } void f2(long x) { System.out.println(&amp;#34;f2(long)&amp;#34;); } void f2(float x) { System.out.println(&amp;#34;f2(float)&amp;#34;); } void f3(char x) { System.out.println(&amp;#34;f3(char)&amp;#34;); } void f3(byte x) { System.out.println(&amp;#34;f3(byte)&amp;#34;); } void f3(short x) { System.out.println(&amp;#34;f3(short)&amp;#34;); } void f3(int x) { System.out.println(&amp;#34;f3(int)&amp;#34;); } void f3(long x) { System.out.println(&amp;#34;f3(long)&amp;#34;); } void f4(char x) { System.out.println(&amp;#34;f4(char)&amp;#34;); } void f4(byte x) { System.out.println(&amp;#34;f4(byte)&amp;#34;); } void f4(short x) { System.out.println(&amp;#34;f4(short)&amp;#34;); } void f4(int x) { System.out.println(&amp;#34;f4(int)&amp;#34;); } void f5(char x) { System.out.println(&amp;#34;f5(char)&amp;#34;); } void f5(byte x) { System.out.println(&amp;#34;f5(byte)&amp;#34;); } void f5(short x) { System.out.println(&amp;#34;f5(short)&amp;#34;); } void f6(char x) { System.out.println(&amp;#34;f6(char)&amp;#34;); } void f6(byte x) { System.out.println(&amp;#34;f6(byte)&amp;#34;); } void f7(char x) { System.out.println(&amp;#34;f7(char)&amp;#34;); } void testDouble() { double x = 0; System.out.println(&amp;#34;double argument:&amp;#34;); f1(x); f2((float) x); f3((long) x); f4((int) x); f5((short) x); f6((byte) x); f7((char) x); } public static void main(String[] args) { Demotion p = new Demotion(); p.testDouble(); } } Output is: &amp;gt; double argument: &amp;gt; &amp;gt; f1(double) &amp;gt; &amp;gt; f2(float) &amp;gt; &amp;gt; f3(long) &amp;gt; &amp;gt; f4(int) &amp;gt; &amp;gt; f5(short) &amp;gt; &amp;gt; f6(byte) &amp;gt; &amp;gt; f7(char)
From the above example, you can see the same rule: the compiler decide method binding in compile time and it always chooses the best and most possible method. When it is possible, it need casting a type to another. So when some wider types like double, float cast to some narrower types like int, short etc, the precision and width of number will be narrowed. If it cannot do this, an error message will be issued.
</content>
    </entry>
    
     <entry>
        <title>Override: a pitfall</title>
        <url>http://yangchao.me/post/override-a-pitfall/</url>
        <categories>
          <category>OOP</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html"> Let&amp;rsquo;s see the flowing program and guess the run result:
class Animal { protected void drink() { System.out.println(&amp;#34;animal drinks before eating&amp;#34;); } public void eat() { this.drink(); } } public class Dog extends Animal { protected void drink() { System.out.println(&amp;#34;dog drinks before eating&amp;#34;); } public void eat() { super.eat(); } public static void main(String[] args) { Animal animal = new Dog(); animal.eat(); } } Yes, the result it: dog drinks before eating. And why?
Overridden just occurs in run time. So it is also called dynamic binding.
In run time, you must always trace the real object reference.
In the aforementioned example, there is only one object both super and _this _refer.
Animal animal = new Dog(); animal.eat(); // because the real type of animal is Dog, so the eat() method uses the overridden version of eat().
super.eat(); It specifically invokes the methods of its parent.
this.drink(); OK, now _this _refers dog object, so polymorphism occurs once again. So it just use the overridden version of drink().
Anyway, that&amp;rsquo;s it.
</content>
    </entry>
    
     <entry>
        <title>Java access control</title>
        <url>http://yangchao.me/post/java-access-control/</url>
        <categories>
          <category>Basics</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html">  Java access control is a bit weird, especially for the ones with C&#43;&#43; background.
There are two types of access control, one for classes and the other for members. To simplify my discussion, in this context the class mean the top level one, which is directly defined in a compile unit. As the nested class is actually always associated with another class, so it&amp;rsquo;s not top level class and I regard it as just a member like member variables and member methods.
P.S: package access control has no specifier.
Class access control Class access control has just two: public, package.
NOTE: A java file must contain ONE public class at most. If a public class exists, its name must be the same as the file name.
Class access control is mainly used for the visibility to other package or class. It can influence the fact whether you can import the class. It can be more convenient if you understand the access of one class as whether you can see it from somewhere.
If you declare some class as package access control, it is only accessed by the classes with the same package.
In this point, you will think it&amp;rsquo;s really reasonable why a class cannot be declared as private or protected.
Member access control Class member access control I simply think static fields or methods as the member of a class.
The rules are similar with the ones of object members access control, so I don&amp;rsquo;t plan to discuss them separately.
Object member access control Object members can be declared as: public, protected, package, private. In this order, the access is more and more limited.
Public: anything can access, object members by object and static members by class. Protected: package and inherited class can access. Package: package class can access Private: just the class itself can access
Now I will discuss other modifiers: static, abstract, final
The meaning of static is very notable, and abstract and final is mutual.
static can be just used for members(fields, methods, nested classes, static initialization block), not top level classes.
abstract class (as well as the nested class): Abstract class has zero or more than one method being left unimplemented.
abstract member method: This method has no body. And the class of this method must be also abstract.
final class (as well as the nested class): Final class means it cannot be inherited.
final member method: This method cannot be overridden.
final member field: This field is unchangeable once initialized. (Primitive field cannot be changed to another value; Object reference field cannot be changed to another object reference)
NOTE: Final object reference field doesn&amp;rsquo;t necessarily mean that the object it refers is unchangeable. The fields/properties of the object can be changed at its will. **The declaration of final CANNOT ensure an immutable object. **
Sometimes, it needn&amp;rsquo;t declare the specifiers explicitly, as there are some defaults.
interface: abstract (interface can be public or package) interface member field: public static final interface member method: public abstract
More comprehensive discussions, please refer to java modifiers review
</content>
    </entry>
    
     <entry>
        <title>Java Object Initialization Order</title>
        <url>http://yangchao.me/post/java-object-initialization-order/</url>
        <categories>
          <category>OOP</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html"> See the following program, and you guess the running result:
public class Dog { public static Dog dog = new Dog(); static final int val1 = -5; static int val2 = 3; public int val3; public Dog() { val3 = val1 &#43; val2; } public static void main(String[] args) { System.out.println(Dog.dog.val3); } } Now, I tell you the result is -5. But why?
To clarify this confusing initialization order, you must know a little about the memory layout and what the JVM do (imagine yourself as the compiler and VM).
Because static fields belong to the Class which located in the method area of JVM. The class initialization occurs in the class loading process by the class loader. The process is more or less like the one of plain object initialization other than the member fields of classes are static and class initialization doesn&amp;rsquo;t invoke any user-defined constructor.
One thing I must mention is that -5 is just CONSTANT, so assigning it to val1 means it is hard-corded into class file at compile-time. Therefore, final class variables and fields of interfaces whose values are compile-time constants are initialized first. 具有编译器常量的final类变量首先初始化！！ http://docs.oracle.com/javase/sp&amp;hellip;
Next, execute either the class variable initializers and static initializers of the class, or the field initializers of the interface, in textual order, as though they were a single block, except that final class variables and fields of interfaces whose values are compile-time constants are initialized first (§8.3.2.1, §9.3.1, §13.4.9).
To verify your thought, please see the decompiled bytecodes:
 Classfile /playground/bin/playground/Dog.class Last modified Aug 25, 2016; size 725 bytes MD5 checksum 73b977e92851a8923319ee5a1032171a Compiled from &amp;quot;Dog.java&amp;quot; public class playground.Dog SourceFile: &amp;quot;Dog.java&amp;quot; minor version: 0 major version: 51 flags: ACC_PUBLIC, ACC_SUPER Constant pool: #1 = Class #2 // playground/Dog #2 = Utf8 playground/Dog #3 = Class #4 // java/lang/Object #4 = Utf8 java/lang/Object #5 = Utf8 dog #6 = Utf8 Lplayground/Dog; #7 = Utf8 val1 #8 = Utf8 I #9 = Utf8 ConstantValue #10 = Integer -5 #11 = Utf8 val2 #12 = Utf8 val3 #13 = Utf8 &amp;lt;clinit&amp;gt; #14 = Utf8 ()V #15 = Utf8 Code #16 = Methodref #1.#17 // playground/Dog.&amp;quot;&amp;lt;init&amp;gt;&amp;quot;:()V #17 = NameAndType #18:#14 // &amp;quot;&amp;lt;init&amp;gt;&amp;quot;:()V #18 = Utf8 &amp;lt;init&amp;gt; #19 = Fieldref #1.#20 // playground/Dog.dog:Lplayground/Dog; #20 = NameAndType #5:#6 // dog:Lplayground/Dog; #21 = Fieldref #1.#22 // playground/Dog.val2:I #22 = NameAndType #11:#8 // val2:I #23 = Utf8 LineNumberTable #24 = Utf8 LocalVariableTable #25 = Methodref #3.#17 // java/lang/Object.&amp;quot;&amp;lt;init&amp;gt;&amp;quot;:()V #26 = Fieldref #1.#27 // playground/Dog.val3:I #27 = NameAndType #12:#8 // val3:I #28 = Utf8 this #29 = Utf8 main #30 = Utf8 ([Ljava/lang/String;)V #31 = Fieldref #32.#34 // java/lang/System.out:Ljava/io/PrintStream; #32 = Class #33 // java/lang/System #33 = Utf8 java/lang/System #34 = NameAndType #35:#36 // out:Ljava/io/PrintStream; #35 = Utf8 out #36 = Utf8 Ljava/io/PrintStream; #37 = Methodref #38.#40 // java/io/PrintStream.println:(I)V #38 = Class #39 // java/io/PrintStream #39 = Utf8 java/io/PrintStream #40 = NameAndType #41:#42 // println:(I)V #41 = Utf8 println #42 = Utf8 (I)V #43 = Utf8 args #44 = Utf8 [Ljava/lang/String; #45 = Utf8 SourceFile #46 = Utf8 Dog.java { public static playground.Dog dog; flags: ACC_PUBLIC, ACC_STATIC static final int val1; flags: ACC_STATIC, ACC_FINAL ConstantValue: int -5 static int val2; flags: ACC_STATIC public int val3; flags: ACC_PUBLIC static {}; flags: ACC_STATIC Code: stack=2, locals=0, args_size=0 0: new #1 // class playground/Dog 3: dup 4: invokespecial #16 // Method &amp;quot;&amp;lt;init&amp;gt;&amp;quot;:()V 7: putstatic #19 // Field dog:Lplayground/Dog; 10: iconst_3 11: putstatic #21 // Field val2:I 14: return LineNumberTable: line 4: 0 line 6: 10 LocalVariableTable: Start Length Slot Name Signature public playground.Dog(); flags: ACC_PUBLIC Code: stack=3, locals=1, args_size=1 0: aload_0 1: invokespecial #25 // Method java/lang/Object.&amp;quot;&amp;lt;init&amp;gt;&amp;quot;:()V 4: aload_0 5: bipush -5 7: getstatic #21 // Field val2:I 10: iadd 11: putfield #26 // Field val3:I 14: return LineNumberTable: line 8: 0 line 9: 4 line 10: 14 LocalVariableTable: Start Length Slot Name Signature 0 15 0 this Lplayground/Dog; public static void main(java.lang.String[]); flags: ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=1, args_size=1 0: getstatic #31 // Field java/lang/System.out:Ljava/io/PrintStream; 3: getstatic #19 // Field dog:Lplayground/Dog; 6: getfield #26 // Field val3:I 9: invokevirtual #37 // Method java/io/PrintStream.println:(I)V 12: return LineNumberTable: line 12: 0 line 13: 12 LocalVariableTable: Start Length Slot Name Signature 0 13 0 args [Ljava/lang/String; }  Let&amp;rsquo;s illustrate the whole process using pictures:  To summarize the process of creating an object, consider a class called Dog: 1). Even though it doesn’t explicitly use the static keyword, the constructor is actually a static method. So the first time an object of type Dog is created, _or_the first time a static method or static field of class Dog is accessed, the Java interpreter must locate Dog.class, which it does by searching through the classpath. 2). As Dog.class is loaded (creating a Class object, which you’ll learn about later), all of its static initializers are run. Thus, static initialization takes place only once, as the Class object is loaded for the first time. 3). When you create a new Dog( ), the construction process for a Dog object first allocates enough storage for a Dog object on the heap. 4). This storage is wiped to zero, automatically setting all the primitives in that Dog object to their default values (zero for numbers and the equivalent for boolean and char) and the references to null. 5). Any initializations that occur at the point of field definition are executed. 6). Constructors are executed. This might actually involve a fair amount of activity, especially when inheritance is involved.
&amp;nbsp;
The following is a complicated example:
public class Test { private static int k = 1; private static Test t1 = new Test(&amp;#34;t1&amp;#34;); private static Test t2 = new Test(&amp;#34;t2&amp;#34;); private static int n = 99; private static int j = print(&amp;#34;j&amp;#34;); private int i = print(&amp;#34;i&amp;#34;); { print(&amp;#34;构造块&amp;#34;); } static { print(&amp;#34;静态构造块&amp;#34;); } public Test(String str) { System.out.println((&#43;&#43;k) &#43; &amp;#34;:&amp;#34; &#43; str &#43;&amp;#34; j=&amp;#34;&#43;j&#43;&amp;#34; n=&amp;#34;&#43;n); &#43;&#43;j; &#43;&#43;n; } public static int print(String str) { System.out.println((&#43;&#43;k) &#43; &amp;#34;:&amp;#34; &#43; str &#43;&amp;#34; j=&amp;#34;&#43;j&#43;&amp;#34; n=&amp;#34;&#43;n); &#43;&#43;n; return &#43;&#43;j; } public static void main(String[] args) { } } the result is:
2:i j=0 n=0 3:构造块 j=1 n=1 4:t1 j=2 n=2 5:i j=3 n=3 6:构造块 j=4 n=4 7:t2 j=5 n=5 8:j j=6 n=99 9:静态构造块 j=7 n=100
&amp;nbsp;
</content>
    </entry>
    
     <entry>
        <title>Posts</title>
        <url>http://yangchao.me/post/</url>
        <categories>
          
        </categories>
        <tags>
          
        </tags>
        <content type="html"> </content>
    </entry>
    
</search>